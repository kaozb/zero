
<!DOCTYPE html>

<html lang="zh_Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>执行查询 &#8212; Django 4.2.6.dev20230904111759 文档</title>
    <link rel="stylesheet" type="text/css" href="../../static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../static/default.css" />
    <script data-url_root="../../" id="documentation_options" src="../../static/documentation_options.js"></script>
    <script src="../../static/jquery.js"></script>
    <script src="../../static/underscore.js"></script>
    <script src="../../static/doctools.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="聚合" href="aggregation.html" />
    <link rel="prev" title="模型" href="models.html" />



 
<script src="../../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django 4.2.6.dev20230904111759 文档</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>  |
        <a title="Table of contents" href="../../contents.html">Table of contents</a>  |
        <a title="Global index" href="../../genindex.html">Index</a>  |
        <a title="Module index" href="../../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="models.html" title="模型">previous</a>
     |
    <a href="../index.html" title="使用 Django" accesskey="U">up</a>
   |
    <a href="aggregation.html" title="聚合">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-db-queries">
            
  <div class="section" id="s-making-queries">
<span id="making-queries"></span><h1>执行查询<a class="headerlink" href="#making-queries" title="永久链接至标题">¶</a></h1>
<p>一旦创建 <a class="reference internal" href="models.html"><span class="doc">数据模型</span></a> 后，Django 自动给予你一套数据库抽象 API，允许你创建，检索，更新和删除对象。本页介绍如何使用这些 API。参考 <a class="reference internal" href="../../ref/models/index.html"><span class="doc">数据模型参考</span></a> 获取所有查询选项的完整细节。</p>
<p>在本指南中（以及在参考资料中），我们将提及以下模型，它们构成了一个博客应用程序：</p>
<div class="highlight-python notranslate" id="queryset-model-example"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>

<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">mod_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">)</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">number_of_comments</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">number_of_pingbacks</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
</div>
<div class="section" id="s-creating-objects">
<span id="creating-objects"></span><h2>创建对象<a class="headerlink" href="#creating-objects" title="永久链接至标题">¶</a></h2>
<p>为了用 Python 对象展示数据表对象，Django 使用了一套直观的系统：一个模型类代表一张数据表，一个模型类的实例代表数据库表中的一行记录。</p>
<p>要创建一个对象，用关键字参数初始化它，然后调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 将其存入数据库。</p>
<p>Assuming models live in a file <code class="docutils literal notranslate"><span class="pre">mysite/blog/models.py</span></code>, here's an example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;All the latest Beatles news.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>这在幕后执行了 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> SQL 语句。Django 在你显式调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 才操作数据库。</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法没有返回值。</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 接受很多此处未介绍的高级选项。参考文档 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 获取完整细节。</p>
<p class="last">要一步创建并保存一个对象，使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> 方法。</p>
</div>
</div>
<div class="section" id="s-saving-changes-to-objects">
<span id="saving-changes-to-objects"></span><h2>将修改保存至对象<a class="headerlink" href="#saving-changes-to-objects" title="永久链接至标题">¶</a></h2>
<p>要将修改保存至数据库中已有的某个对象，使用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>。</p>
<p>Given a <code class="docutils literal notranslate"><span class="pre">Blog</span></code> instance <code class="docutils literal notranslate"><span class="pre">b5</span></code> that has already been saved to the database,
this example changes its name and updates its record in the database:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;New name&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>这在幕后执行了 <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> SQL 语句。Django 在你显示调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 后才操作数据库。</p>
<div class="section" id="s-saving-foreignkey-and-manytomanyfield-fields">
<span id="saving-foreignkey-and-manytomanyfield-fields"></span><h3>保存 <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 字段<a class="headerlink" href="#saving-foreignkey-and-manytomanyfield-fields" title="永久链接至标题">¶</a></h3>
<p>Updating a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> field works exactly the same
way as saving a normal field -- assign an object of the right type to the field
in question. This example updates the <code class="docutils literal notranslate"><span class="pre">blog</span></code> attribute of an <code class="docutils literal notranslate"><span class="pre">Entry</span></code>
instance <code class="docutils literal notranslate"><span class="pre">entry</span></code>, assuming appropriate instances of <code class="docutils literal notranslate"><span class="pre">Entry</span></code> and <code class="docutils literal notranslate"><span class="pre">Blog</span></code>
are already saved to the database (so we can retrieve them below):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Blog</span><span class="p">,</span> <span class="n">Entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cheese_blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cheddar Talk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">cheese_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>Updating a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> works a little
differently -- use the
<a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> method on the field
to add a record to the relation. This example adds the <code class="docutils literal notranslate"><span class="pre">Author</span></code> instance
<code class="docutils literal notranslate"><span class="pre">joe</span></code> to the <code class="docutils literal notranslate"><span class="pre">entry</span></code> object:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Author</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">joe</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Joe&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">joe</span><span class="p">)</span>
</pre></div>
</div>
<p>To add multiple records to a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> in one
go, include multiple arguments in the call to
<a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, like this:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;John&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paul</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Paul&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">george</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;George&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringo</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ringo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">john</span><span class="p">,</span> <span class="n">paul</span><span class="p">,</span> <span class="n">george</span><span class="p">,</span> <span class="n">ringo</span><span class="p">)</span>
</pre></div>
</div>
<p>Django 会在添加或指定错误类型的对象时报错。</p>
</div>
</div>
<div class="section" id="s-retrieving-objects">
<span id="s-id1"></span><span id="retrieving-objects"></span><span id="id1"></span><h2>检索对象<a class="headerlink" href="#retrieving-objects" title="永久链接至标题">¶</a></h2>
<p>要从数据库检索对象，要通过模型类的 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 构建一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。</p>
<p>一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 代表来自数据库中对象的一个集合。它可以有 0 个，1 个或者多个 <em>filters</em>. Filters，可以根据给定参数缩小查询结果量。在 SQL 的层面上， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 对应 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 语句，而*filters*对应类似 <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 或 <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> 的限制子句。</p>
<p>You get a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> by using your model's
<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>. Each model has at least one
<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>, and it's called
<a class="reference internal" href="../../ref/models/class.html#django.db.models.Model.objects" title="django.db.models.Model.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> by default. Access it directly via the
model class, like so:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span>
<span class="go">&lt;django.db.models.manager.Manager object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Bar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">objects</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager isn&#39;t accessible via Blog instances.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Managers</span></code> 只能通过模型类访问，而不是通过模型实例，目的是强制分离 “表级” 操作和 “行级” 操作。</p>
</div>
<p><a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 是模型的 <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> 主要来源。例如 <code class="docutils literal notranslate"><span class="pre">Blog.objects.all()</span></code> 返回了一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，后者包含了数据库中所有的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象。</p>
<div class="section" id="s-retrieving-all-objects">
<span id="retrieving-all-objects"></span><h3>检索全部对象<a class="headerlink" href="#retrieving-all-objects" title="永久链接至标题">¶</a></h3>
<p>The simplest way to retrieve objects from a table is to get all of them. To do
this, use the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> method on a
<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">all_entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>方法 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> 返回了一个包含数据库中所有对象的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 对象。</p>
</div>
<div class="section" id="s-retrieving-specific-objects-with-filters">
<span id="retrieving-specific-objects-with-filters"></span><h3>通过过滤器检索指定对象<a class="headerlink" href="#retrieving-specific-objects-with-filters" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> 返回的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 包含了数据表中所有的对象。虽然，大多数情况下，你只需要完整对象集合的一个子集。</p>
<p>要创建一个这样的子集，你需要通过添加过滤条件精炼原始 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。两种最常见的精炼 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的方式是：</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">filter(**kwargs)</span></code></dt><dd>返回一个新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，包含的对象满足给定查询参数。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exclude(**kwargs)</span></code></dt><dd>返回一个新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，包含的对象 <em>不</em> 满足给定查询参数。</dd>
</dl>
<p>查询参数（<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>）应该符合下面的 <a class="reference internal" href="#field-lookups">Field lookups</a> 的要求。</p>
<p>例如，要包含获取 2006 年的博客条目（entries blog）的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，像这样使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<p>通过默认管理器类也一样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-chaining-filters">
<span id="s-id2"></span><span id="chaining-filters"></span><span id="id2"></span><h4>链式过滤器<a class="headerlink" href="#chaining-filters" title="永久链接至标题">¶</a></h4>
<p>The result of refining a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> is itself a
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>, so it's possible to chain
refinements together. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
</pre></div>
</div>
<p>这个先获取包含数据库所有条目（entry）的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，然后排除一些，再进入另一个过滤器。最终的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 包含标题以 &quot;What&quot; 开头的，发布日期介于 2005 年 1 月 30 日与今天之间的所有条目。</p>
</div>
<div class="section" id="s-filtered-querysets-are-unique">
<span id="s-id3"></span><span id="filtered-querysets-are-unique"></span><span id="id3"></span><h4>每个 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 都是唯一的<a class="headerlink" href="#filtered-querysets-are-unique" title="永久链接至标题">¶</a></h4>
<p>每次精炼一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，你就会获得一个全新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，后者与前者毫无关联。每次精炼都会创建一个单独的、不同的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，能被存储，使用和复用。</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q3</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
</pre></div>
</div>
<p>这三个 <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> 是独立的。第一个是基础 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，包含了所有标题以 &quot;What&quot; 开头的条目。第二个是第一个的子集，带有额外条件，排除了 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> 是今天和今天之后的所有记录。第三个是第一个的子集，带有额外条件，只筛选 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> 是今天或未来的所有记录。最初的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> (<code class="docutils literal notranslate"><span class="pre">q1</span></code>) 不受筛选操作影响。</p>
</div>
<div class="section" id="s-querysets-are-lazy">
<span id="s-id4"></span><span id="querysets-are-lazy"></span><span id="id4"></span><h4><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 是惰性的<a class="headerlink" href="#querysets-are-lazy" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> are lazy -- the act of creating a
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> doesn't involve any database
activity. You can stack filters together all day long, and Django won't
actually run the query until the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> is
<em>evaluated</em>. Take a look at this example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">body_text__icontains</span><span class="o">=</span><span class="s2">&quot;food&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>虽然这看起来像是三次数据库操作，实际上只在最后一行 (<code class="docutils literal notranslate"><span class="pre">print(q)</span></code>) 做了一次。一般来说， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的结果直到你 “要使用” 时才会从数据库中拿出。当你要用时，才通过数据库 <em>计算</em> 出 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。关于何时才真的执行计算的更多细节，参考 <a class="reference internal" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><span class="std std-ref">什么时候 QuerySet 被执行</span></a>。</p>
</div>
</div>
<div class="section" id="s-retrieving-a-single-object-with-get">
<span id="s-retrieving-single-object-with-get"></span><span id="retrieving-a-single-object-with-get"></span><span id="retrieving-single-object-with-get"></span><h3>用 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 检索单个对象<a class="headerlink" href="#retrieving-a-single-object-with-get" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 总是返回一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，即便只有一个对象满足查询条件 —— 这种情况下， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 只包含了一个元素。</p>
<p>If you know there is only one object that matches your query, you can use the
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> method on a
<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> which returns the object directly:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">one_entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以对 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 使用与 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 类似的所有查询表达式 —— 同样的，参考下面的 <a class="reference internal" href="#field-lookups">Field lookups</a>。</p>
<p>注意， 使用切片 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 时的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 有点不同。如果没有满足查询条件的结果， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 会抛出一个 <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> 异常。该异常是执行查询的模型类的一个属性 —— 所有，上述代码中，若没有哪个 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象的主键是 1，Django 会抛出 <code class="docutils literal notranslate"><span class="pre">Entry.DoesNotExist</span></code>。</p>
<p>类似了，Django 会在有不止一个记录满足 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 查询条件时发出警告。这时，Django 会抛出 <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultipleObjectsReturned</span></code></a>，这同样也是模型类的一个属性。</p>
</div>
<div class="section" id="s-other-queryset-methods">
<span id="other-queryset-methods"></span><h3>其它 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法<a class="headerlink" href="#other-queryset-methods" title="永久链接至标题">¶</a></h3>
<p>大多数情况下，你会在需要从数据库中检索对象时使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a>。然而，这样远远不够；完整的各种 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法请参阅 <a class="reference internal" href="../../ref/models/querysets.html#queryset-api"><span class="std std-ref">QuerySet&nbsp;API 参考</span></a>。</p>
</div>
<div class="section" id="s-limiting-querysets">
<span id="s-id5"></span><span id="limiting-querysets"></span><span id="id5"></span><h3>限制 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 条目数<a class="headerlink" href="#limiting-querysets" title="永久链接至标题">¶</a></h3>
<p>利用 Python 的数组切片语法将 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 切成指定长度。这等价于 SQL 的 <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">OFFSET</span></code> 子句。</p>
<p>For example, this returns the first 5 objects (<code class="docutils literal notranslate"><span class="pre">LIMIT</span> <span class="pre">5</span></code>):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>This returns the sixth through tenth objects (<code class="docutils literal notranslate"><span class="pre">OFFSET</span> <span class="pre">5</span> <span class="pre">LIMIT</span> <span class="pre">5</span></code>):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>不支持负索引 (例如 <code class="docutils literal notranslate"><span class="pre">Entry.objects.all()[-1]</span></code>)</p>
<p>Generally, slicing a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> returns a new
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> -- it doesn't evaluate the query. An
exception is if you use the &quot;step&quot; parameter of Python slice syntax. For
example, this would actually execute the query in order to return a list of
every <em>second</em> object of the first 10:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>由于对 queryset 切片工作方式的模糊性，禁止对其进行进一步的排序或过滤。</p>
<p>To retrieve a <em>single</em> object rather than a list
(e.g. <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">foo</span> <span class="pre">FROM</span> <span class="pre">bar</span> <span class="pre">LIMIT</span> <span class="pre">1</span></code>), use an index instead of a slice. For
example, this returns the first <code class="docutils literal notranslate"><span class="pre">Entry</span></code> in the database, after ordering
entries alphabetically by headline:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>This is roughly equivalent to:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>然而，注意一下，若没有对象满足给定条件，前者会抛出 <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>，而后者会抛出 <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code>。参考 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 获取更多细节。</p>
</div>
<div class="section" id="s-field-lookups">
<span id="s-field-lookups-intro"></span><span id="field-lookups"></span><span id="field-lookups-intro"></span><h3>字段查询<a class="headerlink" href="#field-lookups" title="永久链接至标题">¶</a></h3>
<p>字段查询即你如何制定 SQL <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 子句。它们以关键字参数的形式传递给 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>。</p>
<p>Basic lookups keyword arguments take the form <code class="docutils literal notranslate"><span class="pre">field__lookuptype=value</span></code>.
(That's a double-underscore). For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="s2">&quot;2006-01-01&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>转换为 SQL 语句大致如下：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">blog_entry</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">pub_date</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="s1">&#39;2006-01-01&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition-how-this-is-possible admonition">
<p class="first admonition-title">这是怎么做到的</p>
<p class="last">Python 能定义可接受任意数量 name-value 参数的函数，参数名和值均在运行时计算。更多信息，请参考官方 Python 教程中的 <a class="reference external" href="https://docs.python.org/3/tutorial/controlflow.html#tut-keywordargs" title="(在 Python v3.11)"><span>Keyword Arguments</span></a>。</p>
</div>
<p>查询子句中指定的字段必须是模型的一个字段名。不过也有个例外，在 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 中，你可以指定以 <code class="docutils literal notranslate"><span class="pre">_id</span></code> 为后缀的字段名。这种情况下，value 参数需要包含 foreign 模型的主键的原始值。例子：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog_id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>若你传入了无效的关键字参数，查询函数会抛出 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>。</p>
<p>数据库 API 支持两套查询类型；完整参考文档位于 <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">字段查询参考</span></a>。为了让你了解能干啥，以下是一些常见的查询：</p>
<dl class="docutils">
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a></dt><dd><p>An &quot;exact&quot; match. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__exact</span><span class="o">=</span><span class="s2">&quot;Cat bites dog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>会生成这些 SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Cat bites dog&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>若你为提供查询类型 —— 也就说，若关键字参数未包含双下划线 —— 查询类型会被指定为 <code class="docutils literal notranslate"><span class="pre">exact</span></code>。</p>
<p>For example, the following two statements are equivalent:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
</pre></div>
</div>
<p>这是为了方便，因为 <code class="docutils literal notranslate"><span class="pre">exact</span></code> 查询是最常见的。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a></dt><dd><p>A case-insensitive match. So, the query:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s2">&quot;beatles blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>会匹配标题为 <code class="docutils literal notranslate"><span class="pre">&quot;Beatles</span> <span class="pre">Blog&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">&quot;beatles</span> <span class="pre">blog&quot;</span></code>， 甚至 <code class="docutils literal notranslate"><span class="pre">&quot;BeAtlES</span> <span class="pre">blOG&quot;</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code>。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a></dt><dd><p>大小写敏感的包含测试。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>粗略地转为 SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>注意这将匹配标题 <code class="docutils literal notranslate"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></code>。</p>
<p>这也有个大小写不敏感的版本， <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">icontains</span></code></a>。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">startswith</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">endswith</span></code></a></dt><dd>以……开头和以……结尾的查找。当然也有大小写不敏感的版本，名为 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">istartswith</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iendswith</span></code></a>。</dd>
</dl>
<p>同样，这只介绍了皮毛。完整的参考能在 <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">field&nbsp;查询参考</span></a> 找到。</p>
</div>
<div class="section" id="s-lookups-that-span-relationships">
<span id="s-id6"></span><span id="lookups-that-span-relationships"></span><span id="id6"></span><h3>跨关系查询<a class="headerlink" href="#lookups-that-span-relationships" title="永久链接至标题">¶</a></h3>
<p>Django 提供了一种强大而直观的方式来“追踪”查询中的关系，在幕后自动为你处理 SQL <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> 关系。为了跨越关系，跨模型使用关联字段名，字段名由双下划线分割，直到拿到想要的字段。</p>
<p>This example retrieves all <code class="docutils literal notranslate"><span class="pre">Entry</span></code> objects with a <code class="docutils literal notranslate"><span class="pre">Blog</span></code> whose <code class="docutils literal notranslate"><span class="pre">name</span></code>
is <code class="docutils literal notranslate"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>跨域的深度随你所想。</p>
<p>它也可以反向工作。虽然它 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">可以自定义</span></code></a>，默认情况下，你在查找中使用模型的小写名称来引用一个 “反向” 关系。</p>
<p>This example retrieves all <code class="docutils literal notranslate"><span class="pre">Blog</span></code> objects which have at least one <code class="docutils literal notranslate"><span class="pre">Entry</span></code>
whose <code class="docutils literal notranslate"><span class="pre">headline</span></code> contains <code class="docutils literal notranslate"><span class="pre">'Lennon'</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你在跨多个关系进行筛选，而某个中间模型的没有满足筛选条件的值，Django  会将它当做一个空的（所有值都是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>）但是有效的对象。这样就意味着不会抛出错误。例如，在这个过滤器中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>（假设有个关联的 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 模型），若某项条目没有任何关联的 <code class="docutils literal notranslate"><span class="pre">author</span></code>，它会被视作没有关联的 <code class="docutils literal notranslate"><span class="pre">name</span></code>，而不是因为缺失 <code class="docutils literal notranslate"><span class="pre">author</span></code> 而抛出错误。大多数情况下，这就是你期望的。唯一可能使你迷惑的场景是在使用 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a> 时。因此:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>将会返回 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象，包含 <code class="docutils literal notranslate"><span class="pre">author</span></code> 的 <code class="docutils literal notranslate"><span class="pre">name</span></code> 为空的对象，以及那些 <code class="docutils literal notranslate"><span class="pre">entry</span></code> 的 <code class="docutils literal notranslate"><span class="pre">author</span></code> 为空的对象。若你不想要后面的对象，你可以这样写:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__isnull</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-spanning-multi-valued-relationships">
<span id="s-id7"></span><span id="spanning-multi-valued-relationships"></span><span id="id7"></span><h4>跨多值关联<a class="headerlink" href="#spanning-multi-valued-relationships" title="永久链接至标题">¶</a></h4>
<p>当跨越 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 或反查 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> （例如从 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> ）时，对多个属性进行过滤会产生这样的问题：是否要求每个属性都在同一个相关对象中重合。我们可能会寻找那些在标题中含有 <em>“Lennon”</em> 的 2008 年的博客，或者我们可能会寻找那些仅有 2008 年的任何条目以及一些在标题中含有 <em>“Lennon”</em> 的较新或较早的条目。</p>
<p>要选择所有包含 2008 年至少一个标题中有 <em>&quot;Lennon&quot;</em> 的条目的博客（满足两个条件的同一条目），我们要写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span> <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
</div>
<p>否则，如果要执行一个更为宽松的查询，选择任何只在标题中带有 <em>&quot;Lennon&quot;</em> 的条目和 2008 年的条目的博客，我们将写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span>
<span class="p">)</span>
</pre></div>
</div>
<p>假设只有一个博客既有包含 <em>&quot;Lennon&quot;</em> 的条目又有 2008 年的条目，但 2008 年的条目中没有包含 <em>&quot;Lennon&quot;</em> 。第一个查询不会返回任何博客，但第二个查询会返回那一个博客。（这是因为第二个过滤器选择的条目可能与第一个过滤器中的条目相同，也可能不相同）。我们是用每个过滤器语句来过滤 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 项，而不是 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 项）。简而言之，如果每个条件需要匹配相同的相关对象，那么每个条件应该包含在一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code> 调用中。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p>由于第二个（更宽松的）查询链接了多个过滤器，它对主模型进行了多次连接，可能会产生重复的结果。</p>
<div class="doctest last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Beatles Blog&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pop</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Pop Music Blog&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s1">&#39;New Lennon Biography&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: New Lennon Biography&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s1">&#39;New Lennon Biography in Paperback&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: New Lennon Biography in Paperback&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">pop</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s1">&#39;Best Albums of 2008&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: Best Albums of 2008&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">pop</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s1">&#39;Lennon Would Have Loved Hip Hop&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: Lennon Would Have Loved Hip Hop&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s1">&#39;Lennon&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s1">&#39;Lennon&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;, &lt;Blog: Beatles Blog&gt;, &lt;Blog: Pop Music Blog]&gt;</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 的查询行为会跨越多值关联，就像前文说的那样，并不与 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 相同。相反，一次 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 调用的条件并不需要指向同一项目。</p>
<p>例如，以下查询会排除那些关联条目标题包含 <em>&quot;Lennon&quot;</em> 且发布于 2008 年的博客:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>但是，与 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 的行为不同，其并不会限制博客同时满足这两种条件。要这么做的话，也就是筛选出所有条目标题不带 <em>&quot;Lennon&quot;</em> 且发布年不是 2008 的博客，你需要做两次查询:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__in</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
        <span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-filters-can-reference-fields-on-the-model">
<span id="s-using-f-expressions-in-filters"></span><span id="filters-can-reference-fields-on-the-model"></span><span id="using-f-expressions-in-filters"></span><h3>过滤器可以为模型指定字段<a class="headerlink" href="#filters-can-reference-fields-on-the-model" title="永久链接至标题">¶</a></h3>
<p>在之前的例子中，我们已经构建过的 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 都是将模型字段值与常量做比较。但是，要怎么做才能将模型字段值与同一模型中的另一字段做比较呢？</p>
<p>Django 提供了 <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">表达式</span></code></a> 实现这种比较。 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 的实例充当查询中的模型字段的引用。这些引用可在查询过滤器中用于在同一模型实例中比较两个不同的字段。</p>
<p>For example, to find a list of all blog entries that have had more comments
than pingbacks, we construct an <code class="docutils literal notranslate"><span class="pre">F()</span></code> object to reference the pingback count,
and use that <code class="docutils literal notranslate"><span class="pre">F()</span></code> object in the query:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">number_of_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Django supports the use of addition, subtraction, multiplication,
division, modulo, and power arithmetic with <code class="docutils literal notranslate"><span class="pre">F()</span></code> objects, both with constants
and with other <code class="docutils literal notranslate"><span class="pre">F()</span></code> objects. To find all the blog entries with more than
<em>twice</em> as many comments as pingbacks, we modify the query:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">number_of_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>To find all the entries where the rating of the entry is less than the
sum of the pingback count and comment count, we would issue the
query:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">rating__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_comments&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the double underscore notation to span relationships in
an <code class="docutils literal notranslate"><span class="pre">F()</span></code> object. An <code class="docutils literal notranslate"><span class="pre">F()</span></code> object with a double underscore will introduce
any joins needed to access the related object. For example, to retrieve all
the entries where the author's name is the same as the blog name, we could
issue the query:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">authors__name</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;blog__name&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>For date and date/time fields, you can add or subtract a
<a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(在 Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> object. The following would return all entries
that were modified more than 3 days after they were published:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mod_date__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;pub_date&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">F()</span></code> objects support bitwise operations by <code class="docutils literal notranslate"><span class="pre">.bitand()</span></code>, <code class="docutils literal notranslate"><span class="pre">.bitor()</span></code>,
<code class="docutils literal notranslate"><span class="pre">.bitxor()</span></code>, <code class="docutils literal notranslate"><span class="pre">.bitrightshift()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.bitleftshift()</span></code>. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;somefield&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-oracle admonition">
<p class="first admonition-title">Oracle</p>
<p class="last">Oracle 不支持按位 XOR 操作。</p>
</div>
</div>
<div class="section" id="s-expressions-can-reference-transforms">
<span id="s-using-transforms-in-expressions"></span><span id="expressions-can-reference-transforms"></span><span id="using-transforms-in-expressions"></span><h3>Expressions can reference transforms<a class="headerlink" href="#expressions-can-reference-transforms" title="永久链接至标题">¶</a></h3>
<p>Django supports using transforms in expressions.</p>
<p>For example, to find all <code class="docutils literal notranslate"><span class="pre">Entry</span></code> objects published in the same year as they
were last modified:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;mod_date__year&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>To find the earliest year an entry was published, we can issue the query:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Min</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">first_published_year</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>This example finds the value of the highest rated entry and the total number
of comments on all entries for each year:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">OuterRef</span><span class="p">,</span> <span class="n">Subquery</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">top_rating</span><span class="o">=</span><span class="n">Subquery</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">pub_date__year</span><span class="o">=</span><span class="n">OuterRef</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">)</span>
<span class="gp">... </span>        <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;-rating&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s2">&quot;rating&quot;</span><span class="p">)[:</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="p">),</span>
<span class="gp">... </span>    <span class="n">total_comments</span><span class="o">=</span><span class="n">Sum</span><span class="p">(</span><span class="s2">&quot;number_of_comments&quot;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-the-pk-lookup-shortcut">
<span id="the-pk-lookup-shortcut"></span><h3>主键 (<code class="docutils literal notranslate"><span class="pre">pk</span></code>) 查询快捷方式<a class="headerlink" href="#the-pk-lookup-shortcut" title="永久链接至标题">¶</a></h3>
<p>出于方便的目的，Django 提供了一种 <code class="docutils literal notranslate"><span class="pre">pk</span></code> 查询快捷方式， <code class="docutils literal notranslate"><span class="pre">pk</span></code> 表示主键 &quot;primary key&quot;。</p>
<p>In the example <code class="docutils literal notranslate"><span class="pre">Blog</span></code> model, the primary key is the <code class="docutils literal notranslate"><span class="pre">id</span></code> field, so these
three statements are equivalent:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># pk implies id__exact</span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">pk</span></code> isn't limited to <code class="docutils literal notranslate"><span class="pre">__exact</span></code> queries -- any query term
can be combined with <code class="docutils literal notranslate"><span class="pre">pk</span></code> to perform a query on the primary key of a model:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Get blogs entries with id 1, 4 and 7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk__in</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="go"># Get all blog entries with id &gt; 14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk__gt</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pk</span></code> lookups also work across joins. For example, these three statements are
equivalent:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id__exact</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__pk</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># __pk implies __id__exact</span>
</pre></div>
</div>
</div>
<div class="section" id="s-escaping-percent-signs-and-underscores-in-like-statements">
<span id="escaping-percent-signs-and-underscores-in-like-statements"></span><h3>在 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中转义百分号和下划线<a class="headerlink" href="#escaping-percent-signs-and-underscores-in-like-statements" title="永久链接至标题">¶</a></h3>
<p>等效于 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> SQL 语句的字段查询子句 (<code class="docutils literal notranslate"><span class="pre">iexact</span></code>， <code class="docutils literal notranslate"><span class="pre">contains</span></code>， <code class="docutils literal notranslate"><span class="pre">icontains</span></code>， <code class="docutils literal notranslate"><span class="pre">startswith</span></code>， <code class="docutils literal notranslate"><span class="pre">istartswith</span></code>， <code class="docutils literal notranslate"><span class="pre">endswith</span></code> 和 <code class="docutils literal notranslate"><span class="pre">iendswith</span></code>) 会将 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中有特殊用途的两个符号，即百分号和下划线自动转义。（在 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中，百分号匹配多个任意字符，而下划线匹配一个任意字符。）</p>
<p>This means things should work intuitively, so the abstraction doesn't leak.
For example, to retrieve all the entries that contain a percent sign, use the
percent sign as any other character:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Django 为你小心处理了引号；生成的 SQL 语句看起来像这样：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%\%%&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>同样的处理也包括下划线。百分号和下划线都为你自动处理，你无需担心。</p>
</div>
<div class="section" id="s-caching-and-querysets">
<span id="s-id8"></span><span id="caching-and-querysets"></span><span id="id8"></span><h3>缓存和 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#caching-and-querysets" title="永久链接至标题">¶</a></h3>
<p>每个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 都带有缓存，尽量减少数据库访问。理解它是如何工作的能让你编写更高效的代码。</p>
<p>新创建的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 缓存是空的。一旦要计算 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的值，就会执行数据查询，随后，Django 就会将查询结果保存在 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的缓存中，并返回这些显式请求的缓存（例如，下一个元素，若 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 正在被迭代）。后续针对 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的计算会复用缓存结果。</p>
<p>Keep this caching behavior in mind, because it may bite you if you don't use
your <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>s correctly. For example, the
following will create two <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>s, evaluate
them, and throw them away:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
</pre></div>
</div>
<p>这意味着同样的数据库查询会被执行两次，实际加倍了数据库负载。同时，有可能这两个列表不包含同样的记录，因为在两次请求间，可能有 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 被添加或删除了。</p>
<p>To avoid this problem, save the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> and
reuse it:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span>  <span class="c1"># Evaluate the query set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span>  <span class="c1"># Reuse the cache from the evaluation.</span>
</pre></div>
</div>
<div class="section" id="s-when-querysets-are-not-cached">
<span id="when-querysets-are-not-cached"></span><h4>当 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 未被缓存时<a class="headerlink" href="#when-querysets-are-not-cached" title="永久链接至标题">¶</a></h4>
<p>查询结果集并不总是缓存结果。当仅计算查询结果集的 <em>部分</em> 时，会校验缓存，若没有填充缓存，则后续查询返回的项目不会被缓存。特别地说，这意味着使用数组切片或索引的 <a class="reference internal" href="#limiting-querysets"><span class="std std-ref">限制查询结果集</span></a> 不会填充缓存。</p>
<p>For example, repeatedly getting a certain index in a queryset object will query
the database each time:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Queries the database again</span>
</pre></div>
</div>
<p>However, if the entire queryset has already been evaluated, the cache will be
checked instead:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>  <span class="c1"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Uses cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Uses cache</span>
</pre></div>
</div>
<p>Here are some examples of other actions that will result in the entire queryset
being evaluated and therefore populate the cache:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">只是打印查询结果集不会填充缓存。因为调用 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> 仅返回了完整结果集的一个切片。</p>
</div>
</div>
</div>
</div>
<div class="section" id="s-asynchronous-queries">
<span id="s-async-queries"></span><span id="asynchronous-queries"></span><span id="async-queries"></span><h2>Asynchronous queries<a class="headerlink" href="#asynchronous-queries" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<span class="title">New in Django 4.1.</span> </div>
<p>If you are writing asynchronous views or code, you cannot use the ORM for
queries in quite the way we have described above, as you cannot call <em>blocking</em>
synchronous code from asynchronous code - it will block up the event loop
(or, more likely, Django will notice and raise a <code class="docutils literal notranslate"><span class="pre">SynchronousOnlyOperation</span></code>
to stop that from happening).</p>
<p>Fortunately, you can do many queries using Django's asynchronous query APIs.
Every method that might block - such as <code class="docutils literal notranslate"><span class="pre">get()</span></code> or <code class="docutils literal notranslate"><span class="pre">delete()</span></code> - has an
asynchronous variant (<code class="docutils literal notranslate"><span class="pre">aget()</span></code> or <code class="docutils literal notranslate"><span class="pre">adelete()</span></code>), and when you iterate over
results, you can use asynchronous iteration (<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>) instead.</p>
<div class="section" id="s-query-iteration">
<span id="query-iteration"></span><h3>Query iteration<a class="headerlink" href="#query-iteration" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 4.1.</span> </div>
<p>The default way of iterating over a query - with <code class="docutils literal notranslate"><span class="pre">for</span></code> - will result in a
blocking database query behind the scenes as Django loads the results at
iteration time. To fix this, you can swap to <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">Authors</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Be aware that you also can't do other things that might iterate over the
queryset, such as wrapping <code class="docutils literal notranslate"><span class="pre">list()</span></code> around it to force its evaluation (you
can use <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> in a comprehension, if you want it).</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> methods like <code class="docutils literal notranslate"><span class="pre">filter()</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude()</span></code> do not
actually run the query - they set up the queryset to run when it's iterated
over - you can use those freely in asynchronous code. For a guide to which
methods can keep being used like this, and which have asynchronous versions,
read the next section.</p>
</div>
<div class="section" id="s-queryset-and-manager-methods">
<span id="queryset-and-manager-methods"></span><h3><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> and manager methods<a class="headerlink" href="#queryset-and-manager-methods" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 4.1.</span> </div>
<p>Some methods on managers and querysets - like <code class="docutils literal notranslate"><span class="pre">get()</span></code> and <code class="docutils literal notranslate"><span class="pre">first()</span></code> - force
execution of the queryset and are blocking. Some, like <code class="docutils literal notranslate"><span class="pre">filter()</span></code> and
<code class="docutils literal notranslate"><span class="pre">exclude()</span></code>, don't force execution and so are safe to run from asynchronous
code. But how are you supposed to tell the difference?</p>
<p>While you could poke around and see if there is an <code class="docutils literal notranslate"><span class="pre">a</span></code>-prefixed version of
the method (for example, we have <code class="docutils literal notranslate"><span class="pre">aget()</span></code> but not <code class="docutils literal notranslate"><span class="pre">afilter()</span></code>), there is a
more logical way - look up what kind of method it is in the
<a class="reference internal" href="../../ref/models/querysets.html"><span class="doc">QuerySet reference</span></a>.</p>
<p>In there, you'll find the methods on QuerySets grouped into two sections:</p>
<ul class="simple">
<li><em>Methods that return new querysets</em>: These are the non-blocking ones,
and don't have asynchronous versions. You're free to use these in any
situation, though read the notes on <code class="docutils literal notranslate"><span class="pre">defer()</span></code> and <code class="docutils literal notranslate"><span class="pre">only()</span></code> before you use
them.</li>
<li><em>Methods that do not return querysets</em>: These are the blocking ones, and
have asynchronous versions - the asynchronous name for each is noted in its
documentation, though our standard pattern is to add an <code class="docutils literal notranslate"><span class="pre">a</span></code> prefix.</li>
</ul>
<p>Using this distinction, you can work out when you need to use asynchronous
versions, and when you don't. For example, here's a valid asynchronous query:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">my_input</span><span class="p">)</span><span class="o">.</span><span class="n">afirst</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">filter()</span></code> returns a queryset, and so it's fine to keep chaining it inside an
asynchronous environment, whereas <code class="docutils literal notranslate"><span class="pre">first()</span></code> evaluates and returns a model
instance - thus, we change to <code class="docutils literal notranslate"><span class="pre">afirst()</span></code>, and use <code class="docutils literal notranslate"><span class="pre">await</span></code> at the front of
the whole expression in order to call it in an asynchronous-friendly way.</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">If you forget to put the <code class="docutils literal notranslate"><span class="pre">await</span></code> part in, you may see errors like
<em>&quot;coroutine object has no attribute x&quot;</em> or <em>&quot;&lt;coroutine …&gt;&quot;</em> strings in
place of your model instances. If you ever see these, you are missing an
<code class="docutils literal notranslate"><span class="pre">await</span></code> somewhere to turn that coroutine into a real value.</p>
</div>
</div>
<div class="section" id="s-transactions">
<span id="transactions"></span><h3>事务<a class="headerlink" href="#transactions" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 4.1.</span> </div>
<p>Transactions are <strong>not</strong> currently supported with asynchronous queries and
updates. You will find that trying to use one raises
<code class="docutils literal notranslate"><span class="pre">SynchronousOnlyOperation</span></code>.</p>
<p>If you wish to use a transaction, we suggest you write your ORM code inside a
separate, synchronous function and then call that using <code class="docutils literal notranslate"><span class="pre">sync_to_async</span></code> - see
<a class="reference internal" href="../async.html"><span class="doc">异步支持</span></a> for more.</p>
</div>
</div>
<div class="section" id="s-querying-jsonfield">
<span id="s-id9"></span><span id="querying-jsonfield"></span><span id="id9"></span><h2>查询 <code class="docutils literal notranslate"><span class="pre">JSONField</span></code><a class="headerlink" href="#querying-jsonfield" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a> 里的查找实现是不一样的，主要因为存在键转换。为了演示，我们将使用下面这个例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">JSONField</span><span class="p">(</span><span class="n">null</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<div class="section" id="s-storing-and-querying-for-none">
<span id="storing-and-querying-for-none"></span><h3>保存和查询 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值<a class="headerlink" href="#storing-and-querying-for-none" title="永久链接至标题">¶</a></h3>
<p>As with other fields, storing <code class="docutils literal notranslate"><span class="pre">None</span></code> as the field's value will store it as
SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. While not recommended, it is possible to store JSON scalar
<code class="docutils literal notranslate"><span class="pre">null</span></code> instead of SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code> by using <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.Value" title="django.db.models.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value(None,</span> <span class="pre">JSONField())</span></code></a>.</p>
<p>无论存储哪种值，当从数据库检索时，JSON 标量 <code class="docutils literal notranslate"><span class="pre">null</span></code> 的 Python 表示法与 SQL 的 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 相同，即 <code class="docutils literal notranslate"><span class="pre">None</span></code>。因此，可能很难区分它们。</p>
<p>这只适用于 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值作为字段的顶级值。如果 <code class="docutils literal notranslate"><span class="pre">None</span></code> 被保存在列表或字典中，它将始终被解释为 JSON 的 <code class="docutils literal notranslate"><span class="pre">null</span></code> 值。</p>
<p>When querying, <code class="docutils literal notranslate"><span class="pre">None</span></code> value will always be interpreted as JSON <code class="docutils literal notranslate"><span class="pre">null</span></code>. To
query for SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, use <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Max&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># SQL NULL.</span>
<span class="go">&lt;Dog: Max&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Archie&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">()))</span>  <span class="c1"># JSON null.</span>
<span class="go">&lt;Dog: Archie&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">()))</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Max&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__isnull</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
</pre></div>
</div>
<p>除非你确定要使用 SQL 的 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值，否则请考虑设置 <code class="docutils literal notranslate"><span class="pre">null=False</span></code> 并为空值提供合适的默认值，例如 <code class="docutils literal notranslate"><span class="pre">default=dict</span></code> 。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">保存 JSON 的 <code class="docutils literal notranslate"><span class="pre">null</span></code> 值不违反 Django 的 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null=False</span></code></a> 。</p>
</div>
<div class="versionchanged">
<span class="title">Changed in Django 4.2:</span> <p>Support for expressing JSON <code class="docutils literal notranslate"><span class="pre">null</span></code> using <code class="docutils literal notranslate"><span class="pre">Value(None,</span> <span class="pre">JSONField())</span></code> was
added.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">4.2 版后已移除: </span>Passing <code class="docutils literal notranslate"><span class="pre">Value(&quot;null&quot;)</span></code> to express JSON <code class="docutils literal notranslate"><span class="pre">null</span></code> is deprecated.</p>
</div>
</div>
<div class="section" id="s-key-index-and-path-transforms">
<span id="s-std-fieldlookup-jsonfield.key"></span><span id="s-std:fieldlookup-jsonfield.key"></span><span id="key-index-and-path-transforms"></span><span id="std-fieldlookup-jsonfield.key"></span><span id="std:fieldlookup-jsonfield.key"></span><h3>键、索引和路径转换<a class="headerlink" href="#key-index-and-path-transforms" title="永久链接至标题">¶</a></h3>
<p>To query based on a given dictionary key, use that key as the lookup name:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s2">&quot;other_pets&quot;</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">... </span>                <span class="p">{</span>
<span class="gp">... </span>                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Fishy&quot;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="p">}</span>
<span class="gp">... </span>            <span class="p">],</span>
<span class="gp">... </span>        <span class="p">},</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__breed</span><span class="o">=</span><span class="s2">&quot;collie&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
<p>Multiple keys can be chained together to form a path lookup:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__name</span><span class="o">=</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;</span>
</pre></div>
</div>
<p>If the key is an integer, it will be interpreted as an index transform in an
array:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__other_pets__0__name</span><span class="o">=</span><span class="s2">&quot;Fishy&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;</span>
</pre></div>
</div>
<p>如果要查询的键与另一个查询的键名冲突，请改用 <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> 来查询。</p>
<p>To query for missing keys, use the <code class="docutils literal notranslate"><span class="pre">isnull</span></code> lookup:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shep&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Shep&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">上面给出的例子隐式地使用了 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a> 查找。Key，索引和路径转换也可以用：<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">icontains</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">endswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iendswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-regex"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">regex</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iregex"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iregex</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">startswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">istartswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lt"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">lt</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lte"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">lte</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gt"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">gt</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gte"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">gte</span></code></a> 以及 <a class="reference internal" href="#containment-and-key-lookups"><span class="std std-ref">包含与键查找</span></a> 。</p>
</div>
<div class="section" id="s-kt-expressions">
<span id="kt-expressions"></span><h4><code class="docutils literal notranslate"><span class="pre">KT()</span></code> expressions<a class="headerlink" href="#kt-expressions" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<span class="title">New in Django 4.2.</span> </div>
<span class="target" id="module-django.db.models.fields.json"></span><dl class="py class">
<dt class="sig sig-object py" id="django.db.models.fields.json.KT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">KT</span></code>(<em><span class="n"><span class="pre">lookup</span></span></em>)<a class="headerlink" href="#django.db.models.fields.json.KT" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the text value of a key, index, or path transform of
<a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a>. You can use the double underscore
notation in <code class="docutils literal notranslate"><span class="pre">lookup</span></code> to chain dictionary key and index transforms.</p>
<p>例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.fields.json</span> <span class="kn">import</span> <span class="n">KT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shep&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;lhasa apso&quot;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Dog: Shep&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dogs</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">first_breed</span><span class="o">=</span><span class="n">KT</span><span class="p">(</span><span class="s2">&quot;data__breed__1&quot;</span><span class="p">),</span> <span class="n">owner_name</span><span class="o">=</span><span class="n">KT</span><span class="p">(</span><span class="s2">&quot;data__owner__name&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">first_breed__startswith</span><span class="o">=</span><span class="s2">&quot;lhasa&quot;</span><span class="p">,</span> <span class="n">owner_name</span><span class="o">=</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">由于键-路径查询的工作方式，<code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code> 不能保证产生详尽的集合。如果你想包含没有路径的对象，请添加 <code class="docutils literal notranslate"><span class="pre">isnull</span></code> 查找。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">由于任何字符串都可以成为 JSON 对象中的一个键，除了下面列出的那些之外，任何查询都将被解释为一个键查询。不会出现错误。要格外小心打字错误，并经常检查你的查询是否按你的意图进行。</p>
</div>
<div class="admonition-mariadb-and-oracle-users admonition">
<p class="first admonition-title">MariaDB 和 Oracle 用户</p>
<p class="last">在键、索引或路径转换上使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code> 将使用值的字符串表示法对对象进行排序。这是因为 MariaDB 和 Oracle 数据库没有提供将 JSON 值转换为其等价的 SQL 值的函数。</p>
</div>
<div class="admonition-oracle-users admonition">
<p class="first admonition-title">Oracle 用户</p>
<p class="last">在 Oracle 数据库中，在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code> 查询中使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为查询值，将返回没有 <code class="docutils literal notranslate"><span class="pre">null</span></code> 作为指定路径的对象，包括没有路径的对象。在其他数据库后端，该查询将返回具有该路径且其值不是 <code class="docutils literal notranslate"><span class="pre">null</span></code> 的对象。</p>
</div>
<div class="admonition-postgresql-users admonition">
<p class="first admonition-title">PostgreSQL 用户</p>
<p class="last">在 PostgreSQL 上，如果只使用一个键或索引，那么会使用 SQL 运算符 <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> 。如果使用多个操作符，则会使用 <code class="docutils literal notranslate"><span class="pre">#&gt;</span></code> 运算符。</p>
</div>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">SQLite 用户</p>
<p class="last">On SQLite, <code class="docutils literal notranslate"><span class="pre">&quot;true&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;false&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&quot;null&quot;</span></code> string values will
always be interpreted as <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, and JSON <code class="docutils literal notranslate"><span class="pre">null</span></code>
respectively.</p>
</div>
</div>
</div>
<div class="section" id="s-containment-and-key-lookups">
<span id="s-id10"></span><span id="containment-and-key-lookups"></span><span id="id10"></span><h3>包含与键查找<a class="headerlink" href="#containment-and-key-lookups" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-contains">
<span id="s-std-fieldlookup-jsonfield.contains"></span><span id="s-std:fieldlookup-jsonfield.contains"></span><span id="contains"></span><span id="std-fieldlookup-jsonfield.contains"></span><span id="std:fieldlookup-jsonfield.contains"></span><h4><code class="docutils literal notranslate"><span class="pre">contains</span></code><a class="headerlink" href="#contains" title="永久链接至标题">¶</a></h4>
<p>The <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> lookup is overridden on <code class="docutils literal notranslate"><span class="pre">JSONField</span></code>. The returned
objects are those where the given <code class="docutils literal notranslate"><span class="pre">dict</span></code> of key-value pairs are all
contained in the top-level of the field. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{})</span>
<span class="go">&lt;Dog: Fred&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contains</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contains</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition-oracle-and-sqlite admonition">
<p class="first admonition-title">Oracle 和 SQLite</p>
<p class="last">Oracle 和 SQLite 不支持 <code class="docutils literal notranslate"><span class="pre">contains</span></code> 。</p>
</div>
</div>
<div class="section" id="s-contained-by">
<span id="s-std-fieldlookup-jsonfield.contained_by"></span><span id="s-std:fieldlookup-jsonfield.contained_by"></span><span id="contained-by"></span><span id="std-fieldlookup-jsonfield.contained_by"></span><span id="std:fieldlookup-jsonfield.contained_by"></span><h4><code class="docutils literal notranslate"><span class="pre">contained_by</span></code><a class="headerlink" href="#contained-by" title="永久链接至标题">¶</a></h4>
<p>This is the inverse of the <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> lookup - the
objects returned will be those where the key-value pairs on the object are a
subset of those in the value passed. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{})</span>
<span class="go">&lt;Dog: Fred&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contained_by</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;, &lt;Dog: Fred&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contained_by</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Fred&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition-oracle-and-sqlite admonition">
<p class="first admonition-title">Oracle 和 SQLite</p>
<p class="last">Oracle 和 SQLite 不支持 <code class="docutils literal notranslate"><span class="pre">contained_by</span></code> 。</p>
</div>
</div>
<div class="section" id="s-has-key">
<span id="s-std-fieldlookup-jsonfield.has_key"></span><span id="s-std:fieldlookup-jsonfield.has_key"></span><span id="has-key"></span><span id="std-fieldlookup-jsonfield.has_key"></span><span id="std:fieldlookup-jsonfield.has_key"></span><h4><code class="docutils literal notranslate"><span class="pre">has_key</span></code><a class="headerlink" href="#has-key" title="永久链接至标题">¶</a></h4>
<p>Returns objects where the given key is in the top-level of the data. For
example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_key</span><span class="o">=</span><span class="s2">&quot;owner&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-has-keys">
<span id="s-std-fieldlookup-jsonfield.has_any_keys"></span><span id="s-std:fieldlookup-jsonfield.has_any_keys"></span><span id="has-keys"></span><span id="std-fieldlookup-jsonfield.has_any_keys"></span><span id="std:fieldlookup-jsonfield.has_any_keys"></span><h4><code class="docutils literal notranslate"><span class="pre">has_keys</span></code><a class="headerlink" href="#has-keys" title="永久链接至标题">¶</a></h4>
<p>Returns objects where all of the given keys are in the top-level of the data.
For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;breed&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">])</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-has-any-keys">
<span id="s-std-fieldlookup-jsonfield.has_keys"></span><span id="s-std:fieldlookup-jsonfield.has_keys"></span><span id="has-any-keys"></span><span id="std-fieldlookup-jsonfield.has_keys"></span><span id="std:fieldlookup-jsonfield.has_keys"></span><h4><code class="docutils literal notranslate"><span class="pre">has_any_keys</span></code><a class="headerlink" href="#has-any-keys" title="永久链接至标题">¶</a></h4>
<p>Returns objects where any of the given keys are in the top-level of the data.
For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_any_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;owner&quot;</span><span class="p">,</span> <span class="s2">&quot;breed&quot;</span><span class="p">])</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-complex-lookups-with-q-objects">
<span id="s-complex-lookups-with-q"></span><span id="complex-lookups-with-q-objects"></span><span id="complex-lookups-with-q"></span><h2>通过 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象完成复杂查询<a class="headerlink" href="#complex-lookups-with-q-objects" title="永久链接至标题">¶</a></h2>
<p>在类似 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 中，查询使用的关键字参数是通过 &quot;AND&quot; 连接起来的。如果你要执行更复杂的查询（例如，由 <code class="docutils literal notranslate"><span class="pre">OR</span></code> 语句连接的查询），你可以使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">对象</span></code></a>。</p>
<p>一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">对象</span></code></a> (<code class="docutils literal notranslate"><span class="pre">django.db.models.Q</span></code>) 用于压缩关键字参数集合。这些关键字参数由前文 &quot;Field lookups&quot; 指定。</p>
<p>例如，该 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象压缩了一个 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 查询:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>

<span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Q</span></code> objects can be combined using the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, and <code class="docutils literal notranslate"><span class="pre">^</span></code> operators. When
an operator is used on two <code class="docutils literal notranslate"><span class="pre">Q</span></code> objects, it yields a new <code class="docutils literal notranslate"><span class="pre">Q</span></code> object.</p>
<p>例如，该语句生成一个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象，表示两个 <code class="docutils literal notranslate"><span class="pre">&quot;question_startswith&quot;</span></code> 查询语句之间的 &quot;OR&quot; 关系:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to the following SQL <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">WHERE</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Who%&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;What%&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>You can compose statements of arbitrary complexity by combining <code class="docutils literal notranslate"><span class="pre">Q</span></code> objects
with the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, and <code class="docutils literal notranslate"><span class="pre">^</span></code> operators and use parenthetical grouping.
Also, <code class="docutils literal notranslate"><span class="pre">Q</span></code> objects can be negated using the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator, allowing for
combined lookups that combine both a normal query and a negated (<code class="docutils literal notranslate"><span class="pre">NOT</span></code>)
query:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">Q</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>每个接受关键字参数的查询函数 (例如 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>) 也同时接受一个或多个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象作为位置（未命名的）参数。若你为查询函数提供了多个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象参数，这些参数会通过 &quot;AND&quot; 连接。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>...粗略地转为 SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">polls</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Who%&#39;</span><span class="w"></span>
<span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="p">(</span><span class="n">pub_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2005-05-02&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">pub_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2005-05-06&#39;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>查询函数能混合使用 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象和关键字参数。所有提供给查询函数的参数（即关键字参数或 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象）均通过 &quot;AND&quot; 连接。然而，若提供了 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象，那么它必须位于所有关键字参数之前。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>……会是一个有效的查询，等效于前文的例子；但是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># INVALID QUERY</span>
<span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>……却是无效的。</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last">Django 单元测试中的 <a class="reference external" href="https://github.com/django/django/blob/main/tests/or_lookups/tests.py">OR 查询实例</a> 展示了 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 的用法。</p>
</div>
<div class="versionchanged">
<span class="title">Changed in Django 4.1:</span> <p>Support for the <code class="docutils literal notranslate"><span class="pre">^</span></code> (<code class="docutils literal notranslate"><span class="pre">XOR</span></code>) operator was added.</p>
</div>
</div>
<div class="section" id="s-comparing-objects">
<span id="comparing-objects"></span><h2>比较对象<a class="headerlink" href="#comparing-objects" title="永久链接至标题">¶</a></h2>
<p>要比较两个模型实例，使用标准的 Python 比较操作符，两个等号： <code class="docutils literal notranslate"><span class="pre">==</span></code>。实际上，这比较了两个模型实例的主键值。</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">Entry</span></code> example above, the following two statements are equivalent:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span> <span class="o">==</span> <span class="n">other_entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other_entry</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>If a model's primary key isn't called <code class="docutils literal notranslate"><span class="pre">id</span></code>, no problem. Comparisons will
always use the primary key, whatever it's called. For example, if a model's
primary key field is called <code class="docutils literal notranslate"><span class="pre">name</span></code>, these two statements are equivalent:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span> <span class="o">==</span> <span class="n">other_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
<div class="section" id="s-deleting-objects">
<span id="s-topics-db-queries-delete"></span><span id="deleting-objects"></span><span id="topics-db-queries-delete"></span><h2>删除对象<a class="headerlink" href="#deleting-objects" title="永久链接至标题">¶</a></h2>
<p>The delete method, conveniently, is named
<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>. This method immediately deletes the
object and returns the number of objects deleted and a dictionary with
the number of deletions per object type. Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(1, {&#39;blog.Entry&#39;: 1})</span>
</pre></div>
</div>
<p>你也能批量删除对象。所有 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 都有个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> 方法，它会删除 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 中的所有成员。</p>
<p>For example, this deletes all <code class="docutils literal notranslate"><span class="pre">Entry</span></code> objects with a <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> year of
2005:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(5, {&#39;webapp.Entry&#39;: 5})</span>
</pre></div>
</div>
<p>请记住，只要有机会的话，这会通过纯 SQL 语句执行，所以就无需在过程中调用每个对象的删除方法了。若你为模型类提供了自定义的 <code class="docutils literal notranslate"><span class="pre">delete()</span></code> 方法，且希望确保调用了该方法，你需要 “手动” 删除该模型的实例（例如，如，遍历 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，在每个对象上分别调用 <code class="docutils literal notranslate"><span class="pre">delete()</span></code> 方法），而不是使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的批量删除方法 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>。</p>
<p>当 Django 删除某个对象时，默认会模仿 SQL 约束 <code class="docutils literal notranslate"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></code> 的行为——换而言之，某个对象被删除时，关联对象也会被删除。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># This will delete the Blog and all of its Entry objects.</span>
<span class="n">b</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>这种约束行为由 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 的 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">on_delete</span></code></a> 参数指定。</p>
<p>注意 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> 是唯一未在 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 上暴漏的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法。这是一种安全机制，避免你不小心调用了 <code class="docutils literal notranslate"><span class="pre">Entry.objects.delete()</span></code>，删除了 <em>所有的</em> 条目。若你 <em>确实</em> 想要删除所有对象，你必须显示请求完整结果集合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-copying-model-instances">
<span id="s-topics-db-queries-copy"></span><span id="copying-model-instances"></span><span id="topics-db-queries-copy"></span><h2>复制模型实例<a class="headerlink" href="#copying-model-instances" title="永久链接至标题">¶</a></h2>
<p>Although there is no built-in method for copying model instances, it is
possible to easily create new instance with all fields' values copied. In the
simplest case, you can set <code class="docutils literal notranslate"><span class="pre">pk</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code> and
<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model._state" title="django.db.models.Model._state"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_state.adding</span></code></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code>. Using our
blog example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;My blog&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Blogging is easy&quot;</span><span class="p">)</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># blog.pk == 1</span>

<span class="n">blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">blog</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># blog.pk == 2</span>
</pre></div>
</div>
<p>若你使用了集成，事情会更复杂。考虑下 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 的一个子类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThemeBlog</span><span class="p">(</span><span class="n">Blog</span><span class="p">):</span>
    <span class="n">theme</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>


<span class="n">django_blog</span> <span class="o">=</span> <span class="n">ThemeBlog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Django&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Django is easy&quot;</span><span class="p">,</span> <span class="n">theme</span><span class="o">=</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># django_blog.pk == 3</span>
</pre></div>
</div>
<p>Due to how inheritance works, you have to set both <code class="docutils literal notranslate"><span class="pre">pk</span></code> and <code class="docutils literal notranslate"><span class="pre">id</span></code> to
<code class="docutils literal notranslate"><span class="pre">None</span></code>, and <code class="docutils literal notranslate"><span class="pre">_state.adding</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">django_blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># django_blog.pk == 4</span>
</pre></div>
</div>
<p>该方法不会拷贝不是模型数据表中的关联关系。例如， <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 有一个对 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 的 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 关联关系。在复制条目后，你必须为新条目设置多对多关联关系。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># some previous entry</span>
<span class="n">old_authors</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">entry</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">old_authors</span><span class="p">)</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code> 关联，你必须拷贝关联对象，并将其指定给新对象的关联字段，避免违反一对一唯一性约束。例如，指定前文复制的 <code class="docutils literal notranslate"><span class="pre">entry</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">detail</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">detail</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">detail</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">detail</span><span class="o">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span>
<span class="n">detail</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-updating-multiple-objects-at-once">
<span id="s-topics-db-queries-update"></span><span id="updating-multiple-objects-at-once"></span><span id="topics-db-queries-update"></span><h2>一次修改多个对象<a class="headerlink" href="#updating-multiple-objects-at-once" title="永久链接至标题">¶</a></h2>
<p>有时候，你想统一设置 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 中的所有对象的某个字段。你可以通过 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 达到目的。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Update all the headlines with pub_date in 2007.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2007</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Everything is the same&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You can only set non-relation fields and <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>
fields using this method. To update a non-relation field, provide the new value
as a constant. To update <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> fields, set the
new value to be the new model instance you want to point to. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Change every Entry so that it belongs to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">update()</span></code> method is applied instantly and returns the number of rows
matched by the query (which may not be equal to the number of rows updated if
some rows already have the new value). The only restriction on the
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> being updated is that it can only
access one database table: the model's main table. You can filter based on
related fields, but you can only update columns in the model's main
table. Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Update all the headlines belonging to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Everything is the same&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>要认识到 <code class="docutils literal notranslate"><span class="pre">update()</span></code> 方法是直接转为 SQL 语句的。这是一种用于直接更新的批量操作。它并不会调用模型的 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法，或发射 <code class="docutils literal notranslate"><span class="pre">pre_save</span></code> 或 <code class="docutils literal notranslate"><span class="pre">post_save</span></code> 信号（调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 会触发信号），或使用 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> 字段选项。若想保存 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 中的每项，并确保调用了每个实例的 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法，你并不需要任何特殊的函数来处理此问题。迭代它们，并调用它们的 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_queryset</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>Calls to update can also use <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">expressions</span></code></a> to
update one field based on the value of another field in the model. This is
especially useful for incrementing counters based upon their current value. For
example, to increment the pingback count for every entry in the blog:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">number_of_pingbacks</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>However, unlike <code class="docutils literal notranslate"><span class="pre">F()</span></code> objects in filter and exclude clauses, you can't
introduce joins when you use <code class="docutils literal notranslate"><span class="pre">F()</span></code> objects in an update -- you can only
reference fields local to the model being updated. If you attempt to introduce
a join with an <code class="docutils literal notranslate"><span class="pre">F()</span></code> object, a <code class="docutils literal notranslate"><span class="pre">FieldError</span></code> will be raised:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># This will raise a FieldError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;blog__name&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="s-related-objects">
<span id="s-topics-db-queries-related"></span><span id="related-objects"></span><span id="topics-db-queries-related"></span><h2>关联对象<a class="headerlink" href="#related-objects" title="永久链接至标题">¶</a></h2>
<p>当你在模型中定义了关联关系（如 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>， <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a>， 或 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a>），该模型的实例将会自动获取一套 API，能快捷地访问关联对象。</p>
<p>拿本文开始的模型做例子，一个 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象 <code class="docutils literal notranslate"><span class="pre">e</span></code> 通过 <code class="docutils literal notranslate"><span class="pre">blog</span></code> 属性获取其关联的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象： <code class="docutils literal notranslate"><span class="pre">e.blog</span></code>。</p>
<p>（在幕后，这个函数是由  Python <a class="reference external" href="https://docs.python.org/3/howto/descriptor.html" title="(在 Python v3.11)"><span class="xref std std-doc">descriptors</span></a> 实现的。这玩意一般不会麻烦你，但是我们为你指出了注意点。）</p>
<p>Django 也提供了从关联关系 <em>另一边</em> 访问的 API —— 从被关联模型到定义关联关系的模型的连接。例如，一个 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象 <code class="docutils literal notranslate"><span class="pre">b</span></code> 能通过 <code class="docutils literal notranslate"><span class="pre">entry_set</span></code> 属性 <code class="docutils literal notranslate"><span class="pre">b.entry_set.all()</span></code> 访问包含所有关联 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象的列表。</p>
<p>本章节中的所有例子都是用了本页开头定义的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code>， <code class="docutils literal notranslate"><span class="pre">Author</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 模型。</p>
<div class="section" id="s-one-to-many-relationships">
<span id="one-to-many-relationships"></span><h3>一对多关联<a class="headerlink" href="#one-to-many-relationships" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-forward">
<span id="forward"></span><h4>正向访问<a class="headerlink" href="#forward" title="永久链接至标题">¶</a></h4>
<p>若模型有个 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>，该模型的实例能通过其属性访问关联（外部的）对象。</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c1"># Returns the related Blog object.</span>
</pre></div>
</div>
<p>You can get and set via a foreign-key attribute. As you may expect, changes to
the foreign key aren't saved to the database until you call
<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>. Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">some_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>If a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> field has <code class="docutils literal notranslate"><span class="pre">null=True</span></code> set (i.e.,
it allows <code class="docutils literal notranslate"><span class="pre">NULL</span></code> values), you can assign <code class="docutils literal notranslate"><span class="pre">None</span></code> to remove the relation.
Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># &quot;UPDATE blog_entry SET blog_id = NULL ...;&quot;</span>
</pre></div>
</div>
<p>Forward access to one-to-many relationships is cached the first time the
related object is accessed. Subsequent accesses to the foreign key on the same
object instance are cached. Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Hits the database to retrieve the associated Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> method recursively prepopulates the
cache of all one-to-many relationships ahead of time. Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
</div>
<div class="section" id="s-following-relationships-backward">
<span id="s-backwards-related-objects"></span><span id="following-relationships-backward"></span><span id="backwards-related-objects"></span><h4>“反向” 关联<a class="headerlink" href="#following-relationships-backward" title="永久链接至标题">¶</a></h4>
<p>若模型有 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>，外键关联的模型实例将能访问 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>，后者会返回第一个模型的所有实例。默认情况下，该 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 名为 <code class="docutils literal notranslate"><span class="pre">FOO_set</span></code>， <code class="docutils literal notranslate"><span class="pre">FOO</span></code> 即源模型名的小写形式。 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code>，后者能以 “检索对象” 章节介绍的方式进行筛选和操作。</p>
<p>Example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entry_set is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p>You can override the <code class="docutils literal notranslate"><span class="pre">FOO_set</span></code> name by setting the
<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> parameter in the
<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> definition. For example, if the <code class="docutils literal notranslate"><span class="pre">Entry</span></code>
model was altered to <code class="docutils literal notranslate"><span class="pre">blog</span> <span class="pre">=</span> <span class="pre">ForeignKey(Blog,</span> <span class="pre">on_delete=models.CASCADE,</span>
<span class="pre">related_name='entries')</span></code>, the above example code would look like this:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entries is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-using-a-custom-reverse-manager">
<span id="s-using-custom-reverse-manager"></span><span id="using-a-custom-reverse-manager"></span><span id="using-custom-reverse-manager"></span><h4>使用自定义反向管理器<a class="headerlink" href="#using-a-custom-reverse-manager" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager" title="django.db.models.fields.related.RelatedManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">RelatedManager</span></code></a> 反向关联的默认实现是该模型 <a class="reference internal" href="managers.html#manager-names"><span class="std std-ref">默认管理器</span></a> 一个实例。若你想为某个查询指定一个不同的管理器，可以使用如下语法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>  <span class="c1"># Default Manager</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="n">EntryManager</span><span class="p">()</span>  <span class="c1"># Custom Manager</span>


<span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>若 <code class="docutils literal notranslate"><span class="pre">EntryManager</span></code> 在其 <code class="docutils literal notranslate"><span class="pre">get_queryset()</span></code> 方法执行了默认过滤行为，改行为会应用到 <code class="docutils literal notranslate"><span class="pre">all()</span></code> 调用中。</p>
<p>指定一个自定义反向管理也允许你调用模型自定义方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_published</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition-interaction-with-prefetching admonition">
<p class="first admonition-title">Interaction with prefetching</p>
<p>When calling <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a> with
a reverse relation, the default manager will be used. If you want to
prefetch related objects using a custom reverse manager, use
<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Prefetch" title="django.db.models.Prefetch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prefetch()</span></code></a>. For example:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Prefetch</span>

<span class="n">prefetch_manager</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s2">&quot;entry_set&quot;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch_manager</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-additional-methods-to-handle-related-objects">
<span id="additional-methods-to-handle-related-objects"></span><h4>管理关联对象的额外方法<a class="headerlink" href="#additional-methods-to-handle-related-objects" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 还有方法能处理关联对象集合。除了上面的 “检索对象” 中定义的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法以外，以下是每项的简要介绍，而完整的细节能在 <a class="reference internal" href="../../ref/models/relations.html"><span class="doc">关联对象参考</span></a> 中找到。</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">add(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></code></dt><dd>将特定的模型对象加入关联对象集合。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">create(**kwargs)</span></code></dt><dd>创建一个新对象，保存，并将其放入关联对象集合中。返回新创建的对象。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></code></dt><dd>从关联对象集合删除指定模型对象。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clear()</span></code></dt><dd>从关联对象集合删除所有对象。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set(objs)</span></code></dt><dd>替换关联对象集合</dd>
</dl>
<p>要指定关联集合的成员，调用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 方法，并传入可迭代的对象实例集合。例如，若 <code class="docutils literal notranslate"><span class="pre">e1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">e2</span></code> 都是 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 实例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">clear()</span></code> method is available, any preexisting objects will be
removed from the <code class="docutils literal notranslate"><span class="pre">entry_set</span></code> before all objects in the iterable (in this
case, a list) are added to the set. If the <code class="docutils literal notranslate"><span class="pre">clear()</span></code> method is <em>not</em>
available, all objects in the iterable will be added without removing any
existing elements.</p>
<p>本节介绍的所有 “反向” 操作对数据库都是立刻生效的。每次的增加，创建和删除都是及时自动地保存至数据库。</p>
</div>
</div>
<div class="section" id="s-many-to-many-relationships">
<span id="s-m2m-reverse-relationships"></span><span id="many-to-many-relationships"></span><span id="m2m-reverse-relationships"></span><h3>多对多关联<a class="headerlink" href="#many-to-many-relationships" title="永久链接至标题">¶</a></h3>
<p>多对多关联的两端均自动获取访问另一端的 API。该 API 的工作方式类似上面的 “反向” 一对多关联。</p>
<p>不同点在为属性命名上：定义了 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 的模型使用字段名作为属性名，而 “反向” 模型使用源模型名的小写形式，加上 <code class="docutils literal notranslate"><span class="pre">'_set'</span></code> （就像反向一对多关联一样）。</p>
<p>一个更易理解的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Author objects for this Entry.</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s2">&quot;John&quot;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects for this Author.</span>
</pre></div>
</div>
<p>和 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 一样， <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 能指定 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.related_name" title="django.db.models.ManyToManyField.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a>。在上面的例子中，若 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 中的 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 已指定了 <code class="docutils literal notranslate"><span class="pre">related_name='entries'</span></code>，随后每个 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 实例会拥有一个 <code class="docutils literal notranslate"><span class="pre">entries</span></code> 属性，而不是 <code class="docutils literal notranslate"><span class="pre">entry_set</span></code>。</p>
<p>另一个与一对多关联不同的地方是，除了模型实例以外，多对多关联中的 <code class="docutils literal notranslate"><span class="pre">add()</span></code>， <code class="docutils literal notranslate"><span class="pre">set()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 方法能接收主键值。例如，若 <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">e2</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 的实例，以下两种 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 调用结果一致:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">e2</span><span class="o">.</span><span class="n">pk</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="s-one-to-one-relationships">
<span id="one-to-one-relationships"></span><h3>一对一关联<a class="headerlink" href="#one-to-one-relationships" title="永久链接至标题">¶</a></h3>
<p>一对一关联与多对一关联非常类似。若在模型中定义了 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a>，该模型的实例只需通过其属性就能访问关联对象。</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EntryDetail</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Entry</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">details</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>


<span class="n">ed</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ed</span><span class="o">.</span><span class="n">entry</span>  <span class="c1"># Returns the related Entry object.</span>
</pre></div>
</div>
<p>不同点在于 “反向” 查询。一对一关联所关联的对象也能访问 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 对象，但这个 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 仅代表一个对象，而不是对象的集合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span>  <span class="c1"># returns the related EntryDetail object</span>
</pre></div>
</div>
<p>若未为关联关系指定对象，Django 会抛出 <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> 异常。</p>
<p>实例能通过为正向关联指定关联对象一样的方式指定给反向关联:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="o">=</span> <span class="n">ed</span>
</pre></div>
</div>
</div>
<div class="section" id="s-how-are-the-backward-relationships-possible">
<span id="how-are-the-backward-relationships-possible"></span><h3>反向关联是如何实现的？<a class="headerlink" href="#how-are-the-backward-relationships-possible" title="永久链接至标题">¶</a></h3>
<p>其它对象关联映射实现要求你在两边都定义关联关系。而 Django 开发者坚信这违反了 DRY 原则（不要自我重复），故 Django 仅要求你在一端定义关联关系。</p>
<p>但这是如何实现的呢，给你一个模型类，模型类并不知道是否有其它模型类关联它，直到其它模型类被加载？</p>
<p>答案位于 <a class="reference internal" href="../../ref/applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-data docutils literal notranslate"><span class="pre">应用注册</span></code></a>。 Django 启动时，它会导入 <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 列出的每个应用，和每个应用中的 <code class="docutils literal notranslate"><span class="pre">model</span></code> 模块。无论何时创建了一个新模型类，Django 为每个关联模型添加反向关联。若被关联的模型未被导入，Django 会持续追踪这些关联，并在关联模型被导入时添加关联关系。</p>
<p>出于这个原因，包含你所使用的所有模型的应用必须列在 <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中。否则，反向关联可能不会正常工作。</p>
</div>
<div class="section" id="s-queries-over-related-objects">
<span id="queries-over-related-objects"></span><h3>查询关联对象<a class="headerlink" href="#queries-over-related-objects" title="永久链接至标题">¶</a></h3>
<p>涉及关联对象的查询与涉及普通字段的查询遵守同样的规则。未查询条件指定值时，你可以使用对象实例，或该实例的主键。</p>
<p>例如，若有个博客对象 <code class="docutils literal notranslate"><span class="pre">b</span></code>，其 <code class="docutils literal notranslate"><span class="pre">id=5</span></code>，以下三种查询是一样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Query using object instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>  <span class="c1"># Query using id from instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Query using id directly</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-falling-back-to-raw-sql">
<span id="falling-back-to-raw-sql"></span><h2>回归原生 SQL<a class="headerlink" href="#falling-back-to-raw-sql" title="永久链接至标题">¶</a></h2>
<p>若你发现需要编写的 SQL 查询语句太过复杂，以至于 Django 的数据库映射无法处理，你可以回归手动编写 SQL。Django 针对编写原生 SQL 有几个选项；参考 <a class="reference internal" href="sql.html"><span class="doc">执行原生 SQL 查询</span></a>。</p>
<p>最后，Django 数据库层只是一种访问数据库的接口，理解这点非常重要。你也可以通过其它工具，编程语言或数据库框架访问数据库；Django 并没有对数据库数据库做啥独有的操作。</p>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">执行查询</a><ul>
<li><a class="reference internal" href="#creating-objects">创建对象</a></li>
<li><a class="reference internal" href="#saving-changes-to-objects">将修改保存至对象</a><ul>
<li><a class="reference internal" href="#saving-foreignkey-and-manytomanyfield-fields">保存 <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 字段</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-objects">检索对象</a><ul>
<li><a class="reference internal" href="#retrieving-all-objects">检索全部对象</a></li>
<li><a class="reference internal" href="#retrieving-specific-objects-with-filters">通过过滤器检索指定对象</a><ul>
<li><a class="reference internal" href="#chaining-filters">链式过滤器</a></li>
<li><a class="reference internal" href="#filtered-querysets-are-unique">每个 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 都是唯一的</a></li>
<li><a class="reference internal" href="#querysets-are-lazy"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 是惰性的</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-a-single-object-with-get">用 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 检索单个对象</a></li>
<li><a class="reference internal" href="#other-queryset-methods">其它 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法</a></li>
<li><a class="reference internal" href="#limiting-querysets">限制 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 条目数</a></li>
<li><a class="reference internal" href="#field-lookups">字段查询</a></li>
<li><a class="reference internal" href="#lookups-that-span-relationships">跨关系查询</a><ul>
<li><a class="reference internal" href="#spanning-multi-valued-relationships">跨多值关联</a></li>
</ul>
</li>
<li><a class="reference internal" href="#filters-can-reference-fields-on-the-model">过滤器可以为模型指定字段</a></li>
<li><a class="reference internal" href="#expressions-can-reference-transforms">Expressions can reference transforms</a></li>
<li><a class="reference internal" href="#the-pk-lookup-shortcut">主键 (<code class="docutils literal notranslate"><span class="pre">pk</span></code>) 查询快捷方式</a></li>
<li><a class="reference internal" href="#escaping-percent-signs-and-underscores-in-like-statements">在 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中转义百分号和下划线</a></li>
<li><a class="reference internal" href="#caching-and-querysets">缓存和 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#when-querysets-are-not-cached">当 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 未被缓存时</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-queries">Asynchronous queries</a><ul>
<li><a class="reference internal" href="#query-iteration">Query iteration</a></li>
<li><a class="reference internal" href="#queryset-and-manager-methods"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> and manager methods</a></li>
<li><a class="reference internal" href="#transactions">事务</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-jsonfield">查询 <code class="docutils literal notranslate"><span class="pre">JSONField</span></code></a><ul>
<li><a class="reference internal" href="#storing-and-querying-for-none">保存和查询 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值</a></li>
<li><a class="reference internal" href="#key-index-and-path-transforms">键、索引和路径转换</a><ul>
<li><a class="reference internal" href="#kt-expressions"><code class="docutils literal notranslate"><span class="pre">KT()</span></code> expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#containment-and-key-lookups">包含与键查找</a><ul>
<li><a class="reference internal" href="#contains"><code class="docutils literal notranslate"><span class="pre">contains</span></code></a></li>
<li><a class="reference internal" href="#contained-by"><code class="docutils literal notranslate"><span class="pre">contained_by</span></code></a></li>
<li><a class="reference internal" href="#has-key"><code class="docutils literal notranslate"><span class="pre">has_key</span></code></a></li>
<li><a class="reference internal" href="#has-keys"><code class="docutils literal notranslate"><span class="pre">has_keys</span></code></a></li>
<li><a class="reference internal" href="#has-any-keys"><code class="docutils literal notranslate"><span class="pre">has_any_keys</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#complex-lookups-with-q-objects">通过 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象完成复杂查询</a></li>
<li><a class="reference internal" href="#comparing-objects">比较对象</a></li>
<li><a class="reference internal" href="#deleting-objects">删除对象</a></li>
<li><a class="reference internal" href="#copying-model-instances">复制模型实例</a></li>
<li><a class="reference internal" href="#updating-multiple-objects-at-once">一次修改多个对象</a></li>
<li><a class="reference internal" href="#related-objects">关联对象</a><ul>
<li><a class="reference internal" href="#one-to-many-relationships">一对多关联</a><ul>
<li><a class="reference internal" href="#forward">正向访问</a></li>
<li><a class="reference internal" href="#following-relationships-backward">“反向” 关联</a></li>
<li><a class="reference internal" href="#using-a-custom-reverse-manager">使用自定义反向管理器</a></li>
<li><a class="reference internal" href="#additional-methods-to-handle-related-objects">管理关联对象的额外方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#many-to-many-relationships">多对多关联</a></li>
<li><a class="reference internal" href="#one-to-one-relationships">一对一关联</a></li>
<li><a class="reference internal" href="#how-are-the-backward-relationships-possible">反向关联是如何实现的？</a></li>
<li><a class="reference internal" href="#queries-over-related-objects">查询关联对象</a></li>
</ul>
</li>
<li><a class="reference internal" href="#falling-back-to-raw-sql">回归原生 SQL</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="models.html"
                          title="上一章">模型</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="aggregation.html"
                          title="下一章">聚合</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../sources/topics/db/queries.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">9月 04, 2023</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="models.html" title="模型">previous</a>
     |
    <a href="../index.html" title="使用 Django" accesskey="U">up</a>
   |
    <a href="aggregation.html" title="聚合">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>