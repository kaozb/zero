
<!DOCTYPE html>

<html lang="zh_Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>执行查询 &#8212; Django 5.0.3.dev20240221071519 文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/default.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="聚合" href="aggregation.html" />
    <link rel="prev" title="模型" href="models.html" />



 
<script src="../../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django 5.0.3.dev20240221071519 文档</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>  |
        <a title="Table of contents" href="../../contents.html">Table of contents</a>  |
        <a title="Global index" href="../../genindex.html">Index</a>  |
        <a title="Module index" href="../../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="models.html" title="模型">previous</a>
     |
    <a href="../index.html" title="使用 Django" accesskey="U">up</a>
   |
    <a href="aggregation.html" title="聚合">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-db-queries">
            
  <div class="section" id="s-making-queries">
<span id="making-queries"></span><h1>执行查询<a class="headerlink" href="#making-queries" title="永久链接至标题">¶</a></h1>
<p>一旦创建 <a class="reference internal" href="models.html"><span class="doc">数据模型</span></a> 后，Django 自动给予你一套数据库抽象 API，允许你创建，检索，更新和删除对象。本页介绍如何使用这些 API。参考 <a class="reference internal" href="../../ref/models/index.html"><span class="doc">数据模型参考</span></a> 获取所有查询选项的完整细节。</p>
<p>在本指南中（以及在参考资料中），我们将提及以下模型，它们构成了一个博客应用程序：</p>
<div class="highlight-python notranslate" id="queryset-model-example"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>

<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">mod_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">)</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">number_of_comments</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">number_of_pingbacks</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
</div>
<div class="section" id="s-creating-objects">
<span id="creating-objects"></span><h2>创建对象<a class="headerlink" href="#creating-objects" title="永久链接至标题">¶</a></h2>
<p>为了用 Python 对象展示数据表对象，Django 使用了一套直观的系统：一个模型类代表一张数据表，一个模型类的实例代表数据库表中的一行记录。</p>
<p>要创建一个对象，用关键字参数初始化它，然后调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 将其存入数据库。</p>
<p>假设模型存在于文件 <code class="docutils literal notranslate"><span class="pre">mysite/blog/models.py</span></code> 中，这里是一个示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;All the latest Beatles news.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>这在幕后执行了 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> SQL 语句。Django 在你显式调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 才操作数据库。</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法没有返回值。</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 接受很多此处未介绍的高级选项。参考文档 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 获取完整细节。</p>
<p class="last">要一步创建并保存一个对象，使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> 方法。</p>
</div>
</div>
<div class="section" id="s-saving-changes-to-objects">
<span id="saving-changes-to-objects"></span><h2>将修改保存至对象<a class="headerlink" href="#saving-changes-to-objects" title="永久链接至标题">¶</a></h2>
<p>要将修改保存至数据库中已有的某个对象，使用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>。</p>
<p>给定一个已经保存到数据库中的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 实例 <code class="docutils literal notranslate"><span class="pre">b5</span></code>，这个示例会修改其名称并更新其在数据库中的记录：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;New name&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>这在幕后执行了 <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> SQL 语句。Django 在你显示调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 后才操作数据库。</p>
<div class="section" id="s-saving-foreignkey-and-manytomanyfield-fields">
<span id="saving-foreignkey-and-manytomanyfield-fields"></span><h3>保存 <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 字段<a class="headerlink" href="#saving-foreignkey-and-manytomanyfield-fields" title="永久链接至标题">¶</a></h3>
<p>更新 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 字段的方法与保存普通字段完全相同——将正确类型的对象分配给相应的字段。这个示例更新了 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 实例 <code class="docutils literal notranslate"><span class="pre">entry</span></code> 的 <code class="docutils literal notranslate"><span class="pre">blog</span></code> 属性，假设已经保存了适当的 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 实例到数据库中（因此我们可以在下面检索到它们）：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Blog</span><span class="p">,</span> <span class="n">Entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cheese_blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cheddar Talk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">cheese_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>更新 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 有一些不同之处——可以使用字段上的 <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> 方法来添加一个记录到关系中。这个示例将 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 实例 <code class="docutils literal notranslate"><span class="pre">joe</span></code> 添加到 <code class="docutils literal notranslate"><span class="pre">entry</span></code> 对象中：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Author</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">joe</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Joe&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">joe</span><span class="p">)</span>
</pre></div>
</div>
<p>要一次性添加多个记录到 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a>，在调用 <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> 时包括多个参数，如下所示：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;John&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paul</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Paul&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">george</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;George&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringo</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ringo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">john</span><span class="p">,</span> <span class="n">paul</span><span class="p">,</span> <span class="n">george</span><span class="p">,</span> <span class="n">ringo</span><span class="p">)</span>
</pre></div>
</div>
<p>Django 会在添加或指定错误类型的对象时报错。</p>
</div>
</div>
<div class="section" id="s-retrieving-objects">
<span id="s-id1"></span><span id="retrieving-objects"></span><span id="id1"></span><h2>检索对象<a class="headerlink" href="#retrieving-objects" title="永久链接至标题">¶</a></h2>
<p>要从数据库检索对象，要通过模型类的 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 构建一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。</p>
<p>一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 代表来自数据库中对象的一个集合。它可以有 0 个，1 个或者多个 <em>filters</em>. Filters，可以根据给定参数缩小查询结果量。在 SQL 的层面上， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 对应 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 语句，而*filters*对应类似 <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 或 <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> 的限制子句。</p>
<p>通过使用你的模型的 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>，你可以获得一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。每个模型至少有一个 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>，默认情况下称为 <a class="reference internal" href="../../ref/models/class.html#django.db.models.Model.objects" title="django.db.models.Model.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a>。可以直接通过模型类来访问它，如下所示：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span>
<span class="go">&lt;django.db.models.manager.Manager object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Bar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">objects</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager isn&#39;t accessible via Blog instances.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Managers</span></code> 只能通过模型类访问，而不是通过模型实例，目的是强制分离 “表级” 操作和 “行级” 操作。</p>
</div>
<p><a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 是模型的 <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> 主要来源。例如 <code class="docutils literal notranslate"><span class="pre">Blog.objects.all()</span></code> 返回了一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，后者包含了数据库中所有的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象。</p>
<div class="section" id="s-retrieving-all-objects">
<span id="retrieving-all-objects"></span><h3>检索全部对象<a class="headerlink" href="#retrieving-all-objects" title="永久链接至标题">¶</a></h3>
<p>从表中检索对象的最简单方法是获取所有对象。要做到这一点，可以在 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 上使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> 方法：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">all_entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>方法 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> 返回了一个包含数据库中所有对象的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 对象。</p>
</div>
<div class="section" id="s-retrieving-specific-objects-with-filters">
<span id="retrieving-specific-objects-with-filters"></span><h3>通过过滤器检索指定对象<a class="headerlink" href="#retrieving-specific-objects-with-filters" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> 返回的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 包含了数据表中所有的对象。虽然，大多数情况下，你只需要完整对象集合的一个子集。</p>
<p>要创建一个这样的子集，你需要通过添加过滤条件精炼原始 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。两种最常见的精炼 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的方式是：</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">filter(**kwargs)</span></code></dt><dd>返回一个新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，包含的对象满足给定查询参数。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exclude(**kwargs)</span></code></dt><dd>返回一个新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，包含的对象 <em>不</em> 满足给定查询参数。</dd>
</dl>
<p>查询参数（<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>）应该符合下面的 <a class="reference internal" href="#field-lookups">Field lookups</a> 的要求。</p>
<p>例如，要包含获取 2006 年的博客条目（entries blog）的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，像这样使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<p>通过默认管理器类也一样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-chaining-filters">
<span id="s-id2"></span><span id="chaining-filters"></span><span id="id2"></span><h4>链式过滤器<a class="headerlink" href="#chaining-filters" title="永久链接至标题">¶</a></h4>
<p>对 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 进行细化的结果本身也是一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，因此可以将细化操作链接在一起。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
</pre></div>
</div>
<p>这个先获取包含数据库所有条目（entry）的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，然后排除一些，再进入另一个过滤器。最终的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 包含标题以 &quot;What&quot; 开头的，发布日期介于 2005 年 1 月 30 日与今天之间的所有条目。</p>
</div>
<div class="section" id="s-filtered-querysets-are-unique">
<span id="s-id3"></span><span id="filtered-querysets-are-unique"></span><span id="id3"></span><h4>每个 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 都是唯一的<a class="headerlink" href="#filtered-querysets-are-unique" title="永久链接至标题">¶</a></h4>
<p>每次精炼一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，你就会获得一个全新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，后者与前者毫无关联。每次精炼都会创建一个单独的、不同的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，能被存储，使用和复用。</p>
<p>例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q3</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
</pre></div>
</div>
<p>这三个 <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> 是独立的。第一个是基础 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，包含了所有标题以 &quot;What&quot; 开头的条目。第二个是第一个的子集，带有额外条件，排除了 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> 是今天和今天之后的所有记录。第三个是第一个的子集，带有额外条件，只筛选 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> 是今天或未来的所有记录。最初的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> (<code class="docutils literal notranslate"><span class="pre">q1</span></code>) 不受筛选操作影响。</p>
</div>
<div class="section" id="s-querysets-are-lazy">
<span id="s-id4"></span><span id="querysets-are-lazy"></span><span id="id4"></span><h4><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 是惰性的<a class="headerlink" href="#querysets-are-lazy" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> 是惰性的 —— 创建 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的过程不涉及任何数据库活动。你可以一直堆叠过滤条件，但 Django 实际上不会运行查询，直到 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 被 <em>评估</em>。看看这个例子：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">body_text__icontains</span><span class="o">=</span><span class="s2">&quot;food&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>虽然这看起来像是三次数据库操作，实际上只在最后一行 (<code class="docutils literal notranslate"><span class="pre">print(q)</span></code>) 做了一次。一般来说， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的结果直到你 “要使用” 时才会从数据库中拿出。当你要用时，才通过数据库 <em>计算</em> 出 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>。关于何时才真的执行计算的更多细节，参考 <a class="reference internal" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><span class="std std-ref">什么时候 QuerySet 被执行</span></a>。</p>
</div>
</div>
<div class="section" id="s-retrieving-a-single-object-with-get">
<span id="s-retrieving-single-object-with-get"></span><span id="retrieving-a-single-object-with-get"></span><span id="retrieving-single-object-with-get"></span><h3>用 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 检索单个对象<a class="headerlink" href="#retrieving-a-single-object-with-get" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 总是返回一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，即便只有一个对象满足查询条件 —— 这种情况下， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 只包含了一个元素。</p>
<p>如果你知道只有一个对象符合你的查询条件，你可以在 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 上使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 方法，它会直接返回该对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">one_entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以对 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 使用与 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 类似的所有查询表达式 —— 同样的，参考下面的 <a class="reference internal" href="#field-lookups">Field lookups</a>。</p>
<p>注意， 使用切片 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 时的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 有点不同。如果没有满足查询条件的结果， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 会抛出一个 <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> 异常。该异常是执行查询的模型类的一个属性 —— 所有，上述代码中，若没有哪个 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象的主键是 1，Django 会抛出 <code class="docutils literal notranslate"><span class="pre">Entry.DoesNotExist</span></code>。</p>
<p>类似了，Django 会在有不止一个记录满足 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 查询条件时发出警告。这时，Django 会抛出 <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultipleObjectsReturned</span></code></a>，这同样也是模型类的一个属性。</p>
</div>
<div class="section" id="s-other-queryset-methods">
<span id="other-queryset-methods"></span><h3>其它 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法<a class="headerlink" href="#other-queryset-methods" title="永久链接至标题">¶</a></h3>
<p>大多数情况下，你会在需要从数据库中检索对象时使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a>。然而，这样远远不够；完整的各种 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法请参阅 <a class="reference internal" href="../../ref/models/querysets.html#queryset-api"><span class="std std-ref">QuerySet&nbsp;API 参考</span></a>。</p>
</div>
<div class="section" id="s-limiting-querysets">
<span id="s-id5"></span><span id="limiting-querysets"></span><span id="id5"></span><h3>限制 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 条目数<a class="headerlink" href="#limiting-querysets" title="永久链接至标题">¶</a></h3>
<p>利用 Python 的数组切片语法将 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 切成指定长度。这等价于 SQL 的 <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">OFFSET</span></code> 子句。</p>
<p>例如，这返回前5个对象（<code class="docutils literal notranslate"><span class="pre">LIMIT</span> <span class="pre">5</span></code>）：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>这返回第六到第十个对象（<code class="docutils literal notranslate"><span class="pre">OFFSET</span> <span class="pre">5</span> <span class="pre">LIMIT</span> <span class="pre">5</span></code>）：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>不支持负索引 (例如 <code class="docutils literal notranslate"><span class="pre">Entry.objects.all()[-1]</span></code>)</p>
<p>通常，对 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 进行切片会返回一个新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，它不会评估查询。一个例外是如果使用了 Python 切片语法的 &quot;step&quot; 参数。例如，这会实际执行查询，以返回前10个对象中的每 <em>第二个</em> 对象的列表：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>由于对 queryset 切片工作方式的模糊性，禁止对其进行进一步的排序或过滤。</p>
<p>要检索 <em>单个</em> 对象而不是列表（例如，<code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">foo</span> <span class="pre">FROM</span> <span class="pre">bar</span> <span class="pre">LIMIT</span> <span class="pre">1</span></code>），请使用索引而不是切片。例如，这会按标题的字母顺序返回数据库中的第一个 <code class="docutils literal notranslate"><span class="pre">Entry</span></code>：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这大致相当于：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>然而，注意一下，若没有对象满足给定条件，前者会抛出 <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>，而后者会抛出 <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code>。参考 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 获取更多细节。</p>
</div>
<div class="section" id="s-field-lookups">
<span id="s-field-lookups-intro"></span><span id="field-lookups"></span><span id="field-lookups-intro"></span><h3>字段查询<a class="headerlink" href="#field-lookups" title="永久链接至标题">¶</a></h3>
<p>字段查询即你如何制定 SQL <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 子句。它们以关键字参数的形式传递给 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>。</p>
<p>基本的查找关键字参数采用形式 <code class="docutils literal notranslate"><span class="pre">field__lookuptype=value</span></code> （使用双下划线）。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="s2">&quot;2006-01-01&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>转换为 SQL 语句大致如下：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">blog_entry</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">pub_date</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="s1">&#39;2006-01-01&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition-how-this-is-possible admonition">
<p class="first admonition-title">这是怎么做到的</p>
<p class="last">Python 能定义可接受任意数量 name-value 参数的函数，参数名和值均在运行时计算。更多信息，请参考官方 Python 教程中的 <a class="reference external" href="https://docs.python.org/3/tutorial/controlflow.html#tut-keywordargs" title="(在 Python v3.12)"><span>Keyword Arguments</span></a>。</p>
</div>
<p>查询子句中指定的字段必须是模型的一个字段名。不过也有个例外，在 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 中，你可以指定以 <code class="docutils literal notranslate"><span class="pre">_id</span></code> 为后缀的字段名。这种情况下，value 参数需要包含 foreign 模型的主键的原始值。例子：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog_id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>若你传入了无效的关键字参数，查询函数会抛出 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>。</p>
<p>数据库 API 支持两套查询类型；完整参考文档位于 <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">字段查询参考</span></a>。为了让你了解能干啥，以下是一些常见的查询：</p>
<dl class="docutils">
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a></dt><dd><p>一个 &quot;exact&quot; 匹配。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__exact</span><span class="o">=</span><span class="s2">&quot;Cat bites dog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>会生成这些 SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Cat bites dog&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>若你为提供查询类型 —— 也就说，若关键字参数未包含双下划线 —— 查询类型会被指定为 <code class="docutils literal notranslate"><span class="pre">exact</span></code>。</p>
<p>例如，以下两个语句是等价的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
</pre></div>
</div>
<p>这是为了方便，因为 <code class="docutils literal notranslate"><span class="pre">exact</span></code> 查询是最常见的。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a></dt><dd><p>不区分大小写的匹配。因此，查询：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s2">&quot;beatles blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>会匹配标题为 <code class="docutils literal notranslate"><span class="pre">&quot;Beatles</span> <span class="pre">Blog&quot;</span></code>， <code class="docutils literal notranslate"><span class="pre">&quot;beatles</span> <span class="pre">blog&quot;</span></code>， 甚至 <code class="docutils literal notranslate"><span class="pre">&quot;BeAtlES</span> <span class="pre">blOG&quot;</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code>。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a></dt><dd><p>大小写敏感的包含测试。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>粗略地转为 SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>注意这将匹配标题 <code class="docutils literal notranslate"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></code>。</p>
<p>这也有个大小写不敏感的版本， <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">icontains</span></code></a>。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">startswith</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">endswith</span></code></a></dt><dd>以……开头和以……结尾的查找。当然也有大小写不敏感的版本，名为 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">istartswith</span></code></a> 和 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iendswith</span></code></a>。</dd>
</dl>
<p>同样，这只介绍了皮毛。完整的参考能在 <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">field&nbsp;查询参考</span></a> 找到。</p>
</div>
<div class="section" id="s-lookups-that-span-relationships">
<span id="s-id6"></span><span id="lookups-that-span-relationships"></span><span id="id6"></span><h3>跨关系查询<a class="headerlink" href="#lookups-that-span-relationships" title="永久链接至标题">¶</a></h3>
<p>Django 提供了一种强大而直观的方式来“追踪”查询中的关系，在幕后自动为你处理 SQL <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> 关系。为了跨越关系，跨模型使用关联字段名，字段名由双下划线分割，直到拿到想要的字段。</p>
<p>这个示例检索所有具有 <code class="docutils literal notranslate"><span class="pre">name</span></code> 为 <code class="docutils literal notranslate"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>跨域的深度随你所想。</p>
<p>它也可以反向工作。虽然它 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">可以自定义</span></code></a>，默认情况下，你在查找中使用模型的小写名称来引用一个 “反向” 关系。</p>
<p>这个示例检索所有至少有一个 <code class="docutils literal notranslate"><span class="pre">headline</span></code> 包含 <code class="docutils literal notranslate"><span class="pre">'Lennon'</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你在跨多个关系进行筛选，而某个中间模型的没有满足筛选条件的值，Django  会将它当做一个空的（所有值都是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>）但是有效的对象。这样就意味着不会抛出错误。例如，在这个过滤器中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>（假设有个关联的 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 模型），若某项条目没有任何关联的 <code class="docutils literal notranslate"><span class="pre">author</span></code>，它会被视作没有关联的 <code class="docutils literal notranslate"><span class="pre">name</span></code>，而不是因为缺失 <code class="docutils literal notranslate"><span class="pre">author</span></code> 而抛出错误。大多数情况下，这就是你期望的。唯一可能使你迷惑的场景是在使用 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a> 时。因此:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>将会返回 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象，包含 <code class="docutils literal notranslate"><span class="pre">author</span></code> 的 <code class="docutils literal notranslate"><span class="pre">name</span></code> 为空的对象，以及那些 <code class="docutils literal notranslate"><span class="pre">entry</span></code> 的 <code class="docutils literal notranslate"><span class="pre">author</span></code> 为空的对象。若你不想要后面的对象，你可以这样写:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__isnull</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-spanning-multi-valued-relationships">
<span id="s-id7"></span><span id="spanning-multi-valued-relationships"></span><span id="id7"></span><h4>跨多值关联<a class="headerlink" href="#spanning-multi-valued-relationships" title="永久链接至标题">¶</a></h4>
<p>当跨越 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 或反查 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> （例如从 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> ）时，对多个属性进行过滤会产生这样的问题：是否要求每个属性都在同一个相关对象中重合。我们可能会寻找那些在标题中含有 <em>“Lennon”</em> 的 2008 年的博客，或者我们可能会寻找那些仅有 2008 年的任何条目以及一些在标题中含有 <em>“Lennon”</em> 的较新或较早的条目。</p>
<p>要选择所有包含 2008 年至少一个标题中有 <em>&quot;Lennon&quot;</em> 的条目的博客（满足两个条件的同一条目），我们要写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span> <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
</div>
<p>否则，如果要执行一个更为宽松的查询，选择任何只在标题中带有 <em>&quot;Lennon&quot;</em> 的条目和 2008 年的条目的博客，我们将写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span>
<span class="p">)</span>
</pre></div>
</div>
<p>假设只有一个博客既有包含 <em>&quot;Lennon&quot;</em> 的条目又有 2008 年的条目，但 2008 年的条目中没有包含 <em>&quot;Lennon&quot;</em> 。第一个查询不会返回任何博客，但第二个查询会返回那一个博客。（这是因为第二个过滤器选择的条目可能与第一个过滤器中的条目相同，也可能不相同）。我们是用每个过滤器语句来过滤 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 项，而不是 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 项）。简而言之，如果每个条件需要匹配相同的相关对象，那么每个条件应该包含在一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code> 调用中。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p>由于第二个（更宽松的）查询链接了多个过滤器，它对主模型进行了多次连接，可能会产生重复的结果。</p>
<div class="last highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pop</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Pop Music Blog&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;New Lennon Biography&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: New Lennon Biography&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;New Lennon Biography in Paperback&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: New Lennon Biography in Paperback&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">pop</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Best Albums of 2008&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: Best Albums of 2008&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">pop</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Lennon Would Have Loved Hip Hop&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: Lennon Would Have Loved Hip Hop&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;, &lt;Blog: Beatles Blog&gt;, &lt;Blog: Pop Music Blog]&gt;</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 的查询行为会跨越多值关联，就像前文说的那样，并不与 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 相同。相反，一次 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 调用的条件并不需要指向同一项目。</p>
<p>例如，以下查询会排除那些关联条目标题包含 <em>&quot;Lennon&quot;</em> 且发布于 2008 年的博客:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>但是，与 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 的行为不同，其并不会限制博客同时满足这两种条件。要这么做的话，也就是筛选出所有条目标题不带 <em>&quot;Lennon&quot;</em> 且发布年不是 2008 的博客，你需要做两次查询:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__in</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
        <span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-filters-can-reference-fields-on-the-model">
<span id="s-using-f-expressions-in-filters"></span><span id="filters-can-reference-fields-on-the-model"></span><span id="using-f-expressions-in-filters"></span><h3>过滤器可以为模型指定字段<a class="headerlink" href="#filters-can-reference-fields-on-the-model" title="永久链接至标题">¶</a></h3>
<p>在之前的例子中，我们已经构建过的 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 都是将模型字段值与常量做比较。但是，要怎么做才能将模型字段值与同一模型中的另一字段做比较呢？</p>
<p>Django 提供了 <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">表达式</span></code></a> 实现这种比较。 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 的实例充当查询中的模型字段的引用。这些引用可在查询过滤器中用于在同一模型实例中比较两个不同的字段。</p>
<p>例如，要找到所有具有比 pingback 更多评论的博客条目的列表，我们构建一个引用 pingback 计数的 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象，并在查询中使用该 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">number_of_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Django 支持在 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象中使用加法、减法、乘法、除法、取模和幂算术，既可以与常数一起使用，也可以与其他 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象一起使用。要查找所有具有评论数超过 pingback 两倍的博客条目，我们修改查询如下：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">number_of_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>要查找所有评分低于评论数和 pingback 数的总和的条目，我们可以发出以下查询：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">rating__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_comments&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>你还可以在 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象中使用双下划线符号来跨越关系。带有双下划线的 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象将引入任何所需的连接以访问相关对象。例如，要检索所有作者名称与博客名称相同的条目，可以发出以下查询：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">authors__name</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;blog__name&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>对于日期和日期/时间字段，你可以添加或减去一个 <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> 对象。以下代码将返回所有在发布后超过3天修改的条目：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mod_date__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;pub_date&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象支持位操作，包括 <code class="docutils literal notranslate"><span class="pre">.bitand()</span></code>、<code class="docutils literal notranslate"><span class="pre">.bitor()</span></code>、<code class="docutils literal notranslate"><span class="pre">.bitxor()</span></code>、<code class="docutils literal notranslate"><span class="pre">.bitrightshift()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.bitleftshift()</span></code>。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;somefield&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-oracle admonition">
<p class="first admonition-title">Oracle</p>
<p class="last">Oracle 不支持按位 XOR 操作。</p>
</div>
</div>
<div class="section" id="s-expressions-can-reference-transforms">
<span id="s-using-transforms-in-expressions"></span><span id="expressions-can-reference-transforms"></span><span id="using-transforms-in-expressions"></span><h3>表达式可以引用变换<a class="headerlink" href="#expressions-can-reference-transforms" title="永久链接至标题">¶</a></h3>
<p>Django 支持在表达式中使用变换。</p>
<p>例如，要找到所有与它们上次修改的年份相同的 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;mod_date__year&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>要找到条目发布的最早年份，我们可以发出以下查询：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Min</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">first_published_year</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>这个示例查找了评分最高的条目的值以及每年所有条目的总评论数：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">OuterRef</span><span class="p">,</span> <span class="n">Subquery</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">top_rating</span><span class="o">=</span><span class="n">Subquery</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">pub_date__year</span><span class="o">=</span><span class="n">OuterRef</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">)</span>
<span class="gp">... </span>        <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;-rating&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s2">&quot;rating&quot;</span><span class="p">)[:</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="p">),</span>
<span class="gp">... </span>    <span class="n">total_comments</span><span class="o">=</span><span class="n">Sum</span><span class="p">(</span><span class="s2">&quot;number_of_comments&quot;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-the-pk-lookup-shortcut">
<span id="the-pk-lookup-shortcut"></span><h3>主键 (<code class="docutils literal notranslate"><span class="pre">pk</span></code>) 查询快捷方式<a class="headerlink" href="#the-pk-lookup-shortcut" title="永久链接至标题">¶</a></h3>
<p>出于方便的目的，Django 提供了一种 <code class="docutils literal notranslate"><span class="pre">pk</span></code> 查询快捷方式， <code class="docutils literal notranslate"><span class="pre">pk</span></code> 表示主键 &quot;primary key&quot;。</p>
<p>在示例的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 模型中，主键是 <code class="docutils literal notranslate"><span class="pre">id</span></code> 字段，因此以下三个语句是等效的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># pk implies id__exact</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">pk</span></code> 的使用不限于 <code class="docutils literal notranslate"><span class="pre">__exact</span></code> 查询 —— 任何查询条件都可以与 <code class="docutils literal notranslate"><span class="pre">pk</span></code> 结合使用，以执行关于模型的主键的查询：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Get blogs entries with id 1, 4 and 7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk__in</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="go"># Get all blog entries with id &gt; 14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk__gt</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pk</span></code> 查询也可以跨越关联进行。例如，以下三个语句是等效的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id__exact</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__pk</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># __pk implies __id__exact</span>
</pre></div>
</div>
</div>
<div class="section" id="s-escaping-percent-signs-and-underscores-in-like-statements">
<span id="escaping-percent-signs-and-underscores-in-like-statements"></span><h3>在 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中转义百分号和下划线<a class="headerlink" href="#escaping-percent-signs-and-underscores-in-like-statements" title="永久链接至标题">¶</a></h3>
<p>等效于 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> SQL 语句的字段查询子句 (<code class="docutils literal notranslate"><span class="pre">iexact</span></code>， <code class="docutils literal notranslate"><span class="pre">contains</span></code>， <code class="docutils literal notranslate"><span class="pre">icontains</span></code>， <code class="docutils literal notranslate"><span class="pre">startswith</span></code>， <code class="docutils literal notranslate"><span class="pre">istartswith</span></code>， <code class="docutils literal notranslate"><span class="pre">endswith</span></code> 和 <code class="docutils literal notranslate"><span class="pre">iendswith</span></code>) 会将 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中有特殊用途的两个符号，即百分号和下划线自动转义。（在 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中，百分号匹配多个任意字符，而下划线匹配一个任意字符。）</p>
<p>这意味着事情应该工作得很直观，所以抽象不会泄露。例如，要检索所有包含百分号的条目，可以将百分号视为任何其他字符：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Django 为你小心处理了引号；生成的 SQL 语句看起来像这样：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%\%%&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>同样的处理也包括下划线。百分号和下划线都为你自动处理，你无需担心。</p>
</div>
<div class="section" id="s-caching-and-querysets">
<span id="s-id8"></span><span id="caching-and-querysets"></span><span id="id8"></span><h3>缓存和 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#caching-and-querysets" title="永久链接至标题">¶</a></h3>
<p>每个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 都带有缓存，尽量减少数据库访问。理解它是如何工作的能让你编写更高效的代码。</p>
<p>新创建的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 缓存是空的。一旦要计算 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的值，就会执行数据查询，随后，Django 就会将查询结果保存在 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的缓存中，并返回这些显式请求的缓存（例如，下一个元素，若 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 正在被迭代）。后续针对 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的计算会复用缓存结果。</p>
<p>请记住这种缓存行为，因为如果不正确使用你的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，可能会出现问题。例如，以下代码会创建两个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，对它们进行评估，然后将它们丢弃：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
</pre></div>
</div>
<p>这意味着同样的数据库查询会被执行两次，实际加倍了数据库负载。同时，有可能这两个列表不包含同样的记录，因为在两次请求间，可能有 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 被添加或删除了。</p>
<p>为了避免这个问题，保存 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 并重复使用它：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span>  <span class="c1"># Evaluate the query set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span>  <span class="c1"># Reuse the cache from the evaluation.</span>
</pre></div>
</div>
<div class="section" id="s-when-querysets-are-not-cached">
<span id="when-querysets-are-not-cached"></span><h4>当 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 未被缓存时<a class="headerlink" href="#when-querysets-are-not-cached" title="永久链接至标题">¶</a></h4>
<p>查询结果集并不总是缓存结果。当仅计算查询结果集的 <em>部分</em> 时，会校验缓存，若没有填充缓存，则后续查询返回的项目不会被缓存。特别地说，这意味着使用数组切片或索引的 <a class="reference internal" href="#limiting-querysets"><span class="std std-ref">限制查询结果集</span></a> 不会填充缓存。</p>
<p>例如，反复获取查询集对象中的某个索引会每次查询数据库：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Queries the database again</span>
</pre></div>
</div>
<p>然而，如果整个查询集已经被评估过，那么会检查缓存而不是查询数据库：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>  <span class="c1"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Uses cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Uses cache</span>
</pre></div>
</div>
<p>以下是一些其他会导致整个查询集被评估并因此填充缓存的示例操作：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">只是打印查询结果集不会填充缓存。因为调用 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> 仅返回了完整结果集的一个切片。</p>
</div>
</div>
</div>
</div>
<div class="section" id="s-asynchronous-queries">
<span id="s-async-queries"></span><span id="asynchronous-queries"></span><span id="async-queries"></span><h2>异步查询<a class="headerlink" href="#asynchronous-queries" title="永久链接至标题">¶</a></h2>
<p>如果你正在编写异步视图或代码，你不能像我们上面描述的那样完全使用 ORM 进行查询，因为你不能从异步代码中调用 <em>阻塞的</em> 同步代码 —— 它会阻塞事件循环（或者更可能的是，Django 会注意到并引发 <code class="docutils literal notranslate"><span class="pre">SynchronousOnlyOperation</span></code> 以阻止发生这种情况）。</p>
<p>幸运的是，你可以使用 Django 的异步查询 API 执行许多查询。每个可能阻塞的方法，比如 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">delete()</span></code>，都有一个异步的变体（<code class="docutils literal notranslate"><span class="pre">aget()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">adelete()</span></code>），当你遍历结果时，你可以使用异步迭代（<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>）。</p>
<div class="section" id="s-query-iteration">
<span id="query-iteration"></span><h3>查询迭代<a class="headerlink" href="#query-iteration" title="永久链接至标题">¶</a></h3>
<p>默认情况下，通过 <code class="docutils literal notranslate"><span class="pre">for</span></code> 遍历查询会在幕后导致阻塞的数据库查询，因为 Django 在迭代时加载结果。要解决这个问题，你可以切换到 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">Authors</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>请注意，你也不能执行其他可能会遍历查询集的操作，比如用 <code class="docutils literal notranslate"><span class="pre">list()</span></code> 包装它来强制评估它（如果需要，可以在推导式中使用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>）。</p>
<p>因为 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法，比如 <code class="docutils literal notranslate"><span class="pre">filter()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exclude()</span></code>，实际上不会运行查询 —— 它们设置了查询集，以便在迭代时运行 —— 所以你可以在异步代码中自由使用它们。关于哪些方法可以继续像这样使用，哪些有异步版本的指南，请阅读下一节。</p>
</div>
<div class="section" id="s-queryset-and-manager-methods">
<span id="queryset-and-manager-methods"></span><h3><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 和管理器方法<a class="headerlink" href="#queryset-and-manager-methods" title="永久链接至标题">¶</a></h3>
<p>管理器和查询集上的一些方法 - 比如 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">first()</span></code> - 强制执行查询集并会阻塞。而一些方法，比如 <code class="docutils literal notranslate"><span class="pre">filter()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exclude()</span></code>，不会强制执行查询集，因此可以从异步代码中安全运行。但是你应该如何区分它们呢？</p>
<p>虽然你可以查看是否有方法的名称前缀是 <code class="docutils literal notranslate"><span class="pre">a</span></code> （例如，我们有 <code class="docutils literal notranslate"><span class="pre">aget()</span></code>，但没有 <code class="docutils literal notranslate"><span class="pre">afilter()</span></code>），但有一种更合理的方法是查看 <a class="reference internal" href="../../ref/models/querysets.html"><span class="doc">QuerySet 参考文档</span></a>，了解方法的类型。</p>
<p>在这里，你会发现查询集的方法分成了两个部分：</p>
<ul class="simple">
<li><em>返回新查询集的方法</em>：这些方法是非阻塞的，并且没有异步版本。你可以在任何情况下自由使用它们，不过在使用之前请阅读关于 <code class="docutils literal notranslate"><span class="pre">defer()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">only()</span></code> 的注释。</li>
<li><em>不返回查询集的方法</em>：这些方法是阻塞的，并且有异步版本 - 在每个方法的文档中都有它的异步名称，尽管我们的标准模式是在名称前加上 <code class="docutils literal notranslate"><span class="pre">a</span></code> 前缀。</li>
</ul>
<p>使用这个区别，你可以确定何时需要使用异步版本，何时不需要。例如，以下是一个有效的异步查询示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">my_input</span><span class="p">)</span><span class="o">.</span><span class="n">afirst</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">filter()</span></code> 返回一个查询集，因此在异步环境中可以继续链式调用它，而 <code class="docutils literal notranslate"><span class="pre">first()</span></code> 会计算并返回一个模型实例 - 因此，我们改用 <code class="docutils literal notranslate"><span class="pre">afirst()</span></code>，并在整个表达式的前面使用 <code class="docutils literal notranslate"><span class="pre">await</span></code> 以异步友好的方式调用它。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">如果你忘记了加上 <code class="docutils literal notranslate"><span class="pre">await</span></code>，你可能会看到类似 <em>&quot;coroutine object has no attribute x&quot;</em> 的错误，或者在你的模型实例位置看到 <em>&quot;&lt;coroutine …&gt;&quot;</em> 字符串。如果你看到这些错误，说明你忘记了在某个地方添加 <code class="docutils literal notranslate"><span class="pre">await</span></code> 来将协程转换为真实值。</p>
</div>
</div>
<div class="section" id="s-transactions">
<span id="transactions"></span><h3>事务<a class="headerlink" href="#transactions" title="永久链接至标题">¶</a></h3>
<p>目前，异步查询和更新 <strong>不</strong> 支持事务。如果尝试在异步查询中使用事务，会引发 <code class="docutils literal notranslate"><span class="pre">SynchronousOnlyOperation</span></code> 错误。</p>
<p>如果希望使用事务，建议将 ORM 代码编写在单独的同步函数中，然后使用 <code class="docutils literal notranslate"><span class="pre">sync_to_async</span></code> 来调用它 - 参阅 <a class="reference internal" href="../async.html"><span class="doc">异步支持</span></a> 获取更多信息。</p>
</div>
</div>
<div class="section" id="s-querying-jsonfield">
<span id="s-id9"></span><span id="querying-jsonfield"></span><span id="id9"></span><h2>查询 <code class="docutils literal notranslate"><span class="pre">JSONField</span></code><a class="headerlink" href="#querying-jsonfield" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a> 里的查找实现是不一样的，主要因为存在键转换。为了演示，我们将使用下面这个例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">JSONField</span><span class="p">(</span><span class="n">null</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<div class="section" id="s-storing-and-querying-for-none">
<span id="storing-and-querying-for-none"></span><h3>保存和查询 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值<a class="headerlink" href="#storing-and-querying-for-none" title="永久链接至标题">¶</a></h3>
<p>与其他字段一样，将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 存储为字段的值将其存储为 SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。虽然不推荐这样做，但可以通过使用 <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.Value" title="django.db.models.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value(None,</span> <span class="pre">JSONField())</span></code></a> 来存储 JSON 标量的 <code class="docutils literal notranslate"><span class="pre">null</span></code>，而不是 SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>无论存储哪种值，当从数据库检索时，JSON 标量 <code class="docutils literal notranslate"><span class="pre">null</span></code> 的 Python 表示法与 SQL 的 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 相同，即 <code class="docutils literal notranslate"><span class="pre">None</span></code>。因此，可能很难区分它们。</p>
<p>这只适用于 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值作为字段的顶级值。如果 <code class="docutils literal notranslate"><span class="pre">None</span></code> 被保存在列表或字典中，它将始终被解释为 JSON 的 <code class="docutils literal notranslate"><span class="pre">null</span></code> 值。</p>
<p>在查询时，<code class="docutils literal notranslate"><span class="pre">None</span></code> 值将始终被解释为 JSON <code class="docutils literal notranslate"><span class="pre">null</span></code>。要查询 SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，请使用 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a>：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Max&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># SQL NULL.</span>
<span class="go">&lt;Dog: Max&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Archie&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">()))</span>  <span class="c1"># JSON null.</span>
<span class="go">&lt;Dog: Archie&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">()))</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Max&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__isnull</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
</pre></div>
</div>
<p>除非你确定要使用 SQL 的 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值，否则请考虑设置 <code class="docutils literal notranslate"><span class="pre">null=False</span></code> 并为空值提供合适的默认值，例如 <code class="docutils literal notranslate"><span class="pre">default=dict</span></code> 。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">保存 JSON 的 <code class="docutils literal notranslate"><span class="pre">null</span></code> 值不违反 Django 的 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null=False</span></code></a> 。</p>
</div>
<div class="versionchanged">
<span class="title">Changed in Django 4.2:</span> <p>添加了使用 <code class="docutils literal notranslate"><span class="pre">Value(None,</span> <span class="pre">JSONField())</span></code> 表达 JSON <code class="docutils literal notranslate"><span class="pre">null</span></code> 的支持。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">4.2 版后已移除: </span>传递 <code class="docutils literal notranslate"><span class="pre">Value(&quot;null&quot;)</span></code> 以表示 JSON <code class="docutils literal notranslate"><span class="pre">null</span></code> 已弃用。</p>
</div>
</div>
<div class="section" id="s-key-index-and-path-transforms">
<span id="s-std-fieldlookup-jsonfield.key"></span><span id="s-std:fieldlookup-jsonfield.key"></span><span id="key-index-and-path-transforms"></span><span id="std-fieldlookup-jsonfield.key"></span><span id="std:fieldlookup-jsonfield.key"></span><h3>键、索引和路径转换<a class="headerlink" href="#key-index-and-path-transforms" title="永久链接至标题">¶</a></h3>
<p>要基于给定的字典键进行查询，请将该键用作查找名称：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s2">&quot;other_pets&quot;</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">... </span>                <span class="p">{</span>
<span class="gp">... </span>                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Fishy&quot;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="p">}</span>
<span class="gp">... </span>            <span class="p">],</span>
<span class="gp">... </span>        <span class="p">},</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__breed</span><span class="o">=</span><span class="s2">&quot;collie&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
<p>可以将多个键链接在一起以形成路径查找：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__name</span><span class="o">=</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;</span>
</pre></div>
</div>
<p>如果键是整数，则将其解释为数组中的索引变换：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__other_pets__0__name</span><span class="o">=</span><span class="s2">&quot;Fishy&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;</span>
</pre></div>
</div>
<p>如果要查询的键与另一个查询的键名冲突，请改用 <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> 来查询。</p>
<p>要查询缺少的键，请使用 <code class="docutils literal notranslate"><span class="pre">isnull</span></code> 查找：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shep&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Shep&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">上面给出的例子隐式地使用了 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a> 查找。Key，索引和路径转换也可以用：<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">icontains</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">endswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iendswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-regex"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">regex</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iregex"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iregex</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">startswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">istartswith</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lt"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">lt</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lte"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">lte</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gt"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">gt</span></code></a>、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gte"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">gte</span></code></a> 以及 <a class="reference internal" href="#containment-and-key-lookups"><span class="std std-ref">包含与键查找</span></a> 。</p>
</div>
<div class="section" id="s-kt-expressions">
<span id="kt-expressions"></span><h4><code class="docutils literal notranslate"><span class="pre">KT()</span></code> 表达式<a class="headerlink" href="#kt-expressions" title="永久链接至标题">¶</a></h4>
<div class="versionadded">
<span class="title">New in Django 4.2.</span> </div>
<span class="target" id="module-django.db.models.fields.json"></span><dl class="py class">
<dt class="sig sig-object py" id="django.db.models.fields.json.KT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">KT</span></code>(<em><span class="n"><span class="pre">lookup</span></span></em>)<a class="headerlink" href="#django.db.models.fields.json.KT" title="永久链接至目标">¶</a></dt>
<dd><p>表示 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a> 的键、索引或路径变换的文本值。您可以在 <code class="docutils literal notranslate"><span class="pre">lookup</span></code> 中使用双下划线符号来链接字典键和索引变换。</p>
<p>例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.fields.json</span> <span class="kn">import</span> <span class="n">KT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shep&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;lhasa apso&quot;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Dog: Shep&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dogs</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">first_breed</span><span class="o">=</span><span class="n">KT</span><span class="p">(</span><span class="s2">&quot;data__breed__1&quot;</span><span class="p">),</span> <span class="n">owner_name</span><span class="o">=</span><span class="n">KT</span><span class="p">(</span><span class="s2">&quot;data__owner__name&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">first_breed__startswith</span><span class="o">=</span><span class="s2">&quot;lhasa&quot;</span><span class="p">,</span> <span class="n">owner_name</span><span class="o">=</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">由于键-路径查询的工作方式，<code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code> 不能保证产生详尽的集合。如果你想包含没有路径的对象，请添加 <code class="docutils literal notranslate"><span class="pre">isnull</span></code> 查找。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">由于任何字符串都可以成为 JSON 对象中的一个键，除了下面列出的那些之外，任何查询都将被解释为一个键查询。不会出现错误。要格外小心打字错误，并经常检查你的查询是否按你的意图进行。</p>
</div>
<div class="admonition-mariadb-and-oracle-users admonition">
<p class="first admonition-title">MariaDB 和 Oracle 用户</p>
<p class="last">在键、索引或路径转换上使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code> 将使用值的字符串表示法对对象进行排序。这是因为 MariaDB 和 Oracle 数据库没有提供将 JSON 值转换为其等价的 SQL 值的函数。</p>
</div>
<div class="admonition-oracle-users admonition">
<p class="first admonition-title">Oracle 用户</p>
<p class="last">在 Oracle 数据库中，在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code> 查询中使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为查询值，将返回没有 <code class="docutils literal notranslate"><span class="pre">null</span></code> 作为指定路径的对象，包括没有路径的对象。在其他数据库后端，该查询将返回具有该路径且其值不是 <code class="docutils literal notranslate"><span class="pre">null</span></code> 的对象。</p>
</div>
<div class="admonition-postgresql-users admonition">
<p class="first admonition-title">PostgreSQL 用户</p>
<p class="last">在 PostgreSQL 上，如果只使用一个键或索引，那么会使用 SQL 运算符 <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> 。如果使用多个操作符，则会使用 <code class="docutils literal notranslate"><span class="pre">#&gt;</span></code> 运算符。</p>
</div>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">SQLite 用户</p>
<p class="last">在SQLite上，字符串值 <code class="docutils literal notranslate"><span class="pre">&quot;true&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;false&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;null&quot;</span></code> 将始终被解释为分别为 <code class="docutils literal notranslate"><span class="pre">True</span></code>、<code class="docutils literal notranslate"><span class="pre">False</span></code> 和 JSON <code class="docutils literal notranslate"><span class="pre">null</span></code>。</p>
</div>
</div>
</div>
<div class="section" id="s-containment-and-key-lookups">
<span id="s-id10"></span><span id="containment-and-key-lookups"></span><span id="id10"></span><h3>包含与键查找<a class="headerlink" href="#containment-and-key-lookups" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-contains">
<span id="s-std-fieldlookup-jsonfield.contains"></span><span id="s-std:fieldlookup-jsonfield.contains"></span><span id="contains"></span><span id="std-fieldlookup-jsonfield.contains"></span><span id="std:fieldlookup-jsonfield.contains"></span><h4><code class="docutils literal notranslate"><span class="pre">contains</span></code><a class="headerlink" href="#contains" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> 查询在 <code class="docutils literal notranslate"><span class="pre">JSONField</span></code> 上被覆盖。返回的对象是那些包含给定键值对的顶层字段的对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{})</span>
<span class="go">&lt;Dog: Fred&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contains</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contains</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition-oracle-and-sqlite admonition">
<p class="first admonition-title">Oracle 和 SQLite</p>
<p class="last">Oracle 和 SQLite 不支持 <code class="docutils literal notranslate"><span class="pre">contains</span></code> 。</p>
</div>
</div>
<div class="section" id="s-contained-by">
<span id="s-std-fieldlookup-jsonfield.contained_by"></span><span id="s-std:fieldlookup-jsonfield.contained_by"></span><span id="contained-by"></span><span id="std-fieldlookup-jsonfield.contained_by"></span><span id="std:fieldlookup-jsonfield.contained_by"></span><h4><code class="docutils literal notranslate"><span class="pre">contained_by</span></code><a class="headerlink" href="#contained-by" title="永久链接至标题">¶</a></h4>
<p>这是 <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> 查询的反向 - 返回的对象将是那些对象，其上的键值对是传递值中的子集。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{})</span>
<span class="go">&lt;Dog: Fred&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contained_by</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;, &lt;Dog: Fred&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contained_by</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Fred&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition-oracle-and-sqlite admonition">
<p class="first admonition-title">Oracle 和 SQLite</p>
<p class="last">Oracle 和 SQLite 不支持 <code class="docutils literal notranslate"><span class="pre">contained_by</span></code> 。</p>
</div>
</div>
<div class="section" id="s-has-key">
<span id="s-std-fieldlookup-jsonfield.has_key"></span><span id="s-std:fieldlookup-jsonfield.has_key"></span><span id="has-key"></span><span id="std-fieldlookup-jsonfield.has_key"></span><span id="std:fieldlookup-jsonfield.has_key"></span><h4><code class="docutils literal notranslate"><span class="pre">has_key</span></code><a class="headerlink" href="#has-key" title="永久链接至标题">¶</a></h4>
<p>返回具有给定键位于数据的顶层的对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_key</span><span class="o">=</span><span class="s2">&quot;owner&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-has-keys">
<span id="s-std-fieldlookup-jsonfield.has_any_keys"></span><span id="s-std:fieldlookup-jsonfield.has_any_keys"></span><span id="has-keys"></span><span id="std-fieldlookup-jsonfield.has_any_keys"></span><span id="std:fieldlookup-jsonfield.has_any_keys"></span><h4><code class="docutils literal notranslate"><span class="pre">has_keys</span></code><a class="headerlink" href="#has-keys" title="永久链接至标题">¶</a></h4>
<p>返回所有给定键位于数据的顶层的对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;breed&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">])</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-has-any-keys">
<span id="s-std-fieldlookup-jsonfield.has_keys"></span><span id="s-std:fieldlookup-jsonfield.has_keys"></span><span id="has-any-keys"></span><span id="std-fieldlookup-jsonfield.has_keys"></span><span id="std:fieldlookup-jsonfield.has_keys"></span><h4><code class="docutils literal notranslate"><span class="pre">has_any_keys</span></code><a class="headerlink" href="#has-any-keys" title="永久链接至标题">¶</a></h4>
<p>返回任何给定键位于数据的顶层的对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_any_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;owner&quot;</span><span class="p">,</span> <span class="s2">&quot;breed&quot;</span><span class="p">])</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-complex-lookups-with-q-objects">
<span id="s-complex-lookups-with-q"></span><span id="complex-lookups-with-q-objects"></span><span id="complex-lookups-with-q"></span><h2>通过 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象完成复杂查询<a class="headerlink" href="#complex-lookups-with-q-objects" title="永久链接至标题">¶</a></h2>
<p>在类似 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 中，查询使用的关键字参数是通过 &quot;AND&quot; 连接起来的。如果你要执行更复杂的查询（例如，由 <code class="docutils literal notranslate"><span class="pre">OR</span></code> 语句连接的查询），你可以使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">对象</span></code></a>。</p>
<p>一个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">对象</span></code></a> (<code class="docutils literal notranslate"><span class="pre">django.db.models.Q</span></code>) 用于压缩关键字参数集合。这些关键字参数由前文 &quot;Field lookups&quot; 指定。</p>
<p>例如，该 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象压缩了一个 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 查询:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Q</span>

<span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象可以使用 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>、<code class="docutils literal notranslate"><span class="pre">|</span></code> 和 <code class="docutils literal notranslate"><span class="pre">^</span></code> 运算符组合。当在两个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象上使用运算符时，它会产生一个新的 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象。</p>
<p>例如，该语句生成一个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象，表示两个 <code class="docutils literal notranslate"><span class="pre">&quot;question_startswith&quot;</span></code> 查询语句之间的 &quot;OR&quot; 关系:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>这等同于以下 SQL 的 WHERE 子句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">WHERE</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Who%&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;What%&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>、<code class="docutils literal notranslate"><span class="pre">|</span></code> 和 <code class="docutils literal notranslate"><span class="pre">^</span></code> 运算符组合任意复杂的语句，并使用括号进行分组。此外，可以使用 <code class="docutils literal notranslate"><span class="pre">~</span></code> 运算符对 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象进行取反，从而允许组合查询，既包括正常查询又包括取反（<code class="docutils literal notranslate"><span class="pre">NOT</span></code>）查询：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">Q</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>每个接受关键字参数的查询函数 (例如 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a>， <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>) 也同时接受一个或多个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象作为位置（未命名的）参数。若你为查询函数提供了多个 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象参数，这些参数会通过 &quot;AND&quot; 连接。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>...粗略地转为 SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">polls</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Who%&#39;</span><span class="w"></span>
<span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="p">(</span><span class="n">pub_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2005-05-02&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">pub_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2005-05-06&#39;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>查询函数能混合使用 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象和关键字参数。所有提供给查询函数的参数（即关键字参数或 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象）均通过 &quot;AND&quot; 连接。然而，若提供了 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象，那么它必须位于所有关键字参数之前。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>……会是一个有效的查询，等效于前文的例子；但是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># INVALID QUERY</span>
<span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>……却是无效的。</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p class="last">Django 单元测试中的 <a class="reference external" href="https://github.com/django/django/blob/main/tests/or_lookups/tests.py">OR 查询实例</a> 展示了 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 的用法。</p>
</div>
</div>
<div class="section" id="s-comparing-objects">
<span id="comparing-objects"></span><h2>比较对象<a class="headerlink" href="#comparing-objects" title="永久链接至标题">¶</a></h2>
<p>要比较两个模型实例，使用标准的 Python 比较操作符，两个等号： <code class="docutils literal notranslate"><span class="pre">==</span></code>。实际上，这比较了两个模型实例的主键值。</p>
<p>使用上面的 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 示例，下面的两个语句是等效的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span> <span class="o">==</span> <span class="n">other_entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other_entry</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>如果模型的主键不叫 <code class="docutils literal notranslate"><span class="pre">id</span></code>，也没有问题。比较操作将始终使用主键，无论它叫什么。例如，如果一个模型的主键字段叫 <code class="docutils literal notranslate"><span class="pre">name</span></code>，下面两个语句是等效的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span> <span class="o">==</span> <span class="n">other_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
<div class="section" id="s-deleting-objects">
<span id="s-topics-db-queries-delete"></span><span id="deleting-objects"></span><span id="topics-db-queries-delete"></span><h2>删除对象<a class="headerlink" href="#deleting-objects" title="永久链接至标题">¶</a></h2>
<p>删除方法方便地被命名为 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>。这个方法立即删除对象并返回被删除的对象数以及一个包含每种对象类型的删除数的字典。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(1, {&#39;blog.Entry&#39;: 1})</span>
</pre></div>
</div>
<p>你也能批量删除对象。所有 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 都有个 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> 方法，它会删除 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 中的所有成员。</p>
<p>例如，这将删除所有具有 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> 年份为 2005 的 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(5, {&#39;webapp.Entry&#39;: 5})</span>
</pre></div>
</div>
<p>请记住，只要有机会的话，这会通过纯 SQL 语句执行，所以就无需在过程中调用每个对象的删除方法了。若你为模型类提供了自定义的 <code class="docutils literal notranslate"><span class="pre">delete()</span></code> 方法，且希望确保调用了该方法，你需要 “手动” 删除该模型的实例（例如，如，遍历 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>，在每个对象上分别调用 <code class="docutils literal notranslate"><span class="pre">delete()</span></code> 方法），而不是使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 的批量删除方法 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>。</p>
<p>当 Django 删除某个对象时，默认会模仿 SQL 约束 <code class="docutils literal notranslate"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></code> 的行为——换而言之，某个对象被删除时，关联对象也会被删除。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># This will delete the Blog and all of its Entry objects.</span>
<span class="n">b</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>这种约束行为由 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 的 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">on_delete</span></code></a> 参数指定。</p>
<p>注意 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> 是唯一未在 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 上暴漏的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法。这是一种安全机制，避免你不小心调用了 <code class="docutils literal notranslate"><span class="pre">Entry.objects.delete()</span></code>，删除了 <em>所有的</em> 条目。若你 <em>确实</em> 想要删除所有对象，你必须显示请求完整结果集合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-copying-model-instances">
<span id="s-topics-db-queries-copy"></span><span id="copying-model-instances"></span><span id="topics-db-queries-copy"></span><h2>复制模型实例<a class="headerlink" href="#copying-model-instances" title="永久链接至标题">¶</a></h2>
<p>虽然没有内置的方法来复制模型实例，但可以轻松地创建新的实例，并复制所有字段的值。在最简单的情况下，您可以将 <code class="docutils literal notranslate"><span class="pre">pk</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 并将 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model._state" title="django.db.models.Model._state"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_state.adding</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。使用我们的博客示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;My blog&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Blogging is easy&quot;</span><span class="p">)</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># blog.pk == 1</span>

<span class="n">blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">blog</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># blog.pk == 2</span>
</pre></div>
</div>
<p>若你使用了集成，事情会更复杂。考虑下 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 的一个子类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThemeBlog</span><span class="p">(</span><span class="n">Blog</span><span class="p">):</span>
    <span class="n">theme</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>


<span class="n">django_blog</span> <span class="o">=</span> <span class="n">ThemeBlog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Django&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Django is easy&quot;</span><span class="p">,</span> <span class="n">theme</span><span class="o">=</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># django_blog.pk == 3</span>
</pre></div>
</div>
<p>由于继承的工作方式，您必须将 <code class="docutils literal notranslate"><span class="pre">pk</span></code> 和 <code class="docutils literal notranslate"><span class="pre">id</span></code> 都设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，并将 <code class="docutils literal notranslate"><span class="pre">_state.adding</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">django_blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># django_blog.pk == 4</span>
</pre></div>
</div>
<p>该方法不会拷贝不是模型数据表中的关联关系。例如， <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 有一个对 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 的 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 关联关系。在复制条目后，你必须为新条目设置多对多关联关系。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># some previous entry</span>
<span class="n">old_authors</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">entry</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">old_authors</span><span class="p">)</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code> 关联，你必须拷贝关联对象，并将其指定给新对象的关联字段，避免违反一对一唯一性约束。例如，指定前文复制的 <code class="docutils literal notranslate"><span class="pre">entry</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">detail</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">detail</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">detail</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">detail</span><span class="o">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span>
<span class="n">detail</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-updating-multiple-objects-at-once">
<span id="s-topics-db-queries-update"></span><span id="updating-multiple-objects-at-once"></span><span id="topics-db-queries-update"></span><h2>一次修改多个对象<a class="headerlink" href="#updating-multiple-objects-at-once" title="永久链接至标题">¶</a></h2>
<p>有时候，你想统一设置 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 中的所有对象的某个字段。你可以通过 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 达到目的。例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Update all the headlines with pub_date in 2007.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2007</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Everything is the same&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>您只能使用此方法设置非关联字段和 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 字段。要更新非关联字段，请将新值提供为常数。要更新 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 字段，请将新值设置为要指向的新模型实例。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Change every Entry so that it belongs to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">update()</span></code> 方法会立即应用，并返回查询匹配的行数（如果某些行已经具有新值，则可能不等于更新的行数）。对于要更新的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 唯一的限制是它只能访问一个数据库表：模型的主表。您可以基于相关字段进行过滤，但只能更新模型的主表中的列。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Update all the headlines belonging to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Everything is the same&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>要认识到 <code class="docutils literal notranslate"><span class="pre">update()</span></code> 方法是直接转为 SQL 语句的。这是一种用于直接更新的批量操作。它并不会调用模型的 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法，或发射 <code class="docutils literal notranslate"><span class="pre">pre_save</span></code> 或 <code class="docutils literal notranslate"><span class="pre">post_save</span></code> 信号（调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 会触发信号），或使用 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> 字段选项。若想保存 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 中的每项，并确保调用了每个实例的 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法，你并不需要任何特殊的函数来处理此问题。迭代它们，并调用它们的 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_queryset</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>对于调用 update 的情况，还可以使用 <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">表达式</span></code></a> 来根据模型中另一个字段的值来更新字段。这在根据当前值增加计数器时特别有用。例如，要增加博客中每篇文章的 pingback 计数：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">number_of_pingbacks</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>然而，与筛选和排除子句中的 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象不同，在更新中使用 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象时，不能引入连接，只能引用模型被更新的字段。如果尝试使用 <code class="docutils literal notranslate"><span class="pre">F()</span></code> 对象引入连接，将引发 <code class="docutils literal notranslate"><span class="pre">FieldError</span></code> 错误：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># This will raise a FieldError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;blog__name&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="s-related-objects">
<span id="s-topics-db-queries-related"></span><span id="related-objects"></span><span id="topics-db-queries-related"></span><h2>关联对象<a class="headerlink" href="#related-objects" title="永久链接至标题">¶</a></h2>
<p>当你在模型中定义了关联关系（如 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>， <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a>， 或 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a>），该模型的实例将会自动获取一套 API，能快捷地访问关联对象。</p>
<p>拿本文开始的模型做例子，一个 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象 <code class="docutils literal notranslate"><span class="pre">e</span></code> 通过 <code class="docutils literal notranslate"><span class="pre">blog</span></code> 属性获取其关联的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象： <code class="docutils literal notranslate"><span class="pre">e.blog</span></code>。</p>
<p>（在幕后，这个函数是由  Python <a class="reference external" href="https://docs.python.org/3/howto/descriptor.html" title="(在 Python v3.12)"><span class="xref std std-doc">descriptors</span></a> 实现的。这玩意一般不会麻烦你，但是我们为你指出了注意点。）</p>
<p>Django 也提供了从关联关系 <em>另一边</em> 访问的 API —— 从被关联模型到定义关联关系的模型的连接。例如，一个 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> 对象 <code class="docutils literal notranslate"><span class="pre">b</span></code> 能通过 <code class="docutils literal notranslate"><span class="pre">entry_set</span></code> 属性 <code class="docutils literal notranslate"><span class="pre">b.entry_set.all()</span></code> 访问包含所有关联 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 对象的列表。</p>
<p>本章节中的所有例子都是用了本页开头定义的 <code class="docutils literal notranslate"><span class="pre">Blog</span></code>， <code class="docutils literal notranslate"><span class="pre">Author</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 模型。</p>
<div class="section" id="s-one-to-many-relationships">
<span id="one-to-many-relationships"></span><h3>一对多关联<a class="headerlink" href="#one-to-many-relationships" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-forward">
<span id="forward"></span><h4>正向访问<a class="headerlink" href="#forward" title="永久链接至标题">¶</a></h4>
<p>若模型有个 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>，该模型的实例能通过其属性访问关联（外部的）对象。</p>
<p>例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c1"># Returns the related Blog object.</span>
</pre></div>
</div>
<p>你可以通过外键属性进行获取和设置。正如你可能期望的那样，对外键的更改直到调用 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 方法后才会保存到数据库。示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">some_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>如果一个 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 字段设置了 <code class="docutils literal notranslate"><span class="pre">null=True</span></code> （即允许 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值），你可以将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 赋值给它以删除关联。示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># &quot;UPDATE blog_entry SET blog_id = NULL ...;&quot;</span>
</pre></div>
</div>
<p>第一次访问与一对多关系的前向访问时，相关对象会被缓存。对同一对象实例上的外键的后续访问也会被缓存。示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Hits the database to retrieve the associated Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
<p>请注意，<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法会提前递归地预加载所有一对多关系的缓存。示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
</div>
<div class="section" id="s-following-relationships-backward">
<span id="s-backwards-related-objects"></span><span id="following-relationships-backward"></span><span id="backwards-related-objects"></span><h4>“反向” 关联<a class="headerlink" href="#following-relationships-backward" title="永久链接至标题">¶</a></h4>
<p>若模型有 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>，外键关联的模型实例将能访问 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>，后者会返回第一个模型的所有实例。默认情况下，该 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 名为 <code class="docutils literal notranslate"><span class="pre">FOO_set</span></code>， <code class="docutils literal notranslate"><span class="pre">FOO</span></code> 即源模型名的小写形式。 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code>，后者能以 “检索对象” 章节介绍的方式进行筛选和操作。</p>
<p>例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entry_set is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p>你可以通过在 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 定义中设置 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> 参数来覆盖 <code class="docutils literal notranslate"><span class="pre">FOO_set</span></code> 的名称。例如，如果将 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 模型更改为 <code class="docutils literal notranslate"><span class="pre">blog</span> <span class="pre">=</span> <span class="pre">ForeignKey(Blog,</span> <span class="pre">on_delete=models.CASCADE,</span> <span class="pre">related_name='entries')</span></code>，那么上面的示例代码将如下所示：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entries is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-using-a-custom-reverse-manager">
<span id="s-using-custom-reverse-manager"></span><span id="using-a-custom-reverse-manager"></span><span id="using-custom-reverse-manager"></span><h4>使用自定义反向管理器<a class="headerlink" href="#using-a-custom-reverse-manager" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager" title="django.db.models.fields.related.RelatedManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">RelatedManager</span></code></a> 反向关联的默认实现是该模型 <a class="reference internal" href="managers.html#manager-names"><span class="std std-ref">默认管理器</span></a> 一个实例。若你想为某个查询指定一个不同的管理器，可以使用如下语法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>  <span class="c1"># Default Manager</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="n">EntryManager</span><span class="p">()</span>  <span class="c1"># Custom Manager</span>


<span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>若 <code class="docutils literal notranslate"><span class="pre">EntryManager</span></code> 在其 <code class="docutils literal notranslate"><span class="pre">get_queryset()</span></code> 方法执行了默认过滤行为，改行为会应用到 <code class="docutils literal notranslate"><span class="pre">all()</span></code> 调用中。</p>
<p>指定一个自定义反向管理也允许你调用模型自定义方法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_published</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition-interaction-with-prefetching admonition">
<p class="first admonition-title">与预获取的互动</p>
<p>在使用反向关系调用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a> 时，将使用默认管理器。如果要使用自定义反向管理器预获取相关对象，请使用 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Prefetch" title="django.db.models.Prefetch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prefetch()</span></code></a>。例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Prefetch</span>

<span class="n">prefetch_manager</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s2">&quot;entry_set&quot;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch_manager</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-additional-methods-to-handle-related-objects">
<span id="additional-methods-to-handle-related-objects"></span><h4>管理关联对象的额外方法<a class="headerlink" href="#additional-methods-to-handle-related-objects" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 还有方法能处理关联对象集合。除了上面的 “检索对象” 中定义的 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> 方法以外，以下是每项的简要介绍，而完整的细节能在 <a class="reference internal" href="../../ref/models/relations.html"><span class="doc">关联对象参考</span></a> 中找到。</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">add(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></code></dt><dd>将特定的模型对象加入关联对象集合。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">create(**kwargs)</span></code></dt><dd>创建一个新对象，保存，并将其放入关联对象集合中。返回新创建的对象。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></code></dt><dd>从关联对象集合删除指定模型对象。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clear()</span></code></dt><dd>从关联对象集合删除所有对象。</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set(objs)</span></code></dt><dd>替换关联对象集合</dd>
</dl>
<p>要指定关联集合的成员，调用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 方法，并传入可迭代的对象实例集合。例如，若 <code class="docutils literal notranslate"><span class="pre">e1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">e2</span></code> 都是 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 实例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
</pre></div>
</div>
<p>如果存在 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法，则在将可迭代对象（在这种情况下是列表）中的所有对象添加到集合之前，将从 <code class="docutils literal notranslate"><span class="pre">entry_set</span></code> 中删除任何现有对象。如果 <em>没有</em> 可用的 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法，则将添加可迭代对象中的所有对象，而不会删除任何现有元素。</p>
<p>本节介绍的所有 “反向” 操作对数据库都是立刻生效的。每次的增加，创建和删除都是及时自动地保存至数据库。</p>
</div>
</div>
<div class="section" id="s-many-to-many-relationships">
<span id="s-m2m-reverse-relationships"></span><span id="many-to-many-relationships"></span><span id="m2m-reverse-relationships"></span><h3>多对多关联<a class="headerlink" href="#many-to-many-relationships" title="永久链接至标题">¶</a></h3>
<p>多对多关联的两端均自动获取访问另一端的 API。该 API 的工作方式类似上面的 “反向” 一对多关联。</p>
<p>不同点在为属性命名上：定义了 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 的模型使用字段名作为属性名，而 “反向” 模型使用源模型名的小写形式，加上 <code class="docutils literal notranslate"><span class="pre">'_set'</span></code> （就像反向一对多关联一样）。</p>
<p>一个更易理解的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Author objects for this Entry.</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s2">&quot;John&quot;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects for this Author.</span>
</pre></div>
</div>
<p>和 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 一样， <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 能指定 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.related_name" title="django.db.models.ManyToManyField.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a>。在上面的例子中，若 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 中的 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 已指定了 <code class="docutils literal notranslate"><span class="pre">related_name='entries'</span></code>，随后每个 <code class="docutils literal notranslate"><span class="pre">Author</span></code> 实例会拥有一个 <code class="docutils literal notranslate"><span class="pre">entries</span></code> 属性，而不是 <code class="docutils literal notranslate"><span class="pre">entry_set</span></code>。</p>
<p>另一个与一对多关联不同的地方是，除了模型实例以外，多对多关联中的 <code class="docutils literal notranslate"><span class="pre">add()</span></code>， <code class="docutils literal notranslate"><span class="pre">set()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 方法能接收主键值。例如，若 <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">e2</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> 的实例，以下两种 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 调用结果一致:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">e2</span><span class="o">.</span><span class="n">pk</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="s-one-to-one-relationships">
<span id="one-to-one-relationships"></span><h3>一对一关联<a class="headerlink" href="#one-to-one-relationships" title="永久链接至标题">¶</a></h3>
<p>一对一关联与多对一关联非常类似。若在模型中定义了 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a>，该模型的实例只需通过其属性就能访问关联对象。</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EntryDetail</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Entry</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">details</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>


<span class="n">ed</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ed</span><span class="o">.</span><span class="n">entry</span>  <span class="c1"># Returns the related Entry object.</span>
</pre></div>
</div>
<p>不同点在于 “反向” 查询。一对一关联所关联的对象也能访问 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 对象，但这个 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 仅代表一个对象，而不是对象的集合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span>  <span class="c1"># returns the related EntryDetail object</span>
</pre></div>
</div>
<p>若未为关联关系指定对象，Django 会抛出 <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> 异常。</p>
<p>实例能通过为正向关联指定关联对象一样的方式指定给反向关联:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="o">=</span> <span class="n">ed</span>
</pre></div>
</div>
</div>
<div class="section" id="s-how-are-the-backward-relationships-possible">
<span id="how-are-the-backward-relationships-possible"></span><h3>反向关联是如何实现的？<a class="headerlink" href="#how-are-the-backward-relationships-possible" title="永久链接至标题">¶</a></h3>
<p>其它对象关联映射实现要求你在两边都定义关联关系。而 Django 开发者坚信这违反了 DRY 原则（不要自我重复），故 Django 仅要求你在一端定义关联关系。</p>
<p>但这是如何实现的呢，给你一个模型类，模型类并不知道是否有其它模型类关联它，直到其它模型类被加载？</p>
<p>答案位于 <a class="reference internal" href="../../ref/applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-data docutils literal notranslate"><span class="pre">应用注册</span></code></a>。 Django 启动时，它会导入 <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 列出的每个应用，和每个应用中的 <code class="docutils literal notranslate"><span class="pre">model</span></code> 模块。无论何时创建了一个新模型类，Django 为每个关联模型添加反向关联。若被关联的模型未被导入，Django 会持续追踪这些关联，并在关联模型被导入时添加关联关系。</p>
<p>出于这个原因，包含你所使用的所有模型的应用必须列在 <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中。否则，反向关联可能不会正常工作。</p>
</div>
<div class="section" id="s-queries-over-related-objects">
<span id="queries-over-related-objects"></span><h3>查询关联对象<a class="headerlink" href="#queries-over-related-objects" title="永久链接至标题">¶</a></h3>
<p>涉及关联对象的查询与涉及普通字段的查询遵守同样的规则。未查询条件指定值时，你可以使用对象实例，或该实例的主键。</p>
<p>例如，若有个博客对象 <code class="docutils literal notranslate"><span class="pre">b</span></code>，其 <code class="docutils literal notranslate"><span class="pre">id=5</span></code>，以下三种查询是一样的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Query using object instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>  <span class="c1"># Query using id from instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Query using id directly</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-falling-back-to-raw-sql">
<span id="falling-back-to-raw-sql"></span><h2>回归原生 SQL<a class="headerlink" href="#falling-back-to-raw-sql" title="永久链接至标题">¶</a></h2>
<p>若你发现需要编写的 SQL 查询语句太过复杂，以至于 Django 的数据库映射无法处理，你可以回归手动编写 SQL。Django 针对编写原生 SQL 有几个选项；参考 <a class="reference internal" href="sql.html"><span class="doc">执行原生 SQL 查询</span></a>。</p>
<p>最后，Django 数据库层只是一种访问数据库的接口，理解这点非常重要。你也可以通过其它工具，编程语言或数据库框架访问数据库；Django 并没有对数据库数据库做啥独有的操作。</p>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">执行查询</a><ul>
<li><a class="reference internal" href="#creating-objects">创建对象</a></li>
<li><a class="reference internal" href="#saving-changes-to-objects">将修改保存至对象</a><ul>
<li><a class="reference internal" href="#saving-foreignkey-and-manytomanyfield-fields">保存 <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 字段</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-objects">检索对象</a><ul>
<li><a class="reference internal" href="#retrieving-all-objects">检索全部对象</a></li>
<li><a class="reference internal" href="#retrieving-specific-objects-with-filters">通过过滤器检索指定对象</a><ul>
<li><a class="reference internal" href="#chaining-filters">链式过滤器</a></li>
<li><a class="reference internal" href="#filtered-querysets-are-unique">每个 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 都是唯一的</a></li>
<li><a class="reference internal" href="#querysets-are-lazy"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 是惰性的</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-a-single-object-with-get">用 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 检索单个对象</a></li>
<li><a class="reference internal" href="#other-queryset-methods">其它 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法</a></li>
<li><a class="reference internal" href="#limiting-querysets">限制 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 条目数</a></li>
<li><a class="reference internal" href="#field-lookups">字段查询</a></li>
<li><a class="reference internal" href="#lookups-that-span-relationships">跨关系查询</a><ul>
<li><a class="reference internal" href="#spanning-multi-valued-relationships">跨多值关联</a></li>
</ul>
</li>
<li><a class="reference internal" href="#filters-can-reference-fields-on-the-model">过滤器可以为模型指定字段</a></li>
<li><a class="reference internal" href="#expressions-can-reference-transforms">表达式可以引用变换</a></li>
<li><a class="reference internal" href="#the-pk-lookup-shortcut">主键 (<code class="docutils literal notranslate"><span class="pre">pk</span></code>) 查询快捷方式</a></li>
<li><a class="reference internal" href="#escaping-percent-signs-and-underscores-in-like-statements">在 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 语句中转义百分号和下划线</a></li>
<li><a class="reference internal" href="#caching-and-querysets">缓存和 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#when-querysets-are-not-cached">当 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 未被缓存时</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-queries">异步查询</a><ul>
<li><a class="reference internal" href="#query-iteration">查询迭代</a></li>
<li><a class="reference internal" href="#queryset-and-manager-methods"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 和管理器方法</a></li>
<li><a class="reference internal" href="#transactions">事务</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-jsonfield">查询 <code class="docutils literal notranslate"><span class="pre">JSONField</span></code></a><ul>
<li><a class="reference internal" href="#storing-and-querying-for-none">保存和查询 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值</a></li>
<li><a class="reference internal" href="#key-index-and-path-transforms">键、索引和路径转换</a><ul>
<li><a class="reference internal" href="#kt-expressions"><code class="docutils literal notranslate"><span class="pre">KT()</span></code> 表达式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#containment-and-key-lookups">包含与键查找</a><ul>
<li><a class="reference internal" href="#contains"><code class="docutils literal notranslate"><span class="pre">contains</span></code></a></li>
<li><a class="reference internal" href="#contained-by"><code class="docutils literal notranslate"><span class="pre">contained_by</span></code></a></li>
<li><a class="reference internal" href="#has-key"><code class="docutils literal notranslate"><span class="pre">has_key</span></code></a></li>
<li><a class="reference internal" href="#has-keys"><code class="docutils literal notranslate"><span class="pre">has_keys</span></code></a></li>
<li><a class="reference internal" href="#has-any-keys"><code class="docutils literal notranslate"><span class="pre">has_any_keys</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#complex-lookups-with-q-objects">通过 <code class="docutils literal notranslate"><span class="pre">Q</span></code> 对象完成复杂查询</a></li>
<li><a class="reference internal" href="#comparing-objects">比较对象</a></li>
<li><a class="reference internal" href="#deleting-objects">删除对象</a></li>
<li><a class="reference internal" href="#copying-model-instances">复制模型实例</a></li>
<li><a class="reference internal" href="#updating-multiple-objects-at-once">一次修改多个对象</a></li>
<li><a class="reference internal" href="#related-objects">关联对象</a><ul>
<li><a class="reference internal" href="#one-to-many-relationships">一对多关联</a><ul>
<li><a class="reference internal" href="#forward">正向访问</a></li>
<li><a class="reference internal" href="#following-relationships-backward">“反向” 关联</a></li>
<li><a class="reference internal" href="#using-a-custom-reverse-manager">使用自定义反向管理器</a></li>
<li><a class="reference internal" href="#additional-methods-to-handle-related-objects">管理关联对象的额外方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#many-to-many-relationships">多对多关联</a></li>
<li><a class="reference internal" href="#one-to-one-relationships">一对一关联</a></li>
<li><a class="reference internal" href="#how-are-the-backward-relationships-possible">反向关联是如何实现的？</a></li>
<li><a class="reference internal" href="#queries-over-related-objects">查询关联对象</a></li>
</ul>
</li>
<li><a class="reference internal" href="#falling-back-to-raw-sql">回归原生 SQL</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="models.html"
                          title="上一章">模型</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="aggregation.html"
                          title="下一章">聚合</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/topics/db/queries.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">2月 21, 2024</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="models.html" title="模型">previous</a>
     |
    <a href="../index.html" title="使用 Django" accesskey="U">up</a>
   |
    <a href="aggregation.html" title="聚合">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>