
<!DOCTYPE html>

<html lang="zh_Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Django 1.7 版本发行说明 &#8212; Django 5.0.3.dev20240221071519 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Django 1.6.11 版本发行说明" href="1.6.11.html" />
    <link rel="prev" title="Django 1.7.1 版本发行说明" href="1.7.1.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django 5.0.3.dev20240221071519 文档</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="1.7.1.html" title="Django 1.7.1 版本发行说明">previous</a>
     |
    <a href="index.html" title="发行说明" accesskey="U">up</a>
   |
    <a href="1.6.11.html" title="Django 1.6.11 版本发行说明">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="releases-1.7">
            
  <div class="section" id="s-django-1-7-release-notes">
<span id="django-1-7-release-notes"></span><h1>Django 1.7 版本发行说明<a class="headerlink" href="#django-1-7-release-notes" title="永久链接至标题">¶</a></h1>
<p><em>2014 年 9 月 2 日</em></p>
<p>欢迎使用 Django 1.7 ！</p>
<p>这些发布说明涵盖了 <a class="reference internal" href="#whats-new-1-7"><span class="std std-ref">新功能</span></a>，以及在从 Django 1.6 或更旧版本升级时需要注意的一些 <a class="reference internal" href="#backwards-incompatible-1-7"><span class="std std-ref">不兼容的变更</span></a>。我们已经 <a class="reference internal" href="#deprecated-features-1-7"><span class="std std-ref">开始了一些功能的弃用过程</span></a>，并且一些功能已经完成了其弃用过程，已经 <a class="reference internal" href="#removed-features-1-7"><span class="std std-ref">被移除</span></a>。</p>
<div class="section" id="s-python-compatibility">
<span id="python-compatibility"></span><h2>Python 兼容性<a class="headerlink" href="#python-compatibility" title="永久链接至标题">¶</a></h2>
<p>Django 1.7 需要 Python 2.7、3.2、3.3 或 3.4。我们 <strong>强烈建议</strong> 并且只官方支持每个系列的最新版本。</p>
<p>Django 1.6 系列是最后一个支持 Python 2.6 的版本。 Django 1.7 是第一个支持 Python 3.4 的版本。</p>
<p>这个改变应该只影响少数 Django 用户，因为大多数操作系统供应商现在都将 Python 2.7 或更新版本作为默认版本发布。然而，如果您仍在使用 Python 2.6，那么您需要继续使用 Django 1.6，直到您可以升级您的 Python 版本。根据我们的支持政策，Django 1.6 将继续获得安全支持，直到 Django 1.8 发布为止。</p>
</div>
<div class="section" id="s-what-s-new-in-django-1-7">
<span id="s-whats-new-1-7"></span><span id="what-s-new-in-django-1-7"></span><span id="whats-new-1-7"></span><h2>Django 1.7 的新特性包括：<a class="headerlink" href="#what-s-new-in-django-1-7" title="永久链接至标题">¶</a></h2>
<div class="section" id="s-schema-migrations">
<span id="schema-migrations"></span><h3>模式迁移<a class="headerlink" href="#schema-migrations" title="永久链接至标题">¶</a></h3>
<p>Django 现在内置了对模式迁移的支持。它允许通过创建迁移文件来更新、修改和删除模型，这些迁移文件代表了模型的变更，可以在任何开发、暂存或生产数据库上运行。</p>
<p>迁移在 <a class="reference internal" href="../topics/migrations.html"><span class="doc">自己的文档中</span></a> 中有详细的介绍，但其中一些关键特性包括：</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">syncdb</span></code> 已经被弃用，被 <code class="docutils literal notranslate"><span class="pre">migrate</span></code> 取代。不用担心 - 对 <code class="docutils literal notranslate"><span class="pre">syncdb</span></code> 的调用仍然会像以前一样工作。</p>
</li>
<li><p class="first">新的 <code class="docutils literal notranslate"><span class="pre">makemigrations</span></code> 命令提供了一种自动检测模型更改并为其创建迁移的简便方法。</p>
<p><code class="docutils literal notranslate"><span class="pre">django.db.models.signals.pre_syncdb</span></code> 和 <code class="docutils literal notranslate"><span class="pre">django.db.models.signals.post_syncdb</span></code> 已经被弃用，分别由 <a class="reference internal" href="../ref/signals.html#django.db.models.signals.pre_migrate" title="django.db.models.signals.pre_migrate"><code class="xref py py-data docutils literal notranslate"><span class="pre">pre_migrate</span></code></a> 和 <a class="reference internal" href="../ref/signals.html#django.db.models.signals.post_migrate" title="django.db.models.signals.post_migrate"><code class="xref py py-data docutils literal notranslate"><span class="pre">post_migrate</span></code></a> 取代。这些新信号具有稍微不同的参数。请查阅文档以获取详细信息。</p>
</li>
<li><p class="first">数据库路由器上的 <code class="docutils literal notranslate"><span class="pre">allow_syncdb</span></code> 方法现在被称为 <code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code>，但仍然执行相同的功能。具有 <code class="docutils literal notranslate"><span class="pre">allow_syncdb</span></code> 方法的路由器仍然可以工作，但该方法名称已被弃用，您应尽快更改它（只需要重命名即可）。</p>
</li>
<li><p class="first">不再为具有迁移的应用程序加载 <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> fixture；如果您想为应用程序加载初始数据，建议您为应用程序创建一个迁移，并在迁移的 <code class="docutils literal notranslate"><span class="pre">operations</span></code> 部分中定义一个 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> 或 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunSQL" title="django.db.migrations.operations.RunSQL"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunSQL</span></code></a> 操作。</p>
</li>
<li><p class="first">对于具有迁移的应用程序，测试回滚行为会有所不同；特别是，Django 不再在非事务性数据库上或 <code class="docutils literal notranslate"><span class="pre">TransactionTestCase</span></code> 内模拟回滚，除非明确请求（<a class="reference internal" href="../topics/testing/overview.html#test-case-serialized-rollback"><span class="std std-ref">除非明确请求</span></a>）。</p>
</li>
<li><p class="first">不建议没有迁移的应用程序依赖于（具有 <a class="reference internal" href="../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 或 <a class="reference internal" href="../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 的）具有迁移的应用程序。</p>
</li>
</ul>
</div>
<div class="section" id="s-app-loading-refactor">
<span id="s-app-loading-refactor-17-release-note"></span><span id="app-loading-refactor"></span><span id="app-loading-refactor-17-release-note"></span><h3>应用加载重构<a class="headerlink" href="#app-loading-refactor" title="永久链接至标题">¶</a></h3>
<p>在过去，Django 应用与模型紧密耦合。一个名为 &quot;应用缓存&quot; 的单例处理已安装的应用和模型。许多 API 中使用模型模块作为应用的标识符。</p>
<p>随着 <a class="reference internal" href="../ref/applications.html"><span class="doc">Django 应用程序</span></a> 概念的成熟，这段代码显示出了一些不足之处。它已经被重构为一个 &quot;应用程序注册表&quot;，在这里模型模块不再起到核心作用，同时可以将配置数据附加到应用程序。</p>
<p>迄今为止的改进包括：</p>
<ul class="simple">
<li>应用程序可以在启动时运行代码，在 Django 执行任何其他操作之前，使用其配置的 <a class="reference internal" href="../ref/applications.html#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> 方法。</li>
<li>即使在 <code class="docutils literal notranslate"><span class="pre">models.py</span></code> 之外定义模型，应用程序标签也会被正确地分配给模型。您不再需要显式设置 <a class="reference internal" href="../ref/models/options.html#django.db.models.Options.app_label" title="django.db.models.Options.app_label"><code class="xref py py-attr docutils literal notranslate"><span class="pre">app_label</span></code></a>。</li>
<li>如果一个应用程序没有任何模型，完全可以省略 <code class="docutils literal notranslate"><span class="pre">models.py</span></code>。</li>
<li>可以使用应用程序配置的 <a class="reference internal" href="../ref/applications.html#django.apps.AppConfig.label" title="django.apps.AppConfig.label"><code class="xref py py-attr docutils literal notranslate"><span class="pre">label</span></code></a> 属性重新标记应用程序，以解决标签冲突。</li>
<li>可以使用应用程序配置的 <a class="reference internal" href="../ref/applications.html#django.apps.AppConfig.verbose_name" title="django.apps.AppConfig.verbose_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name</span></code></a> 来自定义在管理员界面中的应用程序名称。</li>
<li>管理员界面在 Django 启动时会自动调用 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.autodiscover" title="django.contrib.admin.autodiscover"><code class="xref py py-func docutils literal notranslate"><span class="pre">autodiscover()</span></code></a>。因此，您可以从您的 URL 配置中删除这行代码。</li>
<li>Django 在启动时通过一种确定性且简单的过程导入所有应用程序配置和模型。这将使诊断导入问题（如导入循环）变得更容易。</li>
</ul>
</div>
<div class="section" id="s-new-method-on-field-subclasses">
<span id="new-method-on-field-subclasses"></span><h3>Field 子类的新方法<a class="headerlink" href="#new-method-on-field-subclasses" title="永久链接至标题">¶</a></h3>
<p>为了支持模式迁移并使未来版本的 Django 更容易添加复合键，<a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> API 现在有一个新的必需方法：<code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code>。</p>
<p>该方法不接受任何参数，并返回一个包含四个元素的元组：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>：字段在其父模型上的属性名称，如果它不是模型的一部分，则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</li>
<li><code class="docutils literal notranslate"><span class="pre">path</span></code>：字段类的点分隔的 Python 路径，包括类名。</li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>：作为列表的位置参数。</li>
<li><code class="docutils literal notranslate"><span class="pre">kwargs</span></code>：作为字典的关键字参数。</li>
</ul>
<p>这四个值允许将任何字段序列化到文件中，并且允许字段进行安全复制，这是这些新功能的重要组成部分。</p>
<p>这个变化不会影响您，除非您编写自定义的 Field 子类；如果您这样做，如果您的子类以任何方式更改了 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 的方法签名，您可能需要重新实现 <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> 方法。如果您的字段只是继承自内置的 Django 字段，并且没有重写 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>，则无需进行任何更改。</p>
<p>如果您确实需要重写 <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code>，一个好的起点是内置的 Django 字段（<code class="docutils literal notranslate"><span class="pre">django/db/models/fields/__init__.py</span></code>），因为其中一些字段，包括 <code class="docutils literal notranslate"><span class="pre">DecimalField</span></code> 和 <code class="docutils literal notranslate"><span class="pre">DateField</span></code>，已经重写了它，并展示了如何在超类上调用该方法，只需添加或删除额外的参数。</p>
<p>这也意味着字段的所有参数本身必须是可序列化的；要了解我们认为什么是可序列化的，以及如何使您自己的类可序列化，请阅读 <a class="reference internal" href="../topics/migrations.html#migration-serializing"><span class="std std-ref">迁移序列化文档</span></a>。</p>
</div>
<div class="section" id="s-calling-custom-queryset-methods-from-the-manager">
<span id="calling-custom-queryset-methods-from-the-manager"></span><h3>从 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 中调用自定义的 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法<a class="headerlink" href="#calling-custom-queryset-methods-from-the-manager" title="永久链接至标题">¶</a></h3>
<p>历史上，制作可重用的模型查询的推荐方法是在自定义 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 类上创建方法。这种方法的问题在于，在第一次方法调用之后，您会得到一个 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 实例，无法调用其他自定义的管理器方法。</p>
<p>尽管没有记录，但通常可以通过创建自定义的 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 来解决这个问题，以便可以链接自定义方法；但是这个解决方案有很多缺点：</p>
<ul class="simple">
<li>自定义的 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 和其自定义方法在第一次调用 <code class="docutils literal notranslate"><span class="pre">values()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">values_list()</span></code> 后就丢失了。</li>
<li>仍然需要编写自定义的 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 来返回自定义的 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 类，并且所有希望在 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 上使用的方法都必须被代理到 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 上。整个过程违反了 DRY 原则。</li>
</ul>
<p>现在可以直接使用 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.as_manager" title="django.db.models.query.QuerySet.as_manager"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuerySet.as_manager()</span></code></a> 类方法来 <a class="reference internal" href="../topics/db/managers.html#create-manager-with-queryset-methods"><span class="std std-ref">创建具有 QuerySet 方法的 Manager</span></a>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FoodQuerySet</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pizzas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;pizza&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">vegetarian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vegetarian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Food</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">vegetarian</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">BooleanField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">FoodQuerySet</span><span class="o">.</span><span class="n">as_manager</span><span class="p">()</span>


<span class="n">Food</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">pizzas</span><span class="p">()</span><span class="o">.</span><span class="n">vegetarian</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-using-a-custom-manager-when-traversing-reverse-relations">
<span id="using-a-custom-manager-when-traversing-reverse-relations"></span><h3>在遍历反向关系时使用自定义管理器<a class="headerlink" href="#using-a-custom-manager-when-traversing-reverse-relations" title="永久链接至标题">¶</a></h3>
<p>现在可以在遍历反向关系时 <a class="reference internal" href="../topics/db/queries.html#using-custom-reverse-manager"><span class="std std-ref">指定自定义的管理器</span></a>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">)</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>  <span class="c1"># Default Manager</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="n">EntryManager</span><span class="p">()</span>  <span class="c1"># Custom Manager</span>


<span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-new-system-check-framework">
<span id="new-system-check-framework"></span><h3>新的系统检查框架<a class="headerlink" href="#new-system-check-framework" title="永久链接至标题">¶</a></h3>
<p>我们新增了一个新的 <a class="reference internal" href="../ref/checks.html"><span class="doc">系统检查框架</span></a>，用于检测常见问题（比如无效的模型）并提供解决这些问题的提示。这个框架是可扩展的，因此您可以为自己的应用程序和库添加自定义检查。</p>
<p>要执行系统检查，您可以使用 <a class="reference internal" href="../ref/django-admin.html#django-admin-check"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">check</span></code></a> 管理命令。这个命令替代了旧的 <code class="docutils literal notranslate"><span class="pre">validate</span></code> 管理命令。</p>
</div>
<div class="section" id="s-new-prefetch-object-for-advanced-prefetch-related-operations">
<span id="new-prefetch-object-for-advanced-prefetch-related-operations"></span><h3>新的 <code class="docutils literal notranslate"><span class="pre">Prefetch</span></code> 对象用于高级的 <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code> 操作。<a class="headerlink" href="#new-prefetch-object-for-advanced-prefetch-related-operations" title="永久链接至标题">¶</a></h3>
<p>新的 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.Prefetch" title="django.db.models.Prefetch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prefetch</span></code></a> 对象允许自定义预取操作。</p>
<p>您可以指定用于遍历特定关系的 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>，或者自定义预取结果的存储位置。</p>
<p>这使得可以过滤预取的关系、从预取的关系中调用 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>，或者多次使用不同的查询集预取相同的关系。有关更多详细信息，请参阅 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a>。</p>
</div>
<div class="section" id="s-admin-shortcuts-support-time-zones">
<span id="admin-shortcuts-support-time-zones"></span><h3>管理快捷方式支持时区<a class="headerlink" href="#admin-shortcuts-support-time-zones" title="永久链接至标题">¶</a></h3>
<p>在管理员中日期和时间输入小部件旁边的 &quot;today&quot; 和 &quot;now&quot; 快捷方式现在在 <a class="reference internal" href="../topics/i18n/timezones.html#default-current-time-zone"><span class="std std-ref">当前时区</span></a> 中运行。以前，它们使用浏览器的时区，这可能导致在时区不匹配服务器的当前时区时保存错误的值。</p>
<p>此外，小部件现在在浏览器和服务器时区不同时显示帮助信息，以明确解释字段中插入的值将如何被解释。</p>
</div>
<div class="section" id="s-using-database-cursors-as-context-managers">
<span id="using-database-cursors-as-context-managers"></span><h3>使用数据库游标作为上下文管理器<a class="headerlink" href="#using-database-cursors-as-context-managers" title="永久链接至标题">¶</a></h3>
<p>在 Python 2.7 之前，数据库游标可以用作上下文管理器。具体的后端游标定义了上下文管理器的行为。但是，Python 2.7 改变了魔术方法查找的行为，游标不再能用作上下文管理器。</p>
<p>Django 1.7 允许将游标用作上下文管理器。也就是说，可以使用以下方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>替换成：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-custom-lookups">
<span id="custom-lookups"></span><h3>自定义查找<a class="headerlink" href="#custom-lookups" title="永久链接至标题">¶</a></h3>
<p>现在可以为 ORM 编写自定义查找和转换。自定义查找与 Django 内置的查找（例如 <code class="docutils literal notranslate"><span class="pre">lte</span></code>、<code class="docutils literal notranslate"><span class="pre">icontains</span></code>）类似，而转换是一个新概念。</p>
<p><a class="reference internal" href="../ref/models/lookups.html#django.db.models.Lookup" title="django.db.models.Lookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.Lookup</span></code></a> 类提供了一种为模型字段添加查找运算符的方式。例如，可以为 <code class="docutils literal notranslate"><span class="pre">DateFields</span></code> 添加 <code class="docutils literal notranslate"><span class="pre">day_lte</span></code> 运算符。</p>
<p><a class="reference internal" href="../ref/models/lookups.html#django.db.models.Transform" title="django.db.models.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.Transform</span></code></a> 类允许在最终查找之前对数据库值进行转换。例如，可以编写一个 <code class="docutils literal notranslate"><span class="pre">year</span></code> 转换，从字段的值中提取年份。转换允许进行链式操作。在将 <code class="docutils literal notranslate"><span class="pre">year</span></code> 转换添加到 <code class="docutils literal notranslate"><span class="pre">DateField</span></code> 后，可以对转换后的值进行筛选，例如 <code class="docutils literal notranslate"><span class="pre">qs.filter(author__birthdate__year__lte=1981)</span></code>。</p>
<p>有关自定义查找和转换的更多信息，请参阅 <a class="reference internal" href="../howto/custom-lookups.html"><span class="doc">自定义查找</span></a> 文档。</p>
</div>
<div class="section" id="s-improvements-to-form-error-handling">
<span id="improvements-to-form-error-handling"></span><h3>改进了 <code class="docutils literal notranslate"><span class="pre">Form</span></code> 错误处理<a class="headerlink" href="#improvements-to-form-error-handling" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-form-add-error">
<span id="form-add-error"></span><h4><code class="docutils literal notranslate"><span class="pre">Form.add_error()</span></code><a class="headerlink" href="#form-add-error" title="永久链接至标题">¶</a></h4>
<p>以前在处理表单错误方面有两种主要模式：</p>
<ul class="simple">
<li>在某些函数（例如 <code class="docutils literal notranslate"><span class="pre">Field.clean()</span></code>、<code class="docutils literal notranslate"><span class="pre">Form.clean_&lt;fieldname&gt;()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Form.clean()</span></code> 用于非字段错误的情况）中引发 <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValidationError</span></code></a>。</li>
<li>在 <code class="docutils literal notranslate"><span class="pre">Form.clean()</span></code> 中针对特定字段或在“clean”方法之外（例如直接从视图中）添加错误时，会涉及到 <code class="docutils literal notranslate"><span class="pre">Form._errors</span></code>。</li>
</ul>
<p>使用前一种模式是直接的，因为表单可以根据上下文（即引发异常的方法）猜测错误的归属，并自动处理它们。这仍然是可能时添加错误的规范方式。然而，后一种模式很繁琐且容易出错，因为处理边缘情况的负担落在用户身上。</p>
<p>新的 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.add_error" title="django.forms.Form.add_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_error()</span></code></a> 方法允许在任何地方将错误添加到特定的表单字段，无需担心诸如创建 <code class="docutils literal notranslate"><span class="pre">django.forms.utils.ErrorList</span></code> 实例或处理 <code class="docutils literal notranslate"><span class="pre">Form.cleaned_data</span></code> 等细节。这个新的 API 取代了操作 <code class="docutils literal notranslate"><span class="pre">Form._errors</span></code>，后者现在变成了一个私有的 API。</p>
<p>请参阅 <span class="xref std std-ref">使用 Form.add_error() 进行字段验证</span>，以获取使用 <code class="docutils literal notranslate"><span class="pre">Form.add_error()</span></code> 的示例。</p>
</div>
<div class="section" id="s-error-metadata">
<span id="error-metadata"></span><h4>错误元数据<a class="headerlink" href="#error-metadata" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValidationError</span></code></a> 构造函数接受元数据，如错误 <code class="docutils literal notranslate"><span class="pre">code</span></code> 或 <code class="docutils literal notranslate"><span class="pre">params</span></code>，然后可以将其插入到错误消息中（有关更多详细信息，请参阅 <a class="reference internal" href="../ref/forms/validation.html#raising-validation-error"><span class="std std-ref">引发 ValidationError</span></a>）；然而，在 Django 1.7 之前，这些元数据在错误添加到 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.errors" title="django.forms.Form.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Form.errors</span></code></a> 后立即被丢弃。</p>
<p><a class="reference internal" href="../ref/forms/api.html#django.forms.Form.errors" title="django.forms.Form.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Form.errors</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">django.forms.utils.ErrorList</span></code> 现在存储了 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 实例，因此可以通过新的 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.errors.as_data" title="django.forms.Form.errors.as_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Form.errors.as_data</span></code></a> 方法在任何时候检索这些元数据。</p>
<p>检索到的 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 实例可以通过其错误 <code class="docutils literal notranslate"><span class="pre">code</span></code> 进行标识，从而可以进行诸如重写错误消息或在特定错误存在时编写视图中的自定义逻辑等操作。它还可以用于以自定义格式（例如 XML）序列化错误。</p>
<p>新的 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Form.errors.as_json()</span></code></a> 方法是一个方便的方法，它返回以 JSON 格式序列化的错误消息以及错误代码。<code class="docutils literal notranslate"><span class="pre">as_json()</span></code> 使用了 <code class="docutils literal notranslate"><span class="pre">as_data()</span></code>，并展示了如何扩展新系统的思路。</p>
</div>
<div class="section" id="s-error-containers-and-backward-compatibility">
<span id="error-containers-and-backward-compatibility"></span><h4>错误容器和向后兼容性<a class="headerlink" href="#error-containers-and-backward-compatibility" title="永久链接至标题">¶</a></h4>
<p>为了支持上述功能，需要对各种错误容器进行重大更改，特别是 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.errors" title="django.forms.Form.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Form.errors</span></code></a>、<code class="docutils literal notranslate"><span class="pre">django.forms.utils.ErrorList</span></code> 和 <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValidationError</span></code></a> 的内部存储。这些容器曾经存储错误字符串，现在存储 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 实例，并且公共 API 已经进行了适应，使这些更改尽可能透明，但如果您曾经使用过私有 API，一些更改可能不兼容向后；有关更多详细信息，请参阅 <a class="reference internal" href="#validation-error-constructor-and-internal-storage"><span class="std std-ref">ValidationError 构造函数和内部存储</span></a>。</p>
</div>
</div>
<div class="section" id="s-minor-features">
<span id="minor-features"></span><h3>次要特性<a class="headerlink" href="#minor-features" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-django-contrib-admin">
<span id="django-contrib-admin"></span><h4><a class="reference internal" href="../ref/contrib/admin/index.html#module-django.contrib.admin" title="django.contrib.admin: Django's admin site."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.admin</span></code></a><a class="headerlink" href="#django-contrib-admin" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>现在可以在自定义的 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.AdminSite" title="django.contrib.admin.AdminSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdminSite</span></code></a> 上实现 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.AdminSite.site_header" title="django.contrib.admin.AdminSite.site_header"><code class="xref py py-attr docutils literal notranslate"><span class="pre">site_header</span></code></a>、<a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.AdminSite.site_title" title="django.contrib.admin.AdminSite.site_title"><code class="xref py py-attr docutils literal notranslate"><span class="pre">site_title</span></code></a> 和 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.AdminSite.index_title" title="django.contrib.admin.AdminSite.index_title"><code class="xref py py-attr docutils literal notranslate"><span class="pre">index_title</span></code></a> 属性，以便轻松更改管理站点的页面标题和页眉文本。不再需要覆盖模板！</li>
<li>在 <a class="reference internal" href="../ref/contrib/admin/index.html#module-django.contrib.admin" title="django.contrib.admin: Django's admin site."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.admin</span></code></a> 中的按钮现在使用 <code class="docutils literal notranslate"><span class="pre">border-radius</span></code> CSS 属性来实现圆角，而不再使用 GIF 背景图像。</li>
<li>一些管理模板现在在其 <code class="docutils literal notranslate"><span class="pre">&lt;body&gt;</span></code> 标签中具有 <code class="docutils literal notranslate"><span class="pre">app-&lt;app_name&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">model-&lt;model_name&gt;</span></code> 类，以允许按应用程序或模型自定义 CSS 样式。</li>
<li>管理员变更列表单元格现在在 HTML 中具有 <code class="docutils literal notranslate"><span class="pre">field-&lt;field_name&gt;</span></code> 类，以启用样式自定义。</li>
<li>现在可以通过新的 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.get_search_fields" title="django.contrib.admin.ModelAdmin.get_search_fields"><code class="xref py py-meth docutils literal notranslate"><span class="pre">django.contrib.admin.ModelAdmin.get_search_fields()</span></code></a> 方法，按请求自定义管理员的搜索字段。</li>
<li>可以重写 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.get_fields" title="django.contrib.admin.ModelAdmin.get_fields"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModelAdmin.get_fields()</span></code></a> 方法来自定义 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.fields" title="django.contrib.admin.ModelAdmin.fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelAdmin.fields</span></code></a> 的值。</li>
<li>除了现有的 <code class="docutils literal notranslate"><span class="pre">admin.site.register</span></code> 语法之外，您还可以使用新的 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.register" title="django.contrib.admin.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a> 装饰器来注册一个 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin" title="django.contrib.admin.ModelAdmin"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelAdmin</span></code></a>。</li>
<li>您可以指定 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.list_display_links" title="django.contrib.admin.ModelAdmin.list_display_links"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModelAdmin.list_display_links</span></code></a> <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">None</span></code> 来禁用更改列表页面网格上的链接。</li>
<li>现在可以指定 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.view_on_site" title="django.contrib.admin.ModelAdmin.view_on_site"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelAdmin.view_on_site</span></code></a> 来控制是否显示 &quot;在站点上查看&quot; 链接。</li>
<li>您可以通过在 <code class="docutils literal notranslate"><span class="pre">admin_order_field</span></code> 值前面加上连字符来指定 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.list_display" title="django.contrib.admin.ModelAdmin.list_display"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelAdmin.list_display</span></code></a> 值的降序排序。</li>
<li>可以重写 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.get_changeform_initial_data" title="django.contrib.admin.ModelAdmin.get_changeform_initial_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ModelAdmin.get_changeform_initial_data()</span></code></a> 方法来定义设置更改表单初始数据的自定义行为。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-auth">
<span id="django-contrib-auth"></span><h4><a class="reference internal" href="../topics/auth/index.html#module-django.contrib.auth" title="django.contrib.auth: Django's authentication framework."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.auth</span></code></a><a class="headerlink" href="#django-contrib-auth" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>传递给 <a class="reference internal" href="../ref/contrib/auth.html#django.contrib.auth.models.User.email_user" title="django.contrib.auth.models.User.email_user"><code class="xref py py-meth docutils literal notranslate"><span class="pre">email_user()</span></code></a> 的任何 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 都会传递给底层的 <a class="reference internal" href="../topics/email.html#django.core.mail.send_mail" title="django.core.mail.send_mail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_mail()</span></code></a> 调用。</li>
<li><a class="reference internal" href="../topics/auth/default.html#django.contrib.auth.decorators.permission_required" title="django.contrib.auth.decorators.permission_required"><code class="xref py py-func docutils literal notranslate"><span class="pre">permission_required()</span></code></a> 装饰器可以接受一组权限，而不仅仅是单个权限。</li>
<li>您可以重写新的 <a class="reference internal" href="../topics/auth/default.html#django.contrib.auth.forms.AuthenticationForm.confirm_login_allowed" title="django.contrib.auth.forms.AuthenticationForm.confirm_login_allowed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AuthenticationForm.confirm_login_allowed()</span></code></a> 方法，以更轻松地自定义登录策略。</li>
<li><code class="docutils literal notranslate"><span class="pre">django.contrib.auth.views.password_reset()</span></code> 接受一个可选的 <code class="docutils literal notranslate"><span class="pre">html_email_template_name</span></code> 参数，用于发送包含 HTML 的多部分电子邮件以进行密码重置。</li>
<li>添加了 <a class="reference internal" href="../topics/auth/customizing.html#django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash" title="django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AbstractBaseUser.get_session_auth_hash()</span></code></a> 方法，如果您的 <a class="reference internal" href="../ref/settings.html#std-setting-AUTH_USER_MODEL"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTH_USER_MODEL</span></code></a> 继承自 <a class="reference internal" href="../topics/auth/customizing.html#django.contrib.auth.models.AbstractBaseUser" title="django.contrib.auth.models.AbstractBaseUser"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractBaseUser</span></code></a>，那么现在在启用了 <code class="docutils literal notranslate"><span class="pre">django.contrib.auth.middleware.SessionAuthenticationMiddleware</span></code> 的情况下，更改用户密码会使旧的会话失效。有关更多详细信息，请参阅 <a class="reference internal" href="../topics/auth/default.html#session-invalidation-on-password-change"><span class="std std-ref">密码更改时的会话失效</span></a>。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-formtools">
<span id="django-contrib-formtools"></span><h4><code class="docutils literal notranslate"><span class="pre">django.contrib.formtools</span></code><a class="headerlink" href="#django-contrib-formtools" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>对 <code class="docutils literal notranslate"><span class="pre">WizardView.done()</span></code> 的调用现在包括一个 <code class="docutils literal notranslate"><span class="pre">form_dict</span></code>，以便更容易按步骤名称访问表单。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-gis">
<span id="django-contrib-gis"></span><h4><a class="reference internal" href="../ref/contrib/gis/index.html#module-django.contrib.gis" title="django.contrib.gis: Geographic Information System (GIS) extensions for Django"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.gis</span></code></a><a class="headerlink" href="#django-contrib-gis" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>默认包含在小部件中的 OpenLayers 库版本已从 2.11 更新为 2.13 。</li>
<li>如果安装了 GEOS 3.3 或更高版本，预处理的几何图形现在还支持 <code class="docutils literal notranslate"><span class="pre">crosses</span></code>、<code class="docutils literal notranslate"><span class="pre">disjoint</span></code>、<code class="docutils literal notranslate"><span class="pre">overlaps</span></code>、<code class="docutils literal notranslate"><span class="pre">touches</span></code> 和 <code class="docutils literal notranslate"><span class="pre">within</span></code> 谓词。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-messages">
<span id="django-contrib-messages"></span><h4><a class="reference internal" href="../ref/contrib/messages.html#module-django.contrib.messages" title="django.contrib.messages: Provides cookie- and session-based temporary message storage."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.messages</span></code></a><a class="headerlink" href="#django-contrib-messages" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>使用 Cookie 的 <a class="reference internal" href="../ref/contrib/messages.html#module-django.contrib.messages" title="django.contrib.messages: Provides cookie- and session-based temporary message storage."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.messages</span></code></a> 后端现在将遵循 <a class="reference internal" href="../ref/settings.html#std-setting-SESSION_COOKIE_SECURE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">SESSION_COOKIE_SECURE</span></code></a> 和 <a class="reference internal" href="../ref/settings.html#std-setting-SESSION_COOKIE_HTTPONLY"><code class="xref std std-setting docutils literal notranslate"><span class="pre">SESSION_COOKIE_HTTPONLY</span></code></a> 设置。</li>
<li><a class="reference internal" href="../ref/contrib/messages.html#message-displaying"><span class="std std-ref">消息上下文处理器</span></a> 现在会添加一个名为 <code class="docutils literal notranslate"><span class="pre">DEFAULT_MESSAGE_LEVELS</span></code> 的默认级别字典。</li>
<li>现在 <a class="reference internal" href="../ref/contrib/messages.html#django.contrib.messages.Message" title="django.contrib.messages.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象具有一个 <code class="docutils literal notranslate"><span class="pre">level_tag</span></code> 属性，其中包含消息级别的字符串表示。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-redirects">
<span id="django-contrib-redirects"></span><h4><a class="reference internal" href="../ref/contrib/redirects.html#module-django.contrib.redirects" title="django.contrib.redirects: A framework for managing redirects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.redirects</span></code></a><a class="headerlink" href="#django-contrib-redirects" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/contrib/redirects.html#django.contrib.redirects.middleware.RedirectFallbackMiddleware" title="django.contrib.redirects.middleware.RedirectFallbackMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">RedirectFallbackMiddleware</span></code></a> 具有两个新属性 (<a class="reference internal" href="../ref/contrib/redirects.html#django.contrib.redirects.middleware.RedirectFallbackMiddleware.response_gone_class" title="django.contrib.redirects.middleware.RedirectFallbackMiddleware.response_gone_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">response_gone_class</span></code></a> 和 <a class="reference internal" href="../ref/contrib/redirects.html#django.contrib.redirects.middleware.RedirectFallbackMiddleware.response_redirect_class" title="django.contrib.redirects.middleware.RedirectFallbackMiddleware.response_redirect_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">response_redirect_class</span></code></a>)，用于指定中间件返回的 <a class="reference internal" href="../ref/request-response.html#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例的类型。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-sessions">
<span id="django-contrib-sessions"></span><h4><a class="reference internal" href="../topics/http/sessions.html#module-django.contrib.sessions" title="django.contrib.sessions: Provides session management for Django projects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.sessions</span></code></a><a class="headerlink" href="#django-contrib-sessions" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;django.contrib.sessions.backends.cached_db&quot;</span></code> 会话后端现在尊重 <a class="reference internal" href="../ref/settings.html#std-setting-SESSION_CACHE_ALIAS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">SESSION_CACHE_ALIAS</span></code></a>。在之前的版本中，它总是使用 <code class="docutils literal notranslate"><span class="pre">default</span></code> 缓存。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-sitemaps">
<span id="django-contrib-sitemaps"></span><h4><a class="reference internal" href="../ref/contrib/sitemaps.html#module-django.contrib.sitemaps" title="django.contrib.sitemaps: A framework for generating Google sitemap XML files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.sitemaps</span></code></a><a class="headerlink" href="#django-contrib-sitemaps" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/contrib/sitemaps.html#module-django.contrib.sitemaps" title="django.contrib.sitemaps: A framework for generating Google sitemap XML files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sitemap</span> <span class="pre">framework</span></code></a> 现在使用 <a class="reference internal" href="../ref/contrib/sitemaps.html#django.contrib.sitemaps.Sitemap.lastmod" title="django.contrib.sitemaps.Sitemap.lastmod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lastmod</span></code></a> 来设置响应中的 <code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code> 标头。这使得 <a class="reference internal" href="../ref/middleware.html#django.middleware.http.ConditionalGetMiddleware" title="django.middleware.http.ConditionalGetMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConditionalGetMiddleware</span></code></a> 可以处理对设置了 <code class="docutils literal notranslate"><span class="pre">lastmod</span></code> 的站点地图的条件 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 请求。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-sites">
<span id="django-contrib-sites"></span><h4><a class="reference internal" href="../ref/contrib/sites.html#module-django.contrib.sites" title="django.contrib.sites: Lets you operate multiple websites from the same database and Django project"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.sites</span></code></a><a class="headerlink" href="#django-contrib-sites" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>新的 <a class="reference internal" href="../ref/middleware.html#django.contrib.sites.middleware.CurrentSiteMiddleware" title="django.contrib.sites.middleware.CurrentSiteMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.contrib.sites.middleware.CurrentSiteMiddleware</span></code></a> 允许在每个请求上设置当前站点。</li>
</ul>
</div>
<div class="section" id="s-django-contrib-staticfiles">
<span id="django-contrib-staticfiles"></span><h4><a class="reference internal" href="../ref/contrib/staticfiles.html#module-django.contrib.staticfiles" title="django.contrib.staticfiles: An app for handling static files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.staticfiles</span></code></a><a class="headerlink" href="#django-contrib-staticfiles" title="永久链接至标题">¶</a></h4>
<ul>
<li><p class="first">可以通过子类化 <a class="reference internal" href="../ref/contrib/staticfiles.html#staticfiles-storages"><span class="std std-ref">静态文件存储类</span></a> 来覆盖收集的静态文件和目录的权限，方法是设置 <a class="reference internal" href="../ref/files/storage.html#django.core.files.storage.FileSystemStorage.file_permissions_mode" title="django.core.files.storage.FileSystemStorage.file_permissions_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">file_permissions_mode</span></code></a> 和 <a class="reference internal" href="../ref/files/storage.html#django.core.files.storage.FileSystemStorage.directory_permissions_mode" title="django.core.files.storage.FileSystemStorage.directory_permissions_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">directory_permissions_mode</span></code></a> 参数。请参阅 <a class="reference internal" href="../ref/contrib/staticfiles.html#django-admin-collectstatic"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">collectstatic</span></code></a> 以查看示例用法。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">CachedStaticFilesStorage</span></code> 后端有一个名为 <a class="reference internal" href="../ref/contrib/staticfiles.html#django.contrib.staticfiles.storage.ManifestStaticFilesStorage" title="django.contrib.staticfiles.storage.ManifestStaticFilesStorage"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManifestStaticFilesStorage</span></code></a> 的兄弟类，它根本不使用缓存系统，而是使用一个名为 <code class="docutils literal notranslate"><span class="pre">staticfiles.json</span></code> 的 JSON 文件来存储原始文件名（例如 <code class="docutils literal notranslate"><span class="pre">css/styles.css</span></code>）和散列文件名（例如 <code class="docutils literal notranslate"><span class="pre">css/styles.55e7cbb9ba48.css</span></code>）之间的映射关系。当运行 <a class="reference internal" href="../ref/contrib/staticfiles.html#django-admin-collectstatic"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">collectstatic</span></code></a> 管理命令时，会创建 <code class="docutils literal notranslate"><span class="pre">staticfiles.json</span></code> 文件，对于 Amazon S3 等远程存储来说，这应该是一个更经济的替代方案。</p>
<p>有关更多信息，请参阅 <a class="reference internal" href="../ref/contrib/staticfiles.html#django.contrib.staticfiles.storage.ManifestStaticFilesStorage" title="django.contrib.staticfiles.storage.ManifestStaticFilesStorage"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManifestStaticFilesStorage</span></code></a> 文档。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/contrib/staticfiles.html#django-admin-findstatic"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">findstatic</span></code></a> 现在接受详细程度为 2 的 verbosity 标志，这意味着它将显示搜索的目录的相对路径。请参阅 <a class="reference internal" href="../ref/contrib/staticfiles.html#django-admin-findstatic"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">findstatic</span></code></a> 以查看示例输出。</p>
</li>
</ul>
</div>
<div class="section" id="s-django-contrib-syndication">
<span id="django-contrib-syndication"></span><h4><a class="reference internal" href="../ref/contrib/syndication.html#module-django.contrib.syndication" title="django.contrib.syndication: A framework for generating syndication feeds, in RSS and Atom, quite easily."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.syndication</span></code></a><a class="headerlink" href="#django-contrib-syndication" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/utils.html#django.utils.feedgenerator.Atom1Feed" title="django.utils.feedgenerator.Atom1Feed"><code class="xref py py-class docutils literal notranslate"><span class="pre">Atom1Feed</span></code></a> 辅助工具中的 <code class="docutils literal notranslate"><span class="pre">updated</span></code> 元素现在使用 <code class="docutils literal notranslate"><span class="pre">updateddate</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">pubdate</span></code>，允许在 feed 中包含 <code class="docutils literal notranslate"><span class="pre">published</span></code> 元素（该元素依赖于 <code class="docutils literal notranslate"><span class="pre">pubdate</span></code>）。</li>
</ul>
</div>
<div class="section" id="s-cache">
<span id="cache"></span><h4>缓存<a class="headerlink" href="#cache" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>现在可以通过 <a class="reference internal" href="../topics/cache.html#django.core.cache.caches" title="django.core.cache.caches"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.core.cache.caches</span></code></a> 访问在 <a class="reference internal" href="../ref/settings.html#std-setting-CACHES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CACHES</span></code></a> 中配置的缓存。这个类似字典的对象为每个线程提供一个不同的实例。它取代了已被弃用的 <code class="docutils literal notranslate"><span class="pre">django.core.cache.get_cache()</span></code>。</li>
<li>如果直接实例化缓存后端，请注意它们不再是线程安全的，因为 <a class="reference internal" href="../topics/cache.html#django.core.cache.caches" title="django.core.cache.caches"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.core.cache.caches</span></code></a> 现在为每个线程提供不同的实例。</li>
<li>将 <a class="reference internal" href="../ref/settings.html#std-setting-CACHES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CACHES</span></code></a> 设置的 <a class="reference internal" href="../ref/settings.html#std-setting-CACHES-TIMEOUT"><code class="xref std std-setting docutils literal notranslate"><span class="pre">TIMEOUT</span></code></a> 参数定义为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将默认将缓存键设置为 &quot;永不过期&quot;。以前，只能将 <code class="docutils literal notranslate"><span class="pre">timeout=None</span></code> 传递给缓存后端的 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 方法。</li>
</ul>
</div>
<div class="section" id="s-cross-site-request-forgery">
<span id="cross-site-request-forgery"></span><h4>跨站请求伪造（Cross Site Request Forgery，CSRF）<a class="headerlink" href="#cross-site-request-forgery" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/settings.html#std-setting-CSRF_COOKIE_AGE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CSRF_COOKIE_AGE</span></code></a> 设置方便了使用基于会话的 CSRF Cookie。</li>
</ul>
</div>
<div class="section" id="s-email">
<span id="email"></span><h4>电子邮件<a class="headerlink" href="#email" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../topics/email.html#django.core.mail.send_mail" title="django.core.mail.send_mail"><code class="xref py py-func docutils literal notranslate"><span class="pre">send_mail()</span></code></a> 现在接受一个 <code class="docutils literal notranslate"><span class="pre">html_message</span></code> 参数，用于发送多部分 <em class="mimetype">text/plain</em> 和 <em class="mimetype">text/html</em> 的电子邮件。</li>
<li>SMTP <a class="reference internal" href="../topics/email.html#django.core.mail.backends.smtp.EmailBackend" title="django.core.mail.backends.smtp.EmailBackend"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailBackend</span></code></a> 现在接受一个 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 参数。</li>
</ul>
</div>
<div class="section" id="s-file-storage">
<span id="file-storage"></span><h4>文件存储<a class="headerlink" href="#file-storage" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>在 Windows 上，文件锁定以前依赖于 PyWin32 软件包；如果未安装该软件包，则文件锁定会默默失败。现在已经移除了这个依赖项，文件锁定在 Windows 和 Unix 上都使用本地实现。</li>
</ul>
</div>
<div class="section" id="s-file-uploads">
<span id="file-uploads"></span><h4>文件上传<a class="headerlink" href="#file-uploads" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>新的 <a class="reference internal" href="../ref/files/uploads.html#django.core.files.uploadedfile.UploadedFile.content_type_extra" title="django.core.files.uploadedfile.UploadedFile.content_type_extra"><code class="xref py py-attr docutils literal notranslate"><span class="pre">UploadedFile.content_type_extra</span></code></a> 属性包含在文件上传的 <code class="docutils literal notranslate"><span class="pre">content-type</span></code> 标头中传递的额外参数。</li>
<li>新的 <a class="reference internal" href="../ref/settings.html#std-setting-FILE_UPLOAD_DIRECTORY_PERMISSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">FILE_UPLOAD_DIRECTORY_PERMISSIONS</span></code></a> 设置控制在文件上传期间创建的目录的文件系统权限，就像 <a class="reference internal" href="../ref/settings.html#std-setting-FILE_UPLOAD_PERMISSIONS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">FILE_UPLOAD_PERMISSIONS</span></code></a> 一样控制文件本身的权限。</li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.FileField.upload_to" title="django.db.models.FileField.upload_to"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileField.upload_to</span></code></a> 属性现在是可选的。如果省略或给定 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或空字符串，将不会使用子目录来存储上传的文件。</li>
<li>上传的文件现在在响应交付给客户端之前明确关闭。只要在上传处理程序中的名称为 <code class="docutils literal notranslate"><span class="pre">file</span></code>，部分上传的文件也会被关闭。</li>
<li><a class="reference internal" href="../ref/files/storage.html#django.core.files.storage.Storage.get_available_name" title="django.core.files.storage.Storage.get_available_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Storage.get_available_name()</span></code></a> 现在追加一个下划线加上一个随机的 7 个字符的字母数字字符串（例如，<code class="docutils literal notranslate"><span class="pre">&quot;_x3a1gho&quot;</span></code>），而不是通过一个下划线后跟一个数字（例如，<code class="docutils literal notranslate"><span class="pre">&quot;_1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;_2&quot;</span></code> 等）来进行迭代，以防止拒绝服务攻击。这个更改也在 1.6.6、1.5.9 和 1.4.14 安全发布版中进行了更改。</li>
</ul>
</div>
<div class="section" id="s-forms">
<span id="forms"></span><h4>表单<a class="headerlink" href="#forms" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/forms/widgets.html#django.forms.RadioSelect" title="django.forms.RadioSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">RadioSelect</span></code></a> 和 <a class="reference internal" href="../ref/forms/widgets.html#django.forms.CheckboxSelectMultiple" title="django.forms.CheckboxSelectMultiple"><code class="xref py py-class docutils literal notranslate"><span class="pre">CheckboxSelectMultiple</span></code></a> 渲染的单选按钮或复选框的 <code class="docutils literal notranslate"><span class="pre">&lt;label&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;input&gt;</span></code> 标签现在分别包括 <code class="docutils literal notranslate"><span class="pre">for</span></code> 和 <code class="docutils literal notranslate"><span class="pre">id</span></code> 属性。每个单选按钮或复选框都包括一个 <code class="docutils literal notranslate"><span class="pre">id_for_label</span></code> 属性以输出元素的 ID。</li>
<li><a class="reference internal" href="../ref/forms/widgets.html#django.forms.Textarea" title="django.forms.Textarea"><code class="xref py py-class docutils literal notranslate"><span class="pre">Textarea</span></code></a> 渲染的 <code class="docutils literal notranslate"><span class="pre">&lt;textarea&gt;</span></code> 标签现在如果 <a class="reference internal" href="../ref/models/fields.html#django.db.models.TextField" title="django.db.models.TextField"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextField</span></code></a> 模型字段有 <code class="docutils literal notranslate"><span class="pre">max_length</span></code>，则会包括一个 <code class="docutils literal notranslate"><span class="pre">maxlength</span></code> 属性。</li>
<li><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.choices" title="django.db.models.Field.choices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Field.choices</span></code></a> 现在允许您通过包含一个空字符串或 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的元组作为键以及自定义标签作为值来自定义 &quot;空选项&quot; 标签。在这种情况下，默认的空选项 <code class="docutils literal notranslate"><span class="pre">&quot;----------&quot;</span></code> 将被省略。</li>
<li><a class="reference internal" href="../ref/forms/fields.html#django.forms.MultiValueField" title="django.forms.MultiValueField"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiValueField</span></code></a> 允许通过将 <code class="docutils literal notranslate"><span class="pre">require_all_fields</span></code> 参数设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 来添加可选子字段。将尊重每个单独字段的 <code class="docutils literal notranslate"><span class="pre">required</span></code> 属性，并且当任何必填字段为空时，将引发新的 <code class="docutils literal notranslate"><span class="pre">incomplete</span></code> 验证错误。</li>
<li>表单上的 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.clean" title="django.forms.Form.clean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clean()</span></code></a> 方法不再需要返回 <code class="docutils literal notranslate"><span class="pre">self.cleaned_data</span></code>。如果它返回一个已更改的字典，那么仍将使用该字典。</li>
<li>在 Django 1.6 中的一个临时回归之后，现在可以再次使 <a class="reference internal" href="../ref/forms/fields.html#django.forms.TypedChoiceField" title="django.forms.TypedChoiceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedChoiceField</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">coerce</span></code> 方法返回任意值。</li>
<li><a class="reference internal" href="../ref/forms/widgets.html#django.forms.SelectDateWidget.months" title="django.forms.SelectDateWidget.months"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SelectDateWidget.months</span></code></a> 可以用于自定义在选择小部件中显示的月份的措辞。</li>
<li>添加了 <code class="docutils literal notranslate"><span class="pre">min_num</span></code> 和 <code class="docutils literal notranslate"><span class="pre">validate_min</span></code> 参数到 <a class="reference internal" href="../ref/forms/formsets.html#django.forms.formsets.formset_factory" title="django.forms.formsets.formset_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">formset_factory()</span></code></a>，以允许验证提交的表单的最小数量。</li>
<li><code class="docutils literal notranslate"><span class="pre">Form</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code> 使用的元类已经重新设计，以支持更多的继承情况。以前的限制，阻止同时继承 <code class="docutils literal notranslate"><span class="pre">Form</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code> 已经被移除，只要 <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code> 在方法解析顺序 (MRO) 中首先出现。</li>
<li>现在可以通过将字段的名称设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 来在子类中从 <code class="docutils literal notranslate"><span class="pre">Form</span></code> 中删除字段。</li>
<li>现在可以自定义 <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">unique</span></code>、<code class="docutils literal notranslate"><span class="pre">unique_for_date</span></code> 和 <code class="docutils literal notranslate"><span class="pre">unique_together</span></code> 约束的错误消息。为了支持 <code class="docutils literal notranslate"><span class="pre">unique_together</span></code> 或任何其他 <code class="docutils literal notranslate"><span class="pre">NON_FIELD_ERROR</span></code>，<code class="docutils literal notranslate"><span class="pre">ModelForm</span></code> 现在会查找 <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code> 内部 <code class="docutils literal notranslate"><span class="pre">Meta</span></code> 类的 <code class="docutils literal notranslate"><span class="pre">error_messages</span></code> 字典中的 <code class="docutils literal notranslate"><span class="pre">NON_FIELD_ERROR</span></code> 键。有关更多详细信息，请参阅 <a class="reference internal" href="../topics/forms/modelforms.html#considerations-regarding-model-errormessages"><span class="std std-ref">关于模型的 error_messages 的考虑</span></a>。</li>
</ul>
</div>
<div class="section" id="s-internationalization">
<span id="internationalization"></span><h4>国际化<a class="headerlink" href="#internationalization" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/middleware.html#django.middleware.locale.LocaleMiddleware.response_redirect_class" title="django.middleware.locale.LocaleMiddleware.response_redirect_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">django.middleware.locale.LocaleMiddleware.response_redirect_class</span></code></a> 属性允许您自定义中间件发出的重定向。</li>
<li><a class="reference internal" href="../ref/middleware.html#django.middleware.locale.LocaleMiddleware" title="django.middleware.locale.LocaleMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocaleMiddleware</span></code></a> 现在将用户选择的语言存储在会话键 <code class="docutils literal notranslate"><span class="pre">_language</span></code> 中。这应该只使用 <code class="docutils literal notranslate"><span class="pre">LANGUAGE_SESSION_KEY</span></code> 常量来访问。以前它存储在键 <code class="docutils literal notranslate"><span class="pre">django_language</span></code> 中，而 <code class="docutils literal notranslate"><span class="pre">LANGUAGE_SESSION_KEY</span></code> 常量不存在，但为 Django 保留的键应该以下划线开头。为了向后兼容，在 1.7 中仍然从 <code class="docutils literal notranslate"><span class="pre">django_language</span></code> 读取。随着写入，会话将迁移到新的键。</li>
<li><a class="reference internal" href="../topics/i18n/translation.html#std-templatetag-blocktrans"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">blocktrans</span></code></a> 标签现在支持一个 <code class="docutils literal notranslate"><span class="pre">trimmed</span></code> 选项。此选项将从 <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">blocktrans</span> <span class="pre">%}</span></code> 标签的内容的开头和结尾删除换行符，替换每行开头和结尾的任何空白，并使用空格字符将所有行合并为一行，以分隔它们。这对于缩进 <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">blocktrans</span> <span class="pre">%}</span></code> 标签的内容非常有用，而不会使缩进字符出现在 <code class="docutils literal notranslate"><span class="pre">.po</span></code> 文件中相应的条目中，从而使翻译过程更加容易。</li>
<li>当你在项目的根目录运行 <a class="reference internal" href="../ref/django-admin.html#django-admin-makemessages"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemessages</span></code></a> 时，任何提取出来的字符串现在将自动分发到正确的应用程序或项目消息文件中。详细信息请参见 <a class="reference internal" href="../topics/i18n/translation.html#how-to-create-language-files"><span class="std std-ref">本地化：如何创建语言文件</span></a>。</li>
<li><a class="reference internal" href="../ref/django-admin.html#django-admin-makemessages"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemessages</span></code></a> 命令现在总是会将 <code class="docutils literal notranslate"><span class="pre">--previous</span></code> 命令行标志添加到 <code class="docutils literal notranslate"><span class="pre">msgmerge</span></code> 命令中，以保留先前翻译的模糊字符串在 <code class="docutils literal notranslate"><span class="pre">.po</span></code> 文件中。</li>
<li>引入了以下用于调整语言 cookie 选项的设置：<a class="reference internal" href="../ref/settings.html#std-setting-LANGUAGE_COOKIE_AGE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">LANGUAGE_COOKIE_AGE</span></code></a>、<a class="reference internal" href="../ref/settings.html#std-setting-LANGUAGE_COOKIE_DOMAIN"><code class="xref std std-setting docutils literal notranslate"><span class="pre">LANGUAGE_COOKIE_DOMAIN</span></code></a> 和 <a class="reference internal" href="../ref/settings.html#std-setting-LANGUAGE_COOKIE_PATH"><code class="xref std std-setting docutils literal notranslate"><span class="pre">LANGUAGE_COOKIE_PATH</span></code></a>。</li>
<li>添加了用于 Esperanto 的 <a class="reference internal" href="../topics/i18n/formatting.html"><span class="doc">本地格式化</span></a>。</li>
</ul>
</div>
<div class="section" id="s-management-commands">
<span id="management-commands"></span><h4>管理命令<a class="headerlink" href="#management-commands" title="永久链接至标题">¶</a></h4>
<ul>
<li><p class="first">新的 <a class="reference internal" href="../ref/django-admin.html#cmdoption-no-color"><code class="xref std std-option docutils literal notranslate"><span class="pre">--no-color</span></code></a> 选项用于 <code class="docutils literal notranslate"><span class="pre">django-admin</span></code>，用于禁用管理命令输出的颜色标记。</p>
</li>
<li><p class="first">新的 <a class="reference internal" href="../ref/django-admin.html#cmdoption-dumpdata-natural-foreign"><code class="xref std std-option docutils literal notranslate"><span class="pre">dumpdata</span> <span class="pre">--natural-foreign</span></code></a> 和 <a class="reference internal" href="../ref/django-admin.html#cmdoption-dumpdata-natural-primary"><code class="xref std std-option docutils literal notranslate"><span class="pre">dumpdata</span> <span class="pre">--natural-primary</span></code></a> 选项，以及 <code class="docutils literal notranslate"><span class="pre">serializers.serialize()</span></code> 的新参数 <code class="docutils literal notranslate"><span class="pre">use_natural_foreign_keys</span></code> 和 <code class="docutils literal notranslate"><span class="pre">use_natural_primary_keys</span></code> 允许在序列化时使用自然主键。</p>
</li>
<li><p class="first">不再需要为 <a class="reference internal" href="../ref/django-admin.html#django-admin-createcachetable"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">createcachetable</span></code></a> 命令提供缓存表名或 <code class="docutils literal notranslate"><span class="pre">--database</span></code> 选项。Django 会从你的设置文件中获取这些信息。如果你配置了多个缓存或多个数据库，所有缓存表都会被创建。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/django-admin.html#django-admin-runserver"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">runserver</span></code></a> 命令进行了一些改进：</p>
<ul class="simple">
<li>在 Linux 系统上，如果安装了 <a class="reference external" href="https://pypi.org/project/pyinotify/">pyinotify</a>，开发服务器将在文件更改时立即重新加载。以前，它每秒轮询文件系统以检测更改，这会导致重新加载前有一小段延迟，并降低笔记本电脑的电池寿命。</li>
<li>此外，当翻译文件更新后，即在运行 <a class="reference internal" href="../ref/django-admin.html#django-admin-compilemessages"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">compilemessages</span></code></a> 后，开发服务器会自动重新加载。</li>
<li>所有 HTTP 请求都会记录到控制台，包括以前被过滤掉的用于静态文件或 <code class="docutils literal notranslate"><span class="pre">favicon.ico</span></code> 的请求。</li>
</ul>
</li>
<li><p class="first">如果安装并激活了第三方工具 ANSICON，Windows 下的管理命令现在可以生成带有语法着色的输出。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/contrib/staticfiles.html#django-admin-collectstatic"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">collectstatic</span></code></a> 命令现在在 Windows NT 6 (Windows Vista 及更新版本) 上支持符号链接选项。</p>
</li>
<li><p class="first">如果安装了 <a class="reference external" href="https://pypi.org/project/sqlparse/">sqlparse</a> Python 库，初始 SQL 数据现在将更好地工作。</p>
<p>请注意，它已被弃用，推荐使用迁移的 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunSQL" title="django.db.migrations.operations.RunSQL"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunSQL</span></code></a> 操作，这样可以受益于改进后的行为。</p>
</li>
</ul>
</div>
<div class="section" id="s-models">
<span id="models"></span><h4>模型<a class="headerlink" href="#models" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>新增了 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.update_or_create" title="django.db.models.query.QuerySet.update_or_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuerySet.update_or_create()</span></code></a> 方法。</li>
<li>新的 <a class="reference internal" href="../ref/models/options.html#django.db.models.Options.default_permissions" title="django.db.models.Options.default_permissions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default_permissions</span></code></a> 模型 <code class="docutils literal notranslate"><span class="pre">Meta</span></code> 选项允许你自定义（或禁用）默认添加、修改和删除权限的创建。</li>
<li>现在在抽象类中可以显式使用 <a class="reference internal" href="../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> 用于 <a class="reference internal" href="../topics/db/models.html#multi-table-inheritance"><span class="std std-ref">多表继承</span></a>。</li>
<li>现在可以通过将 <a class="reference internal" href="../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> 的 <a class="reference internal" href="../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 或以 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 结尾来避免创建反向关系。</li>
<li><a class="reference internal" href="../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">表达式</span></code></a> 支持幂运算符（<code class="docutils literal notranslate"><span class="pre">**</span></code>）。</li>
<li>由 <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 和 <code class="docutils literal notranslate"><span class="pre">GenericForeignKey</span></code> 创建的关联管理器的 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法现在接受 <code class="docutils literal notranslate"><span class="pre">bulk</span></code> 关键字参数，用于控制是否批量执行操作（即使用 <code class="docutils literal notranslate"><span class="pre">QuerySet.update()</span></code>）。默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</li>
<li>现在可以将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 用作 <a class="reference internal" href="../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a> 查找的查询值。</li>
<li>现在在定义 <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 时，可以将可调用对象作为属性 <a class="reference internal" href="../ref/models/fields.html#django.db.models.ForeignKey.limit_choices_to" title="django.db.models.ForeignKey.limit_choices_to"><code class="xref py py-attr docutils literal notranslate"><span class="pre">limit_choices_to</span></code></a> 的值传递。</li>
<li>在 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuerySet.values()</span></code></a> 的结果上调用 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code class="xref py py-meth docutils literal notranslate"><span class="pre">only()</span></code></a> 和 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defer()</span></code></a> 现在会引发错误（之前会导致数据库错误或不正确的数据）。</li>
<li>在指定单一字段集合时，可以使用单一列表而不是列表的列表来设置 <a class="reference internal" href="../ref/models/options.html#django.db.models.Options.index_together" title="django.db.models.Options.index_together"><code class="xref py py-attr docutils literal notranslate"><span class="pre">index_together</span></code></a>。</li>
<li>现在允许自定义中间模型具有多个外键与参与多对多关系的任何模型相关联，前提是你通过设置新的 <a class="reference internal" href="../ref/models/fields.html#django.db.models.ManyToManyField.through_fields" title="django.db.models.ManyToManyField.through_fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ManyToManyField.through_fields</span></code></a> 参数来明确指定应该使用哪些外键。</li>
<li>现在，将模型实例分配给非关联字段将会抛出错误。之前，如果字段接受整数作为输入并将其作为主键，这样的操作是有效的。</li>
<li>整数字段现在会根据它们的 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_type</span></code></a> 验证数据库后端特定的最小值和最大值。以前，模型字段的验证不会阻止保存超出其关联列数据类型范围的值，从而导致完整性错误。</li>
<li>现在可以通过使用关联字段的属性名称来显式 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> 一个关系的 <code class="docutils literal notranslate"><span class="pre">_id</span></code> 字段。</li>
</ul>
</div>
<div class="section" id="s-signals">
<span id="signals"></span><h4>信号<a class="headerlink" href="#signals" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>在 <a class="reference internal" href="../ref/signals.html#django.test.signals.setting_changed" title="django.test.signals.setting_changed"><code class="xref py py-data docutils literal notranslate"><span class="pre">setting_changed</span></code></a> 信号中添加了 <code class="docutils literal notranslate"><span class="pre">enter</span></code> 参数。</li>
<li>现在可以使用 <code class="docutils literal notranslate"><span class="pre">'app_label.ModelName'</span></code> 形式的 <code class="docutils literal notranslate"><span class="pre">str</span></code> 来连接模型信号，就像相关字段一样，以惰性引用它们的发送者。</li>
</ul>
</div>
<div class="section" id="s-templates">
<span id="templates"></span><h4>模板<a class="headerlink" href="#templates" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/templates/api.html#django.template.Context.push" title="django.template.Context.push"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.push()</span></code></a> 方法现在返回一个上下文管理器，在退出 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句时会自动调用 <a class="reference internal" href="../ref/templates/api.html#django.template.Context.pop" title="django.template.Context.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a>。此外，<a class="reference internal" href="../ref/templates/api.html#django.template.Context.push" title="django.template.Context.push"><code class="xref py py-meth docutils literal notranslate"><span class="pre">push()</span></code></a> 现在接受参数，这些参数将传递给用于构建新上下文级别的 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 构造函数。</li>
<li>新的 <a class="reference internal" href="../ref/templates/api.html#django.template.Context.flatten" title="django.template.Context.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.flatten()</span></code></a> 方法将一个 <code class="docutils literal notranslate"><span class="pre">Context</span></code> 的堆栈返回为一个扁平的字典。</li>
<li><code class="docutils literal notranslate"><span class="pre">Context</span></code> 对象现在可以进行相等性比较（内部使用 <a class="reference internal" href="../ref/templates/api.html#django.template.Context.flatten" title="django.template.Context.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.flatten()</span></code></a> 进行比较，因此只要它们的扁平化版本相同，每个 <code class="docutils literal notranslate"><span class="pre">Context</span></code> 的堆栈的内部结构就不重要）。</li>
<li><a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-widthratio"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">widthratio</span></code></a> 模板标签现在接受一个 <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> 参数，以将结果存储在一个变量中。</li>
<li><a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-include"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">include</span></code></a> 模板标签现在还接受任何具有 <code class="docutils literal notranslate"><span class="pre">render()</span></code> 方法的对象（例如 <code class="docutils literal notranslate"><span class="pre">Template</span></code>）作为参数。字符串参数将如常使用 <a class="reference internal" href="../topics/templates.html#django.template.loader.get_template" title="django.template.loader.get_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_template()</span></code></a> 进行查找。</li>
<li>现在可以递归地使用 <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-include"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">include</span></code></a> 模板。</li>
<li>当 <code class="docutils literal notranslate"><span class="pre">TEMPLATE_DEBUG</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时，模板对象现在具有一个设置的 origin 属性。这允许在 <code class="docutils literal notranslate"><span class="pre">django.template</span></code> 基础结构之外检查和记录模板的来源。</li>
<li>在模板渲染过程中引发的 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> 异常不再被消除声音。</li>
<li>以下函数现在接受一个 <code class="docutils literal notranslate"><span class="pre">dirs</span></code> 参数，这是一个列表或元组，用于覆盖 <code class="docutils literal notranslate"><span class="pre">TEMPLATE_DIRS</span></code>：<ul>
<li><a class="reference internal" href="../topics/templates.html#django.template.loader.get_template" title="django.template.loader.get_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.template.loader.get_template()</span></code></a></li>
<li><a class="reference internal" href="../topics/templates.html#django.template.loader.select_template" title="django.template.loader.select_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.template.loader.select_template()</span></code></a></li>
<li><a class="reference internal" href="../topics/http/shortcuts.html#django.shortcuts.render" title="django.shortcuts.render"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.shortcuts.render()</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">django.shortcuts.render_to_response()</span></code></li>
</ul>
</li>
<li><a class="reference internal" href="../ref/templates/builtins.html#std-templatefilter-time"><code class="xref std std-tfilter docutils literal notranslate"><span class="pre">time</span></code></a> 过滤器现在接受与时区相关的 <a class="reference internal" href="../ref/templates/builtins.html#date-and-time-formatting-specifiers"><span class="std std-ref">格式说明符</span></a> <code class="docutils literal notranslate"><span class="pre">'e'</span></code>, <code class="docutils literal notranslate"><span class="pre">'O'</span></code>, <code class="docutils literal notranslate"><span class="pre">'T'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'Z'</span></code>，并且能够处理 <a class="reference internal" href="../topics/i18n/timezones.html#naive-vs-aware-datetimes"><span class="std std-ref">时区感知的</span></a> <code class="docutils literal notranslate"><span class="pre">datetime</span></code> 实例，执行预期的渲染。</li>
<li><a class="reference internal" href="../topics/cache.html#std-templatetag-cache"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">cache</span></code></a> 标签现在会尝试使用名为 &quot;template_fragments&quot; 的缓存（如果存在），否则会回退使用默认缓存。它还现在接受一个可选的 <code class="docutils literal notranslate"><span class="pre">using</span></code> 关键字参数，以控制使用哪个缓存。</li>
<li>新的 <a class="reference internal" href="../ref/templates/builtins.html#std-templatefilter-truncatechars_html"><code class="xref std std-tfilter docutils literal notranslate"><span class="pre">truncatechars_html</span></code></a> 过滤器根据指定的字符数截断字符串，考虑到 HTML。</li>
</ul>
</div>
<div class="section" id="s-requests-and-responses">
<span id="requests-and-responses"></span><h4>请求和响应<a class="headerlink" href="#requests-and-responses" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>新的 <a class="reference internal" href="../ref/request-response.html#django.http.HttpRequest.scheme" title="django.http.HttpRequest.scheme"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpRequest.scheme</span></code></a> 属性指定请求的协议（通常是 <code class="docutils literal notranslate"><span class="pre">http</span></code> 或 <code class="docutils literal notranslate"><span class="pre">https</span></code>）。</li>
<li>快捷方式 <a class="reference internal" href="../topics/http/shortcuts.html#django.shortcuts.redirect" title="django.shortcuts.redirect"><code class="xref py py-func docutils literal notranslate"><span class="pre">redirect()</span></code></a> 现在支持相对 URL。</li>
<li><a class="reference internal" href="../ref/request-response.html#django.http.JsonResponse" title="django.http.JsonResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">JsonResponse</span></code></a> 是 <a class="reference internal" href="../ref/request-response.html#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 的一个子类，它可以轻松创建 JSON 编码的响应。</li>
</ul>
</div>
<div class="section" id="s-tests">
<span id="tests"></span><h4>测试<a class="headerlink" href="#tests" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../topics/testing/advanced.html#django.test.runner.DiscoverRunner" title="django.test.runner.DiscoverRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscoverRunner</span></code></a> 新增了两个属性，<a class="reference internal" href="../topics/testing/advanced.html#django.test.runner.DiscoverRunner.test_suite" title="django.test.runner.DiscoverRunner.test_suite"><code class="xref py py-attr docutils literal notranslate"><span class="pre">test_suite</span></code></a> 和 <a class="reference internal" href="../topics/testing/advanced.html#django.test.runner.DiscoverRunner.test_runner" title="django.test.runner.DiscoverRunner.test_runner"><code class="xref py py-attr docutils literal notranslate"><span class="pre">test_runner</span></code></a>，它们有助于重写测试的收集和运行方式。</li>
<li><a class="reference internal" href="../topics/testing/tools.html#django.test.SimpleTestCase.assertRedirects" title="django.test.SimpleTestCase.assertRedirects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRedirects()</span></code></a> 添加了 <code class="docutils literal notranslate"><span class="pre">fetch_redirect_response</span></code> 参数。由于测试客户端无法获取外部 URL，这使您可以在不属于您的 Django 应用程序的重定向上使用 <code class="docutils literal notranslate"><span class="pre">assertRedirects</span></code>。</li>
<li>在 <a class="reference internal" href="../topics/testing/tools.html#django.test.SimpleTestCase.assertRedirects" title="django.test.SimpleTestCase.assertRedirects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRedirects()</span></code></a> 中进行比较时，现在可以正确处理协议。</li>
<li><a class="reference internal" href="../topics/testing/tools.html#django.test.Client" title="django.test.Client"><code class="xref py py-class docutils literal notranslate"><span class="pre">Client</span></code></a> 的所有请求方法现在都添加了 <code class="docutils literal notranslate"><span class="pre">secure</span></code> 参数。如果设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，请求将通过 HTTPS 发送。</li>
<li>如果断言失败，<a class="reference internal" href="../topics/testing/tools.html#django.test.TransactionTestCase.assertNumQueries" title="django.test.TransactionTestCase.assertNumQueries"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNumQueries()</span></code></a> 现在会打印出已执行查询的列表。</li>
<li>由测试处理程序生成的 <code class="docutils literal notranslate"><span class="pre">WSGIRequest</span></code> 实例现在附加到 <a class="reference internal" href="../topics/testing/tools.html#django.test.Response.wsgi_request" title="django.test.Response.wsgi_request"><code class="xref py py-attr docutils literal notranslate"><span class="pre">django.test.Response.wsgi_request</span></code></a> 属性。</li>
<li>测试的数据库设置已经收集到一个名为 <a class="reference internal" href="../ref/settings.html#std-setting-DATABASE-TEST"><code class="xref std std-setting docutils literal notranslate"><span class="pre">TEST</span></code></a> 的字典中。</li>
</ul>
</div>
<div class="section" id="s-utilities">
<span id="utilities"></span><h4>实用程序<a class="headerlink" href="#utilities" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>提高了 <a class="reference internal" href="../ref/utils.html#django.utils.html.strip_tags" title="django.utils.html.strip_tags"><code class="xref py py-func docutils literal notranslate"><span class="pre">strip_tags()</span></code></a> 的准确性（但如文档中所述，它仍然不能保证产生 HTML 安全的结果）。</li>
</ul>
</div>
<div class="section" id="s-validators">
<span id="validators"></span><h4>验证器<a class="headerlink" href="#validators" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="../ref/validators.html#django.core.validators.RegexValidator" title="django.core.validators.RegexValidator"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegexValidator</span></code></a> 现在接受可选的 <a class="reference internal" href="../ref/validators.html#django.core.validators.RegexValidator.flags" title="django.core.validators.RegexValidator.flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">flags</span></code></a> 和布尔型 <a class="reference internal" href="../ref/validators.html#django.core.validators.RegexValidator.inverse_match" title="django.core.validators.RegexValidator.inverse_match"><code class="xref py py-attr docutils literal notranslate"><span class="pre">inverse_match</span></code></a> 参数。<a class="reference internal" href="../ref/validators.html#django.core.validators.RegexValidator.inverse_match" title="django.core.validators.RegexValidator.inverse_match"><code class="xref py py-attr docutils literal notranslate"><span class="pre">inverse_match</span></code></a> 属性确定在正则表达式模式匹配（<code class="docutils literal notranslate"><span class="pre">True</span></code>）或不匹配（默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>）提供的 <code class="docutils literal notranslate"><span class="pre">value</span></code> 时是否引发 <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValidationError</span></code></a>。<a class="reference internal" href="../ref/validators.html#django.core.validators.RegexValidator.flags" title="django.core.validators.RegexValidator.flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">flags</span></code></a> 属性设置编译正则表达式字符串时使用的标志。</li>
<li><a class="reference internal" href="../ref/validators.html#django.core.validators.URLValidator" title="django.core.validators.URLValidator"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLValidator</span></code></a> 现在接受一个可选的 <code class="docutils literal notranslate"><span class="pre">schemes</span></code> 参数，允许自定义接受的 URI 方案（而不是默认的 <code class="docutils literal notranslate"><span class="pre">http(s)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ftp(s)</span></code>）。</li>
<li><a class="reference internal" href="../ref/validators.html#django.core.validators.validate_email" title="django.core.validators.validate_email"><code class="xref py py-func docutils literal notranslate"><span class="pre">validate_email()</span></code></a> 现在接受包含 IPv6 字面量的地址，例如 <code class="docutils literal notranslate"><span class="pre">example&#64;[2001:db8::1]</span></code>，如 RFC 5321 中规定。</li>
</ul>
</div>
</div>
</div>
<div class="section" id="s-backwards-incompatible-changes-in-1-7">
<span id="s-backwards-incompatible-1-7"></span><span id="backwards-incompatible-changes-in-1-7"></span><span id="backwards-incompatible-1-7"></span><h2>1.7 版中向后不兼容的变化<a class="headerlink" href="#backwards-incompatible-changes-in-1-7" title="永久链接至标题">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">除了本节中概述的更改之外，确保查看任何已删除功能的 <a class="reference internal" href="../internals/deprecation.html#deprecation-removed-in-1-7"><span class="std std-ref">废弃计划</span></a>。如果您在给定功能的废弃时间段内未更新您的代码，其删除可能会被视为向后不兼容的更改。</p>
</div>
<div class="section" id="s-allow-syncdb-allow-migrate">
<span id="allow-syncdb-allow-migrate"></span><h3><code class="docutils literal notranslate"><span class="pre">allow_syncdb</span></code> / <code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code><a class="headerlink" href="#allow-syncdb-allow-migrate" title="永久链接至标题">¶</a></h3>
<p>尽管 Django 仍然会查看 <code class="docutils literal notranslate"><span class="pre">allow_syncdb</span></code> 方法，尽管它们应该重命名为 <code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code>，但传递给这些方法的模型有一些微妙的区别。</p>
<p>对于具有迁移的应用程序，<code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code> 现在将传递 <a class="reference internal" href="../topics/migrations.html#historical-models"><span class="std std-ref">历史模型</span></a>，这些模型是特殊的带有自定义属性、方法或管理器的版本模型。确保您的 <code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code> 方法只引用了 <code class="docutils literal notranslate"><span class="pre">model._meta</span></code> 中的字段或其他项。</p>
</div>
<div class="section" id="s-initial-data">
<span id="initial-data"></span><h3>initial_data<a class="headerlink" href="#initial-data" title="永久链接至标题">¶</a></h3>
<p>具有迁移的应用程序在完成迁移后将不再加载 <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> 修复程序。没有迁移的应用程序将在模拟旧的 <code class="docutils literal notranslate"><span class="pre">syncdb</span></code> 行为的 <code class="docutils literal notranslate"><span class="pre">migrate</span></code> 阶段继续加载这些修复程序，但任何新的应用程序将不再支持这一功能。</p>
<p>相反，我们鼓励您在需要时在迁移中加载初始数据（使用 <code class="docutils literal notranslate"><span class="pre">RunPython</span></code> 操作和您的模型类）；这有一个附加优势，即每次更改模式时都不需要更新初始数据。</p>
<p>另外，就像 Django 的旧 <code class="docutils literal notranslate"><span class="pre">syncdb</span></code> 代码一样，<code class="docutils literal notranslate"><span class="pre">initial_data</span></code> 也已经开始了弃用路径，并将在 Django 1.9 中移除。</p>
</div>
<div class="section" id="s-deconstruct-and-serializability">
<span id="deconstruct-and-serializability"></span><h3><code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> 和可序列化性<a class="headerlink" href="#deconstruct-and-serializability" title="永久链接至标题">¶</a></h3>
<p>Django 现在要求所有 Field 类及其构造函数参数都必须可序列化。如果你以任何方式修改了自定义 Field 的构造函数签名，你需要实现一个 <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> 方法；我们已经在自定义字段文档中扩展了 <a class="reference internal" href="../howto/custom-model-fields.html#custom-field-deconstruct-method"><span class="std std-ref">关于实现这个方法的说明</span></a>。</p>
<p>所有字段参数需要是可 <a class="reference internal" href="../topics/migrations.html#migration-serializing"><span class="std std-ref">序列化的</span></a> 要求意味着任何传递到 Field 构造函数中的自定义类实例，比如自定义的 Storage 子类，都需要在它们上面定义一个 <a class="reference internal" href="../topics/migrations.html#custom-deconstruct-method"><span class="std std-ref">deconstruct 方法</span></a>，尽管 Django 提供了一个方便的类装饰器，对大多数应用都适用。</p>
</div>
<div class="section" id="s-app-loading-changes">
<span id="app-loading-changes"></span><h3>应用加载的变化<a class="headerlink" href="#app-loading-changes" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-start-up-sequence">
<span id="start-up-sequence"></span><h4>启动序列<a class="headerlink" href="#start-up-sequence" title="永久链接至标题">¶</a></h4>
<p>Django 1.7 在启动时会立即加载应用程序配置和模型。虽然这种行为更为直接，被认为更加健壮，但不能完全排除回归问题。有关您可能遇到的一些问题的解决方案，请参阅 <a class="reference internal" href="../ref/applications.html#applications-troubleshooting"><span class="std std-ref">错误调试</span></a>。</p>
</div>
<div class="section" id="s-standalone-scripts">
<span id="standalone-scripts"></span><h4>独一无二的脚本<a class="headerlink" href="#standalone-scripts" title="永久链接至标题">¶</a></h4>
<p>如果你在一个普通的 Python 脚本中使用 Django，而不是管理命令，并且依赖于 <span class="target" id="index-4"></span><a class="reference internal" href="../topics/settings.html#envvar-DJANGO_SETTINGS_MODULE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">DJANGO_SETTINGS_MODULE</span></code></a> 环境变量，现在你必须在脚本开头显式地初始化 Django，如下所示：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">django</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">django</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
</pre></div>
</div>
<p>否则，你将遇到一个 <code class="docutils literal notranslate"><span class="pre">AppRegistryNotReady</span></code> 异常。</p>
</div>
<div class="section" id="s-wsgi-scripts">
<span id="wsgi-scripts"></span><h4>WSGI 脚本<a class="headerlink" href="#wsgi-scripts" title="永久链接至标题">¶</a></h4>
<p>在 Django 1.3 之前，创建一个 WSGI 应用程序的推荐方法是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">django.core.handlers.wsgi</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">django</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">wsgi</span><span class="o">.</span><span class="n">WSGIHandler</span><span class="p">()</span>
</pre></div>
</div>
<p>在 Django 1.4 中，对 WSGI 的支持得到改进，并且 API 发生了变化：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.core.wsgi</span> <span class="kn">import</span> <span class="n">get_wsgi_application</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">get_wsgi_application</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你的 WSGI 脚本仍在使用前一种风格，你需要升级到后一种风格，否则你将遇到一个 <code class="docutils literal notranslate"><span class="pre">AppRegistryNotReady</span></code> 异常。</p>
</div>
<div class="section" id="s-app-registry-consistency">
<span id="app-registry-consistency"></span><h4>应用程序注册表的一致性<a class="headerlink" href="#app-registry-consistency" title="永久链接至标题">¶</a></h4>
<p>不再允许安装具有相同标签的多个应用程序。在 Django 的早期版本中，这种情况不总是正常工作，但也不会完全崩溃。</p>
<p>如果你有两个具有相同标签的应用程序，你应该为其中一个创建一个 <a class="reference internal" href="../ref/applications.html#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>，并在其中覆盖其 <a class="reference internal" href="../ref/applications.html#django.apps.AppConfig.label" title="django.apps.AppConfig.label"><code class="xref py py-class docutils literal notranslate"><span class="pre">label</span></code></a>。然后，你应该在引用该应用程序或其模型的任何代码中，将旧标签调整为新标签。</p>
<p>不再允许通过不同路径两次导入同一模型。从 Django 1.6 开始，只有在手动将一个目录和一个子目录放在 <span class="target" id="index-5"></span><a class="reference external" href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH" title="(在 Python v3.12)"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 上时，才会发生这种情况。有关迁移说明，请参阅 <a class="reference internal" href="1.4.html"><span class="doc">1.4 发布说明中的新项目布局部分</span></a>。</p>
<p>您应该确保：</p>
<ul class="simple">
<li>所有模型都在列在 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中或具有明确 <a class="reference internal" href="../ref/models/options.html#django.db.models.Options.app_label" title="django.db.models.Options.app_label"><code class="xref py py-attr docutils literal notranslate"><span class="pre">app_label</span></code></a> 的应用程序中定义。</li>
<li>模型不会作为加载其应用程序的副作用而导入。具体而言，您不应该在应用程序的根模块或定义其配置类的模块中导入模型。</li>
</ul>
<p>从版本 1.9 开始，Django 将强制执行这些要求，经过一段废弃期之后。</p>
</div>
<div class="section" id="s-subclassing-appcommand">
<span id="subclassing-appcommand"></span><h4>继承 AppCommand 类<a class="headerlink" href="#subclassing-appcommand" title="永久链接至标题">¶</a></h4>
<p><a class="reference internal" href="../howto/custom-management-commands.html#django.core.management.AppCommand" title="django.core.management.AppCommand"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppCommand</span></code></a> 的子类现在必须实现 <a class="reference internal" href="../howto/custom-management-commands.html#django.core.management.AppCommand.handle_app_config" title="django.core.management.AppCommand.handle_app_config"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_app_config()</span></code></a> 方法，而不是 <code class="docutils literal notranslate"><span class="pre">handle_app()</span></code>。这个方法接收一个 <a class="reference internal" href="../ref/applications.html#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 实例，而不是一个模型模块。</p>
</div>
<div class="section" id="s-introspecting-applications">
<span id="introspecting-applications"></span><h4>检查应用程序信息<a class="headerlink" href="#introspecting-applications" title="永久链接至标题">¶</a></h4>
<p>由于 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 现在支持应用程序配置类，而不仅仅是应用程序模块，因此你应该检查直接访问此设置的代码，并改为使用应用程序注册表 (<a class="reference internal" href="../ref/applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">django.apps.apps</span></code></a>)。</p>
<p>应用程序注册表保留了一些旧的应用程序缓存的特性。尽管应用程序缓存是一个私有 API，但过时的方法和参数将通过标准的废弃路径逐步移除，但以下变更将立即生效：</p>
<ul class="simple">
<li>当找不到模型时，<code class="docutils literal notranslate"><span class="pre">get_model</span></code> 现在会引发 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>，而不是返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</li>
<li><code class="docutils literal notranslate"><span class="pre">get_model</span></code> 和 <code class="docutils literal notranslate"><span class="pre">get_models</span></code> 的 <code class="docutils literal notranslate"><span class="pre">only_installed</span></code> 参数不再存在，<code class="docutils literal notranslate"><span class="pre">get_model</span></code> 的 <code class="docutils literal notranslate"><span class="pre">seed_cache</span></code> 参数也不再存在。</li>
</ul>
</div>
</div>
<div class="section" id="s-management-commands-and-order-of-installed-apps">
<span id="management-commands-and-order-of-installed-apps"></span><h3>管理命令和 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 的顺序<a class="headerlink" href="#management-commands-and-order-of-installed-apps" title="永久链接至标题">¶</a></h3>
<p>当多个应用程序提供具有相同名称的管理命令时，Django 会从 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中排在前面的应用程序加载命令。之前的版本会从排在最后的应用程序加载命令。</p>
<p>这将管理命令的发现与 Django 的其他部分保持一致，这些部分依赖于 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 的顺序，比如静态文件、模板和翻译。</p>
</div>
<div class="section" id="s-validationerror-constructor-and-internal-storage">
<span id="s-validation-error-constructor-and-internal-storage"></span><span id="validationerror-constructor-and-internal-storage"></span><span id="validation-error-constructor-and-internal-storage"></span><h3><code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 构造函数和内部存储<a class="headerlink" href="#validationerror-constructor-and-internal-storage" title="永久链接至标题">¶</a></h3>
<p>当 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 构造函数接收到错误容器作为参数时（例如，一个 <code class="docutils literal notranslate"><span class="pre">list</span></code> 或一个 <code class="docutils literal notranslate"><span class="pre">ErrorList</span></code>），其行为已经发生了变化：</p>
<ul class="simple">
<li>它会在将字符串添加到其内部存储之前，将其转换为 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 的实例。</li>
<li>它不会存储给定的容器，而是将其内容复制到自己的内部存储中；以前容器本身被添加到 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 实例并用作内部存储。</li>
</ul>
<p>这意味着如果你访问 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 的内部存储，比如 <code class="docutils literal notranslate"><span class="pre">error_list</span></code>、<code class="docutils literal notranslate"><span class="pre">error_dict</span></code> 或 <code class="docutils literal notranslate"><span class="pre">update_error_dict()</span></code> 的返回值，你可能会在以前找到字符串的地方找到 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 的实例。</p>
<p>此外，如果你直接将 <code class="docutils literal notranslate"><span class="pre">update_error_dict()</span></code> 的返回值赋给 <code class="docutils literal notranslate"><span class="pre">Form._errors</span></code>，你可能会无意中添加 <code class="docutils literal notranslate"><span class="pre">list</span></code> 实例，而期望的是 <code class="docutils literal notranslate"><span class="pre">ErrorList</span></code> 实例。这是一个问题，因为与简单的 <code class="docutils literal notranslate"><span class="pre">list</span></code> 不同，<code class="docutils literal notranslate"><span class="pre">ErrorList</span></code> 知道如何处理 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 的实例。</p>
<p>现在，大多数需要使用这些私有 API 的用例都可以使用新引入的 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.add_error" title="django.forms.Form.add_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Form.add_error()</span></code></a> 方法来处理：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Old pattern:</span>
<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">update_error_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>

<span class="c1"># New pattern:</span>
<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你需要同时兼容 Django &lt;= 1.6 和 1.7，由于在 Django 1.7 之前没有提供 <a class="reference internal" href="../ref/forms/api.html#django.forms.Form.add_error" title="django.forms.Form.add_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Form.add_error()</span></code></a> 方法，你可以使用以下解决方法将任何 <code class="docutils literal notranslate"><span class="pre">list</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">ErrorList</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">update_error_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>

<span class="c1"># Additional code to ensure ``ErrorDict`` is exclusively</span>
<span class="c1"># composed of ``ErrorList`` instances.</span>
<span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">error_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_class</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_class</span><span class="p">(</span><span class="n">error_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-behavior-of-locmemcache-regarding-pickle-errors">
<span id="behavior-of-locmemcache-regarding-pickle-errors"></span><h3>关于 <code class="docutils literal notranslate"><span class="pre">LocMemCache</span></code> 对 pickle 错误的行为<a class="headerlink" href="#behavior-of-locmemcache-regarding-pickle-errors" title="永久链接至标题">¶</a></h3>
<p>在以前的 Django 版本中存在一个不一致之处，关于不同缓存后端如何处理 pickle 错误。<code class="docutils literal notranslate"><span class="pre">django.core.cache.backends.locmem.LocMemCache</span></code> 以前在发生这种错误时会静默失败，这与其他后端不一致，并导致了与缓存相关的错误。在 Django 1.7 中已经修复了这个问题，详情请参阅 <a class="reference external" href="https://code.djangoproject.com/ticket/21200">#21200</a>。</p>
</div>
<div class="section" id="s-cache-keys-are-now-generated-from-the-request-s-absolute-url">
<span id="cache-keys-are-now-generated-from-the-request-s-absolute-url"></span><h3>现在缓存键从请求的绝对 URL 生成<a class="headerlink" href="#cache-keys-are-now-generated-from-the-request-s-absolute-url" title="永久链接至标题">¶</a></h3>
<p>在以前的 Django 版本中，缓存键是使用请求的路径和查询字符串生成的，但不包括 scheme 和 host。如果一个 Django 应用程序服务多个子域或域名，缓存键可能会发生冲突。在 Django 1.7 中，缓存键会根据请求的绝对 URL 包括 scheme、host、path 和查询字符串而变化。例如，缓存键的 URL 部分现在是从 <code class="docutils literal notranslate"><span class="pre">https://www.example.com/path/to/?key=val</span></code> 生成的，而不是 <code class="docutils literal notranslate"><span class="pre">/path/to/?key=val</span></code>。Django 1.7 生成的缓存键将与旧版本的 Django 生成的键不同。升级到 Django 1.7 后，对任何以前缓存的 URL 的第一个请求将导致缓存未命中。</p>
</div>
<div class="section" id="s-passing-none-to-manager-db-manager">
<span id="passing-none-to-manager-db-manager"></span><h3>将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 传递给 <code class="docutils literal notranslate"><span class="pre">Manager.db_manager()</span></code><a class="headerlink" href="#passing-none-to-manager-db-manager" title="永久链接至标题">¶</a></h3>
<p>在以前的 Django 版本中，可以在模型管理器实例上使用 <code class="docutils literal notranslate"><span class="pre">db_manager(using=None)</span></code> 来获取一个使用默认路由行为的管理器实例，覆盖任何手动指定的数据库路由。在 Django 1.7 中，传递给 db_manager 的值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将产生一个保留任何手动分配的数据库路由的路由器 -- 管理器将 <em>不</em> 被重置。这是为了解决路由信息在连接中级联的方式存在的不一致性。详情请参阅 <a class="reference external" href="https://code.djangoproject.com/ticket/13724">#13724</a>。</p>
</div>
<div class="section" id="s-pytz-may-be-required">
<span id="pytz-may-be-required"></span><h3>可能需要使用 <code class="docutils literal notranslate"><span class="pre">pytz</span></code><a class="headerlink" href="#pytz-may-be-required" title="永久链接至标题">¶</a></h3>
<p>如果你的项目处理 1970 年之前或 2037 年之后的日期时间，并且当 Django 遇到它们时引发 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，那么你将需要安装 <a class="reference external" href="https://pypi.org/project/pytz/">pytz</a>。如果你使用了 Django 的时区相关的日期格式或 <a class="reference internal" href="../ref/contrib/syndication.html#module-django.contrib.syndication" title="django.contrib.syndication: A framework for generating syndication feeds, in RSS and Atom, quite easily."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.syndication</span></code></a>，可能会受到这个问题的影响。</p>
</div>
<div class="section" id="s-remove-and-clear-methods-of-related-managers">
<span id="remove-and-clear-methods-of-related-managers"></span><h3>关于相关管理器的 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法<a class="headerlink" href="#remove-and-clear-methods-of-related-managers" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code>、<code class="docutils literal notranslate"><span class="pre">GenericForeignKey</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 创建的相关管理器的 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法存在一些问题。一些操作在没有包装在事务中的情况下运行多个数据修改查询，而一些操作在存在默认过滤条件时（即当相关模型上的默认管理器实现了自定义的 <code class="docutils literal notranslate"><span class="pre">get_queryset()</span></code> 时）不会尊重默认过滤条件。</p>
<p>修复这些问题引入了一些向后不兼容的更改：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> 相关管理器的默认 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 实现从一系列的 <code class="docutils literal notranslate"><span class="pre">Model.save()</span></code> 调用更改为单个 <code class="docutils literal notranslate"><span class="pre">QuerySet.update()</span></code> 调用。这个改变意味着不再发送 <code class="docutils literal notranslate"><span class="pre">pre_save</span></code> 和 <code class="docutils literal notranslate"><span class="pre">post_save</span></code> 信号。你可以使用 <code class="docutils literal notranslate"><span class="pre">bulk=False</span></code> 关键字参数来恢复到以前的行为。</li>
<li><code class="docutils literal notranslate"><span class="pre">GenericForeignKey</span></code> 相关管理器的 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法现在执行批量删除。不再在每个实例上调用 <code class="docutils literal notranslate"><span class="pre">Model.delete()</span></code> 方法。你可以使用 <code class="docutils literal notranslate"><span class="pre">bulk=False</span></code> 关键字参数来恢复到以前的行为。</li>
<li>与 <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> 相关的管理器的 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法在涉及到过滤时执行嵌套查询，这可能会根据你的数据库和数据本身是否成问题而有所不同。有关更多详情，请参阅 <a class="reference internal" href="../ref/models/querysets.html#nested-queries-performance"><span class="std std-ref">此说明</span></a>。</li>
</ul>
</div>
<div class="section" id="s-admin-login-redirection-strategy">
<span id="admin-login-redirection-strategy"></span><h3>管理员登录重定向策略<a class="headerlink" href="#admin-login-redirection-strategy" title="永久链接至标题">¶</a></h3>
<p>在历史上，Django 管理站点会将未经授权或未经身份验证的用户的请求直接传递给登录视图，而不进行 HTTP 重定向。在 Django 1.7 中，这种行为发生了变化，以符合更传统的工作流程，其中任何未经授权的请求到管理页面都会被重定向（通过 HTTP 状态码 302）到登录页面，其中 <code class="docutils literal notranslate"><span class="pre">next</span></code> 参数设置为引用的路径。用户在成功登录后将被重定向到那里。</p>
<p>还请注意，管理员登录表单已更新，不再包含无用的 <code class="docutils literal notranslate"><span class="pre">this_is_the_login_form</span></code> 字段，而且 <code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 代码已设置为更常规的 <code class="docutils literal notranslate"><span class="pre">invalid_login</span></code> 键。</p>
</div>
<div class="section" id="s-select-for-update-requires-a-transaction">
<span id="select-for-update-requires-a-transaction"></span><h3><code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> 需要在事务中使用<a class="headerlink" href="#select-for-update-requires-a-transaction" title="永久链接至标题">¶</a></h3>
<p>在历史上，使用 <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.select_for_update" title="django.db.models.query.QuerySet.select_for_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_for_update()</span></code></a> 的查询可以在自动提交模式下，在事务之外执行。在 Django 1.6 之前，Django 的自动事务模式允许使用这种方式锁定记录，直到下一次写操作。Django 1.6 引入了数据库级别的自动提交；自那时起，在这种上下文中执行将取消 <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> 的效果。因此，现在假定这是一个错误并引发异常。</p>
<p>这个更改是因为这样的错误可能是由包含一个期望全局事务的应用程序（例如：<a class="reference internal" href="../ref/settings.html#std-setting-DATABASE-ATOMIC_REQUESTS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ATOMIC_REQUESTS</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>）或者 Django 的旧的自动提交行为，在一个不需要它们的项目中运行时引起的；而且，这样的错误可能会表现为数据损坏的问题。这个更改也是在 Django 1.6.3 中进行的。</p>
<p>如果您在测试类中使用 <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> 并且该测试类是 <a class="reference internal" href="../topics/testing/tools.html#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransactionTestCase</span></code></a> 的子类而不是 <a class="reference internal" href="../topics/testing/tools.html#django.test.TestCase" title="django.test.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>，则此更改可能导致测试失败。</p>
</div>
<div class="section" id="s-contrib-middleware-removed-from-default-middleware-classes">
<span id="contrib-middleware-removed-from-default-middleware-classes"></span><h3>Contrib 中间件从默认的 <code class="docutils literal notranslate"><span class="pre">MIDDLEWARE_CLASSES</span></code> 中移除<a class="headerlink" href="#contrib-middleware-removed-from-default-middleware-classes" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#app-loading-refactor-17-release-note"><span class="std std-ref">应用加载重构</span></a> 弃用了使用不在 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 设置中的应用程序中的模型。这暴露出默认的 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 和全局默认值（<code class="docutils literal notranslate"><span class="pre">django.conf.global_settings</span></code>）中的 <code class="docutils literal notranslate"><span class="pre">MIDDLEWARE_CLASSES</span></code> 之间的不兼容性。为了使这些设置保持同步，并且在使用最小设置测试可重用应用程序等情况下防止弃用警告，从默认设置中移除了 <a class="reference internal" href="../ref/middleware.html#django.contrib.sessions.middleware.SessionMiddleware" title="django.contrib.sessions.middleware.SessionMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionMiddleware</span></code></a>、<a class="reference internal" href="../ref/middleware.html#django.contrib.auth.middleware.AuthenticationMiddleware" title="django.contrib.auth.middleware.AuthenticationMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">AuthenticationMiddleware</span></code></a> 和 <a class="reference internal" href="../ref/middleware.html#django.contrib.messages.middleware.MessageMiddleware" title="django.contrib.messages.middleware.MessageMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">MessageMiddleware</span></code></a>。这些类仍然会包含在由 <a class="reference internal" href="../ref/django-admin.html#django-admin-startproject"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">startproject</span></code></a> 生成的默认设置中。大多数项目不会受到这个更改的影响，但如果你之前没有在项目设置中声明 <code class="docutils literal notranslate"><span class="pre">MIDDLEWARE_CLASSES</span></code> 并依赖于全局默认值，你应该确保新的默认值符合你的项目需求。你还应该检查任何访问 <code class="docutils literal notranslate"><span class="pre">django.conf.global_settings.MIDDLEWARE_CLASSES</span></code> 的代码。</p>
</div>
<div class="section" id="s-miscellaneous">
<span id="miscellaneous"></span><h3>杂项<a class="headerlink" href="#miscellaneous" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first"><a class="reference internal" href="../ref/files/uploads.html#django.core.files.uploadhandler.FileUploadHandler.new_file" title="django.core.files.uploadhandler.FileUploadHandler.new_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">django.core.files.uploadhandler.FileUploadHandler.new_file()</span></code></a> 方法现在传递了一个额外的 <code class="docutils literal notranslate"><span class="pre">content_type_extra</span></code> 参数。如果你有一个自定义的 <a class="reference internal" href="../ref/files/uploads.html#django.core.files.uploadhandler.FileUploadHandler" title="django.core.files.uploadhandler.FileUploadHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileUploadHandler</span></code></a>，实现了 <code class="docutils literal notranslate"><span class="pre">new_file()</span></code> 方法，请确保它接受这个新参数。</p>
</li>
<li><p class="first"><a class="reference internal" href="../topics/forms/modelforms.html#django.forms.models.BaseModelFormSet" title="django.forms.models.BaseModelFormSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelFormSet</span></code></a> 在调用 <code class="docutils literal notranslate"><span class="pre">save(commit=False)</span></code> 时不再删除实例。请查看 <a class="reference internal" href="../topics/forms/formsets.html#django.forms.formsets.BaseFormSet.can_delete" title="django.forms.formsets.BaseFormSet.can_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">can_delete</span></code></a> 以获取如何手动从删除的表单中删除对象的说明。</p>
</li>
<li><p class="first">加载空的 fixture 现在会发出一个 <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code>，而不是引发 <a class="reference internal" href="../howto/custom-management-commands.html#django.core.management.CommandError" title="django.core.management.CommandError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CommandError</span></code></a>。</p>
</li>
<li><p class="first">当 <a class="reference internal" href="../ref/settings.html#std-setting-DEBUG"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEBUG</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时，<a class="reference internal" href="../ref/contrib/staticfiles.html#django.contrib.staticfiles.views.serve" title="django.contrib.staticfiles.views.serve"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.contrib.staticfiles.views.serve()</span></code></a> 现在会引发一个 <a class="reference internal" href="../topics/http/views.html#django.http.Http404" title="django.http.Http404"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Http404</span></code></a> 异常，而不是 <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ImproperlyConfigured" title="django.core.exceptions.ImproperlyConfigured"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImproperlyConfigured</span></code></a>。这个更改消除了将视图有条件地添加到根 URLconf 的需要，从而使其能够通过名称安全地反转。它还消除了访问者通过请求不存在或尚未收集的静态文件而生成虚假的 HTTP 500 错误的能力。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/models/instances.html#django.db.models.Model.__eq__" title="django.db.models.Model.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">django.db.models.Model.__eq__()</span></code></a> 方法现在以一种新的方式定义，其中代理模型的实例和其基模型的实例在主键匹配时被视为相等。以前，只有完全相同类的实例在主键匹配时被视为相等。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/models/instances.html#django.db.models.Model.__eq__" title="django.db.models.Model.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">django.db.models.Model.__eq__()</span></code></a> 方法已更改，因此两个没有主键值的 <code class="docutils literal notranslate"><span class="pre">Model</span></code> 实例不会被视为相等（除非它们是同一个实例）。</p>
</li>
<li><p class="first">当在没有主键值的实例上调用 <a class="reference internal" href="../ref/models/instances.html#django.db.models.Model.__hash__" title="django.db.models.Model.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">django.db.models.Model.__hash__()</span></code></a> 方法时，现在会引发 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>。这是为了避免在容器中使用可变的 <code class="docutils literal notranslate"><span class="pre">__hash__</span></code> 值。</p>
</li>
<li><p class="first">在 SQLite 数据库中，<a class="reference internal" href="../ref/models/fields.html#django.db.models.AutoField" title="django.db.models.AutoField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoField</span></code></a> 列现在将使用 <code class="docutils literal notranslate"><span class="pre">AUTOINCREMENT</span></code> 选项创建，以确保单调递增。这将导致 SQLite 上的主键编号行为发生变化，与大多数其他 SQL 数据库保持一致。这仅适用于新创建的表。如果你有一个使用较早版本的 Django 创建的数据库，你需要迁移它以利用这个功能。例如，你可以执行以下操作：</p>
<ol class="arabic simple">
<li>使用 <a class="reference internal" href="../ref/django-admin.html#django-admin-dumpdata"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">dumpdata</span></code></a> 来保存你的数据。</li>
<li>重命名现有的数据库文件（将其保留作为备份）。</li>
<li>运行 <a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> 来创建更新后的模式。</li>
<li>使用 <a class="reference internal" href="../ref/django-admin.html#django-admin-loaddata"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">loaddata</span></code></a> 导入你在第一步导出的 fixture 数据。</li>
</ol>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.contrib.auth.models.AbstractUser</span></code> 不再定义 <a class="reference internal" href="../ref/models/instances.html#django.db.models.Model.get_absolute_url" title="django.db.models.Model.get_absolute_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_absolute_url()</span></code></a> 方法。旧的定义返回 <code class="docutils literal notranslate"><span class="pre">&quot;/users/%s/&quot;</span> <span class="pre">%</span> <span class="pre">urlquote(self.username)</span></code>，这是任意的，因为应用程序可以或不可以在 <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> 中定义这样的 URL。在你自己的自定义用户对象上定义一个 <code class="docutils literal notranslate"><span class="pre">get_absolute_url()</span></code> 方法，或者如果你想要一个用户的 URL，可以使用 <a class="reference internal" href="../ref/settings.html#std-setting-ABSOLUTE_URL_OVERRIDES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ABSOLUTE_URL_OVERRIDES</span></code></a>。</p>
</li>
<li><p class="first"><a class="reference internal" href="../topics/testing/tools.html#django.test.LiveServerTestCase" title="django.test.LiveServerTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.test.LiveServerTestCase</span></code></a> 类的静态资源服务功能已经简化：现在它只能在运行测试时服务于已经存在于 <a class="reference internal" href="../ref/settings.html#std-setting-STATIC_ROOT"><code class="xref std std-setting docutils literal notranslate"><span class="pre">STATIC_ROOT</span></code></a> 中的内容。像在开发时使用 <a class="reference internal" href="../ref/settings.html#std-setting-DEBUG"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEBUG</span> <span class="pre">=</span> <span class="pre">True</span></code></a> 那样透明地提供所有静态资源的能力已经移动到一个新的类中，该类位于 <code class="docutils literal notranslate"><span class="pre">staticfiles</span></code> 应用程序中（实际负责此功能的应用程序）：<a class="reference internal" href="../ref/contrib/staticfiles.html#django.contrib.staticfiles.testing.StaticLiveServerTestCase" title="django.contrib.staticfiles.testing.StaticLiveServerTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.contrib.staticfiles.testing.StaticLiveServerTestCase</span></code></a>。换句话说，<code class="docutils literal notranslate"><span class="pre">LiveServerTestCase</span></code> 本身的功能减弱了，但同时也减少了魔法。</p>
<p>这样做的原因是将非 contrib 代码与 contrib 应用程序的依赖关系移除。</p>
</li>
<li><p class="first">旧的缓存 URI 语法（例如 <code class="docutils literal notranslate"><span class="pre">&quot;locmem://&quot;</span></code>）不再受支持。尽管它之前可以工作，但它并没有被记录或正式支持。如果你仍在使用它，请更新到当前的 <a class="reference internal" href="../ref/settings.html#std-setting-CACHES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CACHES</span></code></a> 语法。</p>
</li>
<li><p class="first">在继承情况下，<code class="docutils literal notranslate"><span class="pre">Form</span></code> 字段的默认排序方式已更改为遵循正常的 Python MRO。现在，字段是通过反向迭代 MRO 来发现的，最顶层的类最后被考虑。这只会在你同时在当前类和父类 <code class="docutils literal notranslate"><span class="pre">Form</span></code> 中定义字段并且依赖于默认字段顺序时影响你。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/forms/widgets.html#django.forms.SelectDateWidget" title="django.forms.SelectDateWidget"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectDateWidget</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">required</span></code> 参数已被移除。这个小部件现在会像其他小部件一样尊重表单字段的 <code class="docutils literal notranslate"><span class="pre">is_required</span></code> 属性。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Widget.is_hidden</span></code> 现在是一个只读属性，通过检查 <code class="docutils literal notranslate"><span class="pre">input_type</span> <span class="pre">==</span> <span class="pre">'hidden'</span></code> 的存在来获取其值。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> 现在与其他类似的调用（如 <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code>）以相同的方式链式调用。也就是说，<code class="docutils literal notranslate"><span class="pre">select_related('foo',</span> <span class="pre">'bar')</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">select_related('foo').select_related('bar')</span></code>。以前，后者等同于 <code class="docutils literal notranslate"><span class="pre">select_related('bar')</span></code>。</p>
</li>
<li><p class="first">GeoDjango 不再支持 GEOS &lt; 3.1 。</p>
</li>
<li><p class="first">数据库后端的 <code class="docutils literal notranslate"><span class="pre">init_connection_state</span></code> 方法现在在自动提交模式下执行（除非你将 <a class="reference internal" href="../ref/settings.html#std-setting-DATABASE-AUTOCOMMIT"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTOCOMMIT</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>）。如果你维护一个自定义数据库后端，你应该检查这个方法。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.db.backends.BaseDatabaseFeatures.allows_primary_key_0</span></code> 属性已重命名为 <code class="docutils literal notranslate"><span class="pre">allows_auto_pk_0</span></code>，以更好地描述它。对于所有包含在 Django 中的数据库后端，除了 MySQL，它都为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，因为 MySQL 允许主键值为 0。它只禁止具有值 0 的 <em>autoincrement</em> 主键。</p>
</li>
<li><p class="first">禁止在子模型中定义与父模型中已定义的字段同名的字段，因为这会导致模型行为的歧义。此外，在模型继承层次结构中发生字段冲突将导致系统检查错误。例如，如果使用多继承，你需要在父模型中定义自定义主键字段，否则默认的 <code class="docutils literal notranslate"><span class="pre">id</span></code> 字段将发生冲突。有关详细信息，请参阅 <a class="reference internal" href="../topics/db/models.html#model-multiple-inheritance-topic"><span class="std std-ref">多重继承</span></a>。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.utils.translation.parse_accept_lang_header()</span></code> 现在返回小写的区域设置，而不是提供的大小写。由于区域设置应该被视为不区分大小写，这使得我们能够加速区域设置的检测。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.utils.translation.get_language_from_path()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">django.utils.translation.trans_real.get_supported_language_variant()</span></code> 现在不再接受 <code class="docutils literal notranslate"><span class="pre">supported</span></code> 参数。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.contrib.contenttypes.views</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">shortcut</span></code> 视图现在支持协议相对 URL（例如 <code class="docutils literal notranslate"><span class="pre">//example.com</span></code>）。</p>
</li>
<li><p class="first"><a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericRelation</span></code></a> 现在支持一个可选的 <code class="docutils literal notranslate"><span class="pre">related_query_name</span></code> 参数。设置 <code class="docutils literal notranslate"><span class="pre">related_query_name</span></code> 可以在相关对象和内容类型之间添加关系，用于过滤、排序和其他查询操作。</p>
</li>
<li><p class="first">在 PostgreSQL 上运行测试时，<a class="reference internal" href="../ref/settings.html#std-setting-USER"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USER</span></code></a> 将需要对内置的 <code class="docutils literal notranslate"><span class="pre">postgres</span></code> 数据库进行读取访问权限。这是替代了以前连接到实际非测试数据库的行为。</p>
</li>
<li><p class="first">作为 <a class="reference internal" href="../ref/checks.html"><span class="doc">系统检查框架</span></a> 的一部分，<a class="reference internal" href="../topics/checks.html#field-checking"><span class="std std-ref">字段、模型和模型管理器</span></a> 都实现了一个已在检查框架中注册的 <code class="docutils literal notranslate"><span class="pre">check()</span></code> 方法。如果你已经在其中一个对象上有一个名为 <code class="docutils literal notranslate"><span class="pre">check()</span></code> 的现有方法，你需要将其重命名。</p>
</li>
<li><p class="first">如上述 &quot;缓存&quot; 部分所提到的，将 <a class="reference internal" href="../ref/settings.html#std-setting-CACHES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">CACHES</span></code></a> 设置的 <a class="reference internal" href="../ref/settings.html#std-setting-CACHES-TIMEOUT"><code class="xref std std-setting docutils literal notranslate"><span class="pre">TIMEOUT</span></code></a> 参数定义为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将设置缓存键为 &quot;不过期&quot;。以前，对于 memcache 后端，<a class="reference internal" href="../ref/settings.html#std-setting-CACHES-TIMEOUT"><code class="xref std std-setting docutils literal notranslate"><span class="pre">TIMEOUT</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 会设置不过期的键，但这与 <code class="docutils literal notranslate"><span class="pre">set(&quot;key&quot;,</span> <span class="pre">&quot;value&quot;,</span> <span class="pre">timeout=0)</span></code> 的设置和过期（即不缓存）行为不一致。如果你想要不过期的键，请更新你的设置，将 <code class="docutils literal notranslate"><span class="pre">0</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，因为后者现在在设置中也表示设置和过期。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">sql*</span></code> 管理命令现在尊重 <a class="reference internal" href="../ref/settings.html#std-setting-DATABASE_ROUTERS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DATABASE_ROUTERS</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">allow_migrate()</span></code> 方法。如果你的模型与非默认数据库同步，请使用 <code class="docutils literal notranslate"><span class="pre">--database</span></code> 标志来获取这些模型的 SQL（以前它们总是包含在输出中）。</p>
</li>
<li><p class="first">解码 URL 中的查询字符串现在在输入不是有效的 UTF-8 时会回退到 ISO-8859-1 编码。</p>
</li>
<li><p class="first">通过将 <code class="docutils literal notranslate"><span class="pre">django.contrib.auth.middleware.SessionAuthenticationMiddleware</span></code> 添加到默认项目模板（仅适用于 1.7.2 之前的版本），在使用 <a class="reference internal" href="../ref/django-admin.html#django-admin-runserver"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">runserver</span></code></a> 访问页面之前必须创建一个数据库。</p>
</li>
<li><p class="first">将 <code class="docutils literal notranslate"><span class="pre">schemes</span></code> 参数添加到 <code class="docutils literal notranslate"><span class="pre">URLValidator</span></code> 中可能会在你之前使用自定义正则表达式来验证 schemes 的情况下出现向后不兼容的更改。如果 schemes 中没有列出的任何 scheme 将失败验证，即使正则表达式匹配给定的 URL。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="s-features-deprecated-in-1-7">
<span id="s-deprecated-features-1-7"></span><span id="features-deprecated-in-1-7"></span><span id="deprecated-features-1-7"></span><h2>在 1.7 中被废弃的功能<a class="headerlink" href="#features-deprecated-in-1-7" title="永久链接至标题">¶</a></h2>
<div class="section" id="s-django-core-cache-get-cache">
<span id="django-core-cache-get-cache"></span><h3><code class="docutils literal notranslate"><span class="pre">django.core.cache.get_cache</span></code><a class="headerlink" href="#django-core-cache-get-cache" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">django.core.cache.get_cache</span></code> 已被 <a class="reference internal" href="../topics/cache.html#django.core.cache.caches" title="django.core.cache.caches"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.core.cache.caches</span></code></a> 取代。</p>
</div>
<div class="section" id="s-django-utils-dictconfig-django-utils-importlib">
<span id="django-utils-dictconfig-django-utils-importlib"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.dictconfig</span></code>/<code class="docutils literal notranslate"><span class="pre">django.utils.importlib</span></code><a class="headerlink" href="#django-utils-dictconfig-django-utils-importlib" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">django.utils.dictconfig</span></code> 和 <code class="docutils literal notranslate"><span class="pre">django.utils.importlib</span></code> 分别是在 Python 版本 2.7 之前提供的 <a class="reference external" href="https://docs.python.org/3/library/logging.config.html#module-logging.config" title="(在 Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> 和 <a class="reference external" href="https://docs.python.org/3/library/importlib.html#module-importlib" title="(在 Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 的副本。它们已经被弃用。</p>
</div>
<div class="section" id="s-django-utils-module-loading-import-by-path">
<span id="django-utils-module-loading-import-by-path"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.module_loading.import_by_path</span></code><a class="headerlink" href="#django-utils-module-loading-import-by-path" title="永久链接至标题">¶</a></h3>
<p>当前的 <code class="docutils literal notranslate"><span class="pre">django.utils.module_loading.import_by_path</span></code> 函数捕获 <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>、<code class="docutils literal notranslate"><span class="pre">ImportError</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> 异常，并重新引发 <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ImproperlyConfigured" title="django.core.exceptions.ImproperlyConfigured"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImproperlyConfigured</span></code></a> 异常。这种异常掩盖使得诊断循环导入问题变得不必要地困难，因为它让问题看起来像是来自 Django 内部。它已被弃用，推荐使用 <a class="reference internal" href="../ref/utils.html#django.utils.module_loading.import_string" title="django.utils.module_loading.import_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">import_string()</span></code></a>。</p>
</div>
<div class="section" id="s-django-utils-tzinfo">
<span id="django-utils-tzinfo"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.tzinfo</span></code><a class="headerlink" href="#django-utils-tzinfo" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">django.utils.tzinfo</span></code> 提供了两个 <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.tzinfo" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tzinfo</span></code></a> 的子类，分别是 <code class="docutils literal notranslate"><span class="pre">LocalTimezone</span></code> 和 <code class="docutils literal notranslate"><span class="pre">FixedOffset</span></code>。它们已经被弃用，推荐使用更正确的替代方案，由 <a class="reference internal" href="../ref/utils.html#module-django.utils.timezone" title="django.utils.timezone: Timezone support."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.utils.timezone</span></code></a> 提供的 <a class="reference internal" href="../ref/utils.html#django.utils.timezone.get_default_timezone" title="django.utils.timezone.get_default_timezone"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.utils.timezone.get_default_timezone()</span></code></a> 和 <a class="reference internal" href="../ref/utils.html#django.utils.timezone.get_fixed_timezone" title="django.utils.timezone.get_fixed_timezone"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.utils.timezone.get_fixed_timezone()</span></code></a>。</p>
</div>
<div class="section" id="s-django-utils-unittest">
<span id="django-utils-unittest"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.unittest</span></code><a class="headerlink" href="#django-utils-unittest" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">django.utils.unittest</span></code> 在所有 Python 版本上提供了对 <code class="docutils literal notranslate"><span class="pre">unittest2</span></code> 库的统一访问。由于 <code class="docutils literal notranslate"><span class="pre">unittest2</span></code> 在 Python 2.7 中成为标准库的 <a class="reference external" href="https://docs.python.org/3/library/unittest.html#module-unittest" title="(在 Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块，并且 Django 1.7 不再支持旧的 Python 版本，因此该模块不再有用。它已被弃用，请改用 <a class="reference external" href="https://docs.python.org/3/library/unittest.html#module-unittest" title="(在 Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>。</p>
</div>
<div class="section" id="s-django-utils-datastructures-sorteddict">
<span id="django-utils-datastructures-sorteddict"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.datastructures.SortedDict</span></code><a class="headerlink" href="#django-utils-datastructures-sorteddict" title="永久链接至标题">¶</a></h3>
<p>由于 Python 2.7 中已经添加了 <a class="reference external" href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> 到标准库中，因此不再需要 <code class="docutils literal notranslate"><span class="pre">SortedDict</span></code>，它已经被弃用。</p>
<p><code class="docutils literal notranslate"><span class="pre">SortedDict</span></code> 提供的两个额外且已弃用的方法（<code class="docutils literal notranslate"><span class="pre">insert()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">value_for_index()</span></code>）已被移除。如果您曾依赖这些方法来更改类似表单字段的结构，现在应将这些 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 视为不可变对象，并重写它们以更改其内容。</p>
<p>例如，您可能希望覆盖 <code class="docutils literal notranslate"><span class="pre">MyFormClass.base_fields</span></code> （尽管该属性不被视为公共 API）以更改所有 <code class="docutils literal notranslate"><span class="pre">MyFormClass</span></code> 实例的字段顺序；或者类似地，您可以在 <code class="docutils literal notranslate"><span class="pre">MyFormClass.__init__()</span></code> 中从内部覆盖 <code class="docutils literal notranslate"><span class="pre">self.fields</span></code>，以更改特定表单实例的字段。例如（来自 Django 自身）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PasswordChangeForm</span><span class="o">.</span><span class="n">base_fields</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
    <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">PasswordChangeForm</span><span class="o">.</span><span class="n">base_fields</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;old_password&quot;</span><span class="p">,</span> <span class="s2">&quot;new_password1&quot;</span><span class="p">,</span> <span class="s2">&quot;new_password2&quot;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-custom-sql-location-for-models-package">
<span id="custom-sql-location-for-models-package"></span><h3>自定义模型包的 SQL 位置<a class="headerlink" href="#custom-sql-location-for-models-package" title="永久链接至标题">¶</a></h3>
<p>以前，如果模型组织在一个包中（<code class="docutils literal notranslate"><span class="pre">myapp/models/</span></code>）而不是简单的 <code class="docutils literal notranslate"><span class="pre">myapp/models.py</span></code>，Django 会在 <code class="docutils literal notranslate"><span class="pre">myapp/models/sql/</span></code> 中查找初始 SQL 数据。这个问题已经被修复，Django 将按文档中的方式搜索 <code class="docutils literal notranslate"><span class="pre">myapp/sql/</span></code>。在解决了这个问题后，添加了迁移，从而废弃了初始 SQL 数据。因此，尽管这个改变仍然存在，但废弃已经不相关，因为整个功能将在 Django 1.9 中被移除。</p>
</div>
<div class="section" id="s-reorganization-of-django-contrib-sites">
<span id="reorganization-of-django-contrib-sites"></span><h3><code class="docutils literal notranslate"><span class="pre">django.contrib.sites</span></code> 的重新组织<a class="headerlink" href="#reorganization-of-django-contrib-sites" title="永久链接至标题">¶</a></h3>
<p>当 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites</span></code> 不在 <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中时，它提供的功能会减少。应用程序加载的重构在这种情况下添加了一些限制。因此，两个对象被移动，旧的位置已被弃用：</p>
<ul class="simple">
<li><a class="reference internal" href="../ref/contrib/sites.html#django.contrib.sites.requests.RequestSite" title="django.contrib.sites.requests.RequestSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">RequestSite</span></code></a> 现在位于 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites.requests</span></code> 中。</li>
<li><a class="reference internal" href="../ref/contrib/sites.html#django.contrib.sites.shortcuts.get_current_site" title="django.contrib.sites.shortcuts.get_current_site"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_current_site()</span></code></a> 现在位于 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites.shortcuts</span></code> 中。</li>
</ul>
</div>
<div class="section" id="s-declared-fieldsets-attribute-on-modeladmin">
<span id="declared-fieldsets-attribute-on-modeladmin"></span><h3><code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">declared_fieldsets</span></code> 属性<a class="headerlink" href="#declared-fieldsets-attribute-on-modeladmin" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ModelAdmin.declared_fieldsets</span></code> 已经被弃用。尽管它是一个私有 API，但它将按照常规的弃用路径进行处理。这个属性主要被一些绕过了 <code class="docutils literal notranslate"><span class="pre">ModelAdmin.get_fieldsets()</span></code> 方法的方法使用，但这被视为一个错误，并已得到解决。</p>
</div>
<div class="section" id="s-reorganization-of-django-contrib-contenttypes">
<span id="reorganization-of-django-contrib-contenttypes"></span><h3><code class="docutils literal notranslate"><span class="pre">django.contrib.contenttypes</span></code> 的重新组织<a class="headerlink" href="#reorganization-of-django-contrib-contenttypes" title="永久链接至标题">¶</a></h3>
<p>由于 <code class="docutils literal notranslate"><span class="pre">django.contrib.contenttypes.generic</span></code> 定义了与管理和模型相关的对象，导入该模块可能会触发意外的副作用。因此，其内容已被拆分为 <a class="reference internal" href="../ref/contrib/contenttypes.html#module-django.contrib.contenttypes" title="django.contrib.contenttypes: Provides generic interface to installed models."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contenttypes</span></code></a> 子模块，并且 <code class="docutils literal notranslate"><span class="pre">django.contrib.contenttypes.generic</span></code> 模块已被弃用：</p>
<ul class="simple">
<li><a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericForeignKey</span></code></a> 和 <a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericRelation</span></code></a> 现在位于 <a class="reference internal" href="../ref/contrib/contenttypes.html#module-django.contrib.contenttypes.fields" title="django.contrib.contenttypes.fields"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fields</span></code></a> 中。</li>
<li><a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.forms.BaseGenericInlineFormSet" title="django.contrib.contenttypes.forms.BaseGenericInlineFormSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseGenericInlineFormSet</span></code></a> 和 <a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.forms.generic_inlineformset_factory" title="django.contrib.contenttypes.forms.generic_inlineformset_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">generic_inlineformset_factory()</span></code></a> 现在位于 <a class="reference internal" href="../ref/contrib/contenttypes.html#module-django.contrib.contenttypes.forms" title="django.contrib.contenttypes.forms"><code class="xref py py-mod docutils literal notranslate"><span class="pre">forms</span></code></a> 中。</li>
<li><a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.admin.GenericInlineModelAdmin" title="django.contrib.contenttypes.admin.GenericInlineModelAdmin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericInlineModelAdmin</span></code></a>、<a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.admin.GenericStackedInline" title="django.contrib.contenttypes.admin.GenericStackedInline"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericStackedInline</span></code></a> 和 <a class="reference internal" href="../ref/contrib/contenttypes.html#django.contrib.contenttypes.admin.GenericTabularInline" title="django.contrib.contenttypes.admin.GenericTabularInline"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericTabularInline</span></code></a> 现在位于 <a class="reference internal" href="../ref/contrib/contenttypes.html#module-django.contrib.contenttypes.admin" title="django.contrib.contenttypes.admin"><code class="xref py py-mod docutils literal notranslate"><span class="pre">admin</span></code></a> 中。</li>
</ul>
</div>
<div class="section" id="s-syncdb">
<span id="syncdb"></span><h3><code class="docutils literal notranslate"><span class="pre">syncdb</span></code><a class="headerlink" href="#syncdb" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">syncdb</span></code> 命令已被弃用，推荐使用新的 <a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> 命令。<code class="docutils literal notranslate"><span class="pre">migrate</span></code> 命令接受与以前的 <code class="docutils literal notranslate"><span class="pre">syncdb</span></code> 相同的参数，还添加了一些额外的参数，因此只需更改调用的名称而不需要做其他更改。</p>
</div>
<div class="section" id="s-util-modules-renamed-to-utils">
<span id="util-modules-renamed-to-utils"></span><h3><code class="docutils literal notranslate"><span class="pre">util</span></code> 模块已重命名为 <code class="docutils literal notranslate"><span class="pre">utils</span></code><a class="headerlink" href="#util-modules-renamed-to-utils" title="永久链接至标题">¶</a></h3>
<p>在 Django 代码库中，以下实例的 <code class="docutils literal notranslate"><span class="pre">util.py</span></code> 已重命名为 <code class="docutils literal notranslate"><span class="pre">utils.py</span></code>，以统一所有 util 和 utils 的引用：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">django.contrib.admin.util</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">django.contrib.gis.db.backends.util</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">django.db.backends.util</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">django.forms.util</span></code></li>
</ul>
</div>
<div class="section" id="s-get-formsets-method-on-modeladmin">
<span id="get-formsets-method-on-modeladmin"></span><h3>在 <code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">get_formsets</span></code> 方法<a class="headerlink" href="#get-formsets-method-on-modeladmin" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ModelAdmin.get_formsets</span></code> 已弃用，推荐使用新的 <a class="reference internal" href="../ref/contrib/admin/index.html#django.contrib.admin.ModelAdmin.get_formsets_with_inlines" title="django.contrib.admin.ModelAdmin.get_formsets_with_inlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_formsets_with_inlines()</span></code></a>，以更好地处理在 <code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 上有选择地显示内联表单的情况。</p>
</div>
<div class="section" id="s-ipaddressfield">
<span id="ipaddressfield"></span><h3><code class="docutils literal notranslate"><span class="pre">IPAddressField</span></code><a class="headerlink" href="#ipaddressfield" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">django.db.models.IPAddressField</span></code> 和 <code class="docutils literal notranslate"><span class="pre">django.forms.IPAddressField</span></code> 字段已弃用，推荐使用 <a class="reference internal" href="../ref/models/fields.html#django.db.models.GenericIPAddressField" title="django.db.models.GenericIPAddressField"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.GenericIPAddressField</span></code></a> 和 <a class="reference internal" href="../ref/forms/fields.html#django.forms.GenericIPAddressField" title="django.forms.GenericIPAddressField"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.forms.GenericIPAddressField</span></code></a>。</p>
</div>
<div class="section" id="s-basememcachedcache-get-memcache-timeout-method">
<span id="basememcachedcache-get-memcache-timeout-method"></span><h3><code class="docutils literal notranslate"><span class="pre">BaseMemcachedCache._get_memcache_timeout</span></code> 方法<a class="headerlink" href="#basememcachedcache-get-memcache-timeout-method" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BaseMemcachedCache._get_memcache_timeout()</span></code> 方法已重命名为 <code class="docutils literal notranslate"><span class="pre">get_backend_timeout()</span></code>。尽管它是一个私有 API，但它将经历正常的弃用过程。</p>
</div>
<div class="section" id="s-natural-key-serialization-options">
<span id="natural-key-serialization-options"></span><h3>自然键序列化选项<a class="headerlink" href="#natural-key-serialization-options" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">--natural</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-n</span></code> 选项对于 <a class="reference internal" href="../ref/django-admin.html#django-admin-dumpdata"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">dumpdata</span></code></a> 已被弃用。请改用 <a class="reference internal" href="../ref/django-admin.html#cmdoption-dumpdata-natural-foreign"><code class="xref std std-option docutils literal notranslate"><span class="pre">dumpdata</span> <span class="pre">--natural-foreign</span></code></a>。</p>
<p>类似地，对于 <code class="docutils literal notranslate"><span class="pre">serializers.serialize()</span></code> 的 <code class="docutils literal notranslate"><span class="pre">use_natural_keys</span></code> 参数已被弃用。请改用 <code class="docutils literal notranslate"><span class="pre">use_natural_foreign_keys</span></code>。</p>
</div>
<div class="section" id="s-merging-of-post-and-get-arguments-into-wsgirequest-request">
<span id="merging-of-post-and-get-arguments-into-wsgirequest-request"></span><h3>将 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 和 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 参数合并到 <code class="docutils literal notranslate"><span class="pre">WSGIRequest.REQUEST</span></code> 中<a class="headerlink" href="#merging-of-post-and-get-arguments-into-wsgirequest-request" title="永久链接至标题">¶</a></h3>
<p>已经强烈建议使用 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 和 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">REQUEST</span></code>，因为前者更加明确。属性 <code class="docutils literal notranslate"><span class="pre">REQUEST</span></code> 已弃用，并将在 Django 1.9 中移除。</p>
</div>
<div class="section" id="s-django-utils-datastructures-mergedict-class">
<span id="django-utils-datastructures-mergedict-class"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.datastructures.MergeDict</span></code> 类<a class="headerlink" href="#django-utils-datastructures-mergedict-class" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">MergeDict</span></code> 主要用于将 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 和 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 参数合并到 <code class="docutils literal notranslate"><span class="pre">WSGIRequest</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">REQUEST</span></code> 属性中。要合并字典，请使用 <code class="docutils literal notranslate"><span class="pre">dict.update()</span></code>。类 <code class="docutils literal notranslate"><span class="pre">MergeDict</span></code> 已被弃用，并将在 Django 1.9 中移除。</p>
</div>
<div class="section" id="s-language-codes-zh-cn-zh-tw-and-fy-nl">
<span id="language-codes-zh-cn-zh-tw-and-fy-nl"></span><h3>语言代码 <code class="docutils literal notranslate"><span class="pre">zh-cn</span></code>、<code class="docutils literal notranslate"><span class="pre">zh-tw</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fy-nl</span></code><a class="headerlink" href="#language-codes-zh-cn-zh-tw-and-fy-nl" title="永久链接至标题">¶</a></h3>
<p>目前用于简体中文的语言代码 <code class="docutils literal notranslate"><span class="pre">zh-cn</span></code>，繁体中文的语言代码 <code class="docutils literal notranslate"><span class="pre">zh-tw</span></code> 和 (西弗里西亚) 弗里西亚语的语言代码 <code class="docutils literal notranslate"><span class="pre">fy-nl</span></code> 已被弃用，应分别替换为语言代码 <code class="docutils literal notranslate"><span class="pre">zh-hans</span></code>，<code class="docutils literal notranslate"><span class="pre">zh-hant</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fy</span></code>。如果您使用这些语言代码，应重命名区域目录并更新您的设置以反映这些更改。弃用的语言代码将在 Django 1.9 中移除。</p>
</div>
<div class="section" id="s-django-utils-functional-memoize-function">
<span id="django-utils-functional-memoize-function"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.functional.memoize</span></code> 函数<a class="headerlink" href="#django-utils-functional-memoize-function" title="永久链接至标题">¶</a></h3>
<p>函数 <code class="docutils literal notranslate"><span class="pre">memoize</span></code> 已被弃用，应替换为 <code class="docutils literal notranslate"><span class="pre">functools.lru_cache</span></code> 装饰器（从 Python 3.2 开始可用）。</p>
<p>Django 在较旧的 Python 版本中附带了这个装饰器的后移版本，并且可以在 <code class="docutils literal notranslate"><span class="pre">django.utils.lru_cache.lru_cache</span></code> 中使用。弃用的函数将在 Django 1.9 中移除。</p>
</div>
<div class="section" id="s-geo-sitemaps">
<span id="geo-sitemaps"></span><h3>地理网站地图<a class="headerlink" href="#geo-sitemaps" title="永久链接至标题">¶</a></h3>
<p>Google 已停止支持 Geo Sitemaps 格式。因此，Django 对 Geo Sitemaps 的支持已被弃用，并将在 Django 1.8 中移除。</p>
</div>
<div class="section" id="s-passing-callable-arguments-to-queryset-methods">
<span id="passing-callable-arguments-to-queryset-methods"></span><h3>将可调用参数传递给查询集方法<a class="headerlink" href="#passing-callable-arguments-to-queryset-methods" title="永久链接至标题">¶</a></h3>
<p>查询集的可调用参数是一个未记录的功能，不可靠。已弃用，并将在 Django 1.9 中移除。</p>
<p>可调用参数在构建查询集时被求值，而不是在查询集被评估时求值，因此与在传递参数之前对其进行求值相比，此功能并没有提供任何好处，并且会导致混淆，使人误以为参数可能在查询时被求值。</p>
</div>
<div class="section" id="s-admin-for-setting">
<span id="admin-for-setting"></span><h3><code class="docutils literal notranslate"><span class="pre">ADMIN_FOR</span></code> 设置<a class="headerlink" href="#admin-for-setting" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ADMIN_FOR</span></code> 功能，是 admindocs 的一部分，已被移除。您可以根据需要从配置中移除此设置。</p>
</div>
<div class="section" id="s-splitdatetimewidget-with-datetimefield">
<span id="splitdatetimewidget-with-datetimefield"></span><h3><code class="docutils literal notranslate"><span class="pre">SplitDateTimeWidget</span></code> 与 <code class="docutils literal notranslate"><span class="pre">DateTimeField</span></code><a class="headerlink" href="#splitdatetimewidget-with-datetimefield" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">SplitDateTimeWidget</span></code> 在 <a class="reference internal" href="../ref/forms/fields.html#django.forms.DateTimeField" title="django.forms.DateTimeField"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTimeField</span></code></a> 上的支持已被弃用，请改用与 <a class="reference internal" href="../ref/forms/fields.html#django.forms.SplitDateTimeField" title="django.forms.SplitDateTimeField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitDateTimeField</span></code></a> 一起使用的 <code class="docutils literal notranslate"><span class="pre">SplitDateTimeWidget</span></code>。</p>
</div>
<div class="section" id="s-validate">
<span id="validate"></span><h3><code class="docutils literal notranslate"><span class="pre">validate</span></code><a class="headerlink" href="#validate" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">validate</span></code> 管理命令已被弃用，推荐使用 <a class="reference internal" href="../ref/django-admin.html#django-admin-check"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">check</span></code></a> 命令。</p>
</div>
<div class="section" id="s-django-core-management-basecommand">
<span id="django-core-management-basecommand"></span><h3><code class="docutils literal notranslate"><span class="pre">django.core.management.BaseCommand</span></code><a class="headerlink" href="#django-core-management-basecommand" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">requires_model_validation</span></code> 已被弃用，改为使用新的 <code class="docutils literal notranslate"><span class="pre">requires_system_checks</span></code> 标志。如果缺少后者标志，则将使用前者标志的值。定义同时 <code class="docutils literal notranslate"><span class="pre">requires_system_checks</span></code> 和 <code class="docutils literal notranslate"><span class="pre">requires_model_validation</span></code> 将导致错误。</p>
<p><code class="docutils literal notranslate"><span class="pre">check()</span></code> 方法取代了旧的 <code class="docutils literal notranslate"><span class="pre">validate()</span></code> 方法。</p>
</div>
<div class="section" id="s-modeladmin-validators">
<span id="modeladmin-validators"></span><h3><code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 验证器<a class="headerlink" href="#modeladmin-validators" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ModelAdmin.validator_class</span></code> 和 <code class="docutils literal notranslate"><span class="pre">default_validator_class</span></code> 属性已被弃用，推荐使用新的 <code class="docutils literal notranslate"><span class="pre">checks_class</span></code> 属性。</p>
<p><code class="docutils literal notranslate"><span class="pre">ModelAdmin.validate()</span></code> 方法已被弃用，推荐使用 <code class="docutils literal notranslate"><span class="pre">ModelAdmin.check()</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">django.contrib.admin.validation</span></code> 模块已被弃用。</p>
</div>
<div class="section" id="s-django-db-backends-databasevalidation-validate-field">
<span id="django-db-backends-databasevalidation-validate-field"></span><h3><code class="docutils literal notranslate"><span class="pre">django.db.backends.DatabaseValidation.validate_field</span></code><a class="headerlink" href="#django-db-backends-databasevalidation-validate-field" title="永久链接至标题">¶</a></h3>
<p>这个方法已被弃用，推荐使用新的 <code class="docutils literal notranslate"><span class="pre">check_field</span></code> 方法。<code class="docutils literal notranslate"><span class="pre">check_field()</span></code> 所需的功能与 <code class="docutils literal notranslate"><span class="pre">validate_field()</span></code> 提供的相同，但输出格式不同。需要这种功能的第三方数据库后端应提供 <code class="docutils literal notranslate"><span class="pre">check_field()</span></code> 的实现。</p>
</div>
<div class="section" id="s-loading-ssi-and-url-template-tags-from-future-library">
<span id="loading-ssi-and-url-template-tags-from-future-library"></span><h3>从 <code class="docutils literal notranslate"><span class="pre">future</span></code> 库加载 <code class="docutils literal notranslate"><span class="pre">ssi</span></code> 和 <code class="docutils literal notranslate"><span class="pre">url</span></code> 模板标签<a class="headerlink" href="#loading-ssi-and-url-template-tags-from-future-library" title="永久链接至标题">¶</a></h3>
<p>Django 1.3 引入了 <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">ssi</span> <span class="pre">from</span> <span class="pre">future</span> <span class="pre">%}</span></code> 和 <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">url</span> <span class="pre">from</span> <span class="pre">future</span> <span class="pre">%}</span></code> 语法，用于前向兼容 <code class="docutils literal notranslate"><span class="pre">ssi</span></code> 和 <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-url"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">url</span></code></a> 模板标签。这个语法现在已被弃用，并将在 Django 1.9 中移除。您可以简单地删除 <code class="docutils literal notranslate"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">...</span> <span class="pre">from</span> <span class="pre">future</span> <span class="pre">%}</span></code> 标签。</p>
</div>
<div class="section" id="s-django-utils-text-javascript-quote">
<span id="django-utils-text-javascript-quote"></span><h3><code class="docutils literal notranslate"><span class="pre">django.utils.text.javascript_quote</span></code><a class="headerlink" href="#django-utils-text-javascript-quote" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">javascript_quote()</span></code> 是一个位于 <code class="docutils literal notranslate"><span class="pre">django.utils.text</span></code> 中的未记录函数。它在 <code class="docutils literal notranslate"><span class="pre">javascript_catalog()</span></code> 视图的内部使用，但该视图的实现已更改为使用 <code class="docutils literal notranslate"><span class="pre">json.dumps()</span></code>。如果您依赖此函数来提供来自不受信任的字符串的安全输出，您应该使用 <code class="docutils literal notranslate"><span class="pre">django.utils.html.escapejs</span></code> 或 <a class="reference internal" href="../ref/templates/builtins.html#std-templatefilter-escapejs"><code class="xref std std-tfilter docutils literal notranslate"><span class="pre">escapejs</span></code></a> 模板过滤器。如果您只需要生成有效的 JavaScript 字符串，可以简单地使用 <code class="docutils literal notranslate"><span class="pre">json.dumps()</span></code>。</p>
</div>
<div class="section" id="s-fix-ampersands-utils-method-and-template-filter">
<span id="fix-ampersands-utils-method-and-template-filter"></span><h3><code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code> 工具方法和模板过滤器<a class="headerlink" href="#fix-ampersands-utils-method-and-template-filter" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">django.utils.html.fix_ampersands</span></code> 方法和 <code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code> 模板过滤器已被弃用，因为 Django 的标准 HTML 转义功能已经处理了 ampersands 的转义。与 <code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code> 结合使用可能会导致重复转义，或者如果输出被视为安全，则存在引入 XSS 漏洞的风险。除了 <code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code>，未记录的调用 <code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code> 的 <code class="docutils literal notranslate"><span class="pre">django.utils.html.clean_html</span></code> 也已被弃用。由于这是一项加速弃用，<code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clean_html</span></code> 将在 Django 1.8 中移除。</p>
</div>
<div class="section" id="s-reorganization-of-database-test-settings">
<span id="reorganization-of-database-test-settings"></span><h3>数据库测试设置的重新组织<a class="headerlink" href="#reorganization-of-database-test-settings" title="永久链接至标题">¶</a></h3>
<p>所有以 <code class="docutils literal notranslate"><span class="pre">TEST_</span></code> 前缀的数据库设置已被弃用，推荐使用数据库设置中的 <a class="reference internal" href="../ref/settings.html#std-setting-DATABASE-TEST"><code class="xref std std-setting docutils literal notranslate"><span class="pre">TEST</span></code></a> 字典中的条目。旧设置将在 Django 1.9 之前受到支持。为了与较旧版本的 Django 向后兼容，您可以定义这两个版本的设置，只要它们匹配即可。</p>
</div>
<div class="section" id="s-fastcgi-support">
<span id="fastcgi-support"></span><h3>FastCGI 支持<a class="headerlink" href="#fastcgi-support" title="永久链接至标题">¶</a></h3>
<p>通过 <code class="docutils literal notranslate"><span class="pre">runfcgi</span></code> 管理命令提供的 FastCGI 支持将在 Django 1.9 中移除。请使用 WSGI 部署您的项目。</p>
</div>
<div class="section" id="s-moved-objects-in-contrib-sites">
<span id="moved-objects-in-contrib-sites"></span><h3><code class="docutils literal notranslate"><span class="pre">contrib.sites</span></code> 中的对象已移动<a class="headerlink" href="#moved-objects-in-contrib-sites" title="永久链接至标题">¶</a></h3>
<p>在应用加载重构后，<code class="docutils literal notranslate"><span class="pre">django.contrib.sites.models</span></code> 中的两个对象需要移动，因为它们在没有安装 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites</span></code> 的情况下必须可用，而无需导入 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites.models</span></code>。从 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites.requests</span></code> 导入 <code class="docutils literal notranslate"><span class="pre">RequestSite</span></code>，从 <code class="docutils literal notranslate"><span class="pre">django.contrib.sites.shortcuts</span></code> 导入 <code class="docutils literal notranslate"><span class="pre">get_current_site()</span></code>。旧的导入位置将在 Django 1.9 之前继续工作。</p>
</div>
<div class="section" id="s-django-forms-forms-get-declared-fields">
<span id="django-forms-forms-get-declared-fields"></span><h3><code class="docutils literal notranslate"><span class="pre">django.forms.forms.get_declared_fields()</span></code><a class="headerlink" href="#django-forms-forms-get-declared-fields" title="永久链接至标题">¶</a></h3>
<p>Django 不再在内部使用此功能。尽管它是一个私有 API，但它将按照正常的弃用周期进行处理。</p>
</div>
<div class="section" id="s-private-query-lookup-apis">
<span id="private-query-lookup-apis"></span><h3>私有查询查找 API<a class="headerlink" href="#private-query-lookup-apis" title="永久链接至标题">¶</a></h3>
<p>私有 API <code class="docutils literal notranslate"><span class="pre">django.db.models.sql.where.WhereNode.make_atom()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">django.db.models.sql.where.Constraint</span></code> 已被弃用，推荐使用新的 <a class="reference internal" href="../ref/models/lookups.html"><span class="doc">自定义查询 API</span></a>。</p>
</div>
</div>
<div class="section" id="s-features-removed-in-1-7">
<span id="s-removed-features-1-7"></span><span id="features-removed-in-1-7"></span><span id="removed-features-1-7"></span><h2>在 1.7 版本中移除的功能<a class="headerlink" href="#features-removed-in-1-7" title="永久链接至标题">¶</a></h2>
<p>这些功能已经完成了它们的弃用周期，并在 Django 1.7 中被移除。有关详细信息，包括如何删除对这些功能的使用，请参阅 <a class="reference internal" href="1.5.html#deprecated-features-1-5"><span class="std std-ref">在 1.5 中被废弃的功能</span></a>。</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">django.utils.simplejson</span></code> 已被移除。</li>
<li><code class="docutils literal notranslate"><span class="pre">django.utils.itercompat.product</span></code> 已被移除。</li>
<li>INSTALLED_APPS 和 TEMPLATE_DIRS 不再自动将纯字符串转换为元组。</li>
<li><a class="reference internal" href="../ref/request-response.html#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a>、<a class="reference internal" href="../ref/template-response.html#django.template.response.SimpleTemplateResponse" title="django.template.response.SimpleTemplateResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleTemplateResponse</span></code></a>、<a class="reference internal" href="../ref/template-response.html#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemplateResponse</span></code></a>、<code class="docutils literal notranslate"><span class="pre">render_to_response()</span></code>、<a class="reference internal" href="../ref/contrib/sitemaps.html#django.contrib.sitemaps.views.index" title="django.contrib.sitemaps.views.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">index()</span></code></a> 和 <a class="reference internal" href="../ref/contrib/sitemaps.html#django.contrib.sitemaps.views.sitemap" title="django.contrib.sitemaps.views.sitemap"><code class="xref py py-func docutils literal notranslate"><span class="pre">sitemap()</span></code></a> 不再接受 <code class="docutils literal notranslate"><span class="pre">mimetype</span></code> 参数。</li>
<li><a class="reference internal" href="../ref/request-response.html#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 如果其内容是一个迭代器，会立即消耗它。</li>
<li><code class="docutils literal notranslate"><span class="pre">AUTH_PROFILE_MODULE</span></code> 设置以及用户模型上的 <code class="docutils literal notranslate"><span class="pre">get_profile()</span></code> 方法已被移除。</li>
<li><code class="docutils literal notranslate"><span class="pre">cleanup</span></code> 管理命令已被移除。</li>
<li><code class="docutils literal notranslate"><span class="pre">daily_cleanup.py</span></code> 脚本已被移除。</li>
<li><a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> 不再具有 <code class="docutils literal notranslate"><span class="pre">depth</span></code> 关键字参数。</li>
<li>从 <a class="reference internal" href="../topics/testing/advanced.html#module-django.test.utils" title="django.test.utils: Helpers to write custom test runners."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.test.utils</span></code></a> 中的 <code class="docutils literal notranslate"><span class="pre">get_warnings_state()</span></code>/<code class="docutils literal notranslate"><span class="pre">restore_warnings_state()</span></code> 函数以及 <a class="reference internal" href="../topics/testing/tools.html#django-testcase-subclasses"><span class="std std-ref">django.test.*TestCase</span></a> 中的 <code class="docutils literal notranslate"><span class="pre">save_warnings_state()</span></code>/ <code class="docutils literal notranslate"><span class="pre">restore_warnings_state()</span></code> 已被移除。</li>
<li><a class="reference internal" href="../topics/auth/default.html#django.contrib.auth.forms.AuthenticationForm" title="django.contrib.auth.forms.AuthenticationForm"><code class="xref py py-class docutils literal notranslate"><span class="pre">AuthenticationForm</span></code></a> 中的 <code class="docutils literal notranslate"><span class="pre">check_for_test_cookie</span></code> 方法已被移除。</li>
<li>支持 base36 编码的用户 ID 的 <code class="docutils literal notranslate"><span class="pre">django.contrib.auth.views.password_reset_confirm()</span></code> 版本（<code class="docutils literal notranslate"><span class="pre">django.contrib.auth.views.password_reset_confirm_uidb36</span></code>）已被移除。</li>
<li><code class="docutils literal notranslate"><span class="pre">django.utils.encoding.StrAndUnicode</span></code> 混合类已被移除。</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Django 1.7 版本发行说明</a><ul>
<li><a class="reference internal" href="#python-compatibility">Python 兼容性</a></li>
<li><a class="reference internal" href="#what-s-new-in-django-1-7">Django 1.7 的新特性包括：</a><ul>
<li><a class="reference internal" href="#schema-migrations">模式迁移</a></li>
<li><a class="reference internal" href="#app-loading-refactor">应用加载重构</a></li>
<li><a class="reference internal" href="#new-method-on-field-subclasses">Field 子类的新方法</a></li>
<li><a class="reference internal" href="#calling-custom-queryset-methods-from-the-manager">从 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 中调用自定义的 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 方法</a></li>
<li><a class="reference internal" href="#using-a-custom-manager-when-traversing-reverse-relations">在遍历反向关系时使用自定义管理器</a></li>
<li><a class="reference internal" href="#new-system-check-framework">新的系统检查框架</a></li>
<li><a class="reference internal" href="#new-prefetch-object-for-advanced-prefetch-related-operations">新的 <code class="docutils literal notranslate"><span class="pre">Prefetch</span></code> 对象用于高级的 <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code> 操作。</a></li>
<li><a class="reference internal" href="#admin-shortcuts-support-time-zones">管理快捷方式支持时区</a></li>
<li><a class="reference internal" href="#using-database-cursors-as-context-managers">使用数据库游标作为上下文管理器</a></li>
<li><a class="reference internal" href="#custom-lookups">自定义查找</a></li>
<li><a class="reference internal" href="#improvements-to-form-error-handling">改进了 <code class="docutils literal notranslate"><span class="pre">Form</span></code> 错误处理</a><ul>
<li><a class="reference internal" href="#form-add-error"><code class="docutils literal notranslate"><span class="pre">Form.add_error()</span></code></a></li>
<li><a class="reference internal" href="#error-metadata">错误元数据</a></li>
<li><a class="reference internal" href="#error-containers-and-backward-compatibility">错误容器和向后兼容性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#minor-features">次要特性</a><ul>
<li><a class="reference internal" href="#django-contrib-admin"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.admin</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-auth"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.auth</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-formtools"><code class="docutils literal notranslate"><span class="pre">django.contrib.formtools</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-gis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.gis</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.messages</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-redirects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.redirects</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-sessions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.sessions</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-sitemaps"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.sitemaps</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-sites"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.sites</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-staticfiles"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.staticfiles</span></code></a></li>
<li><a class="reference internal" href="#django-contrib-syndication"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.syndication</span></code></a></li>
<li><a class="reference internal" href="#cache">缓存</a></li>
<li><a class="reference internal" href="#cross-site-request-forgery">跨站请求伪造（Cross Site Request Forgery，CSRF）</a></li>
<li><a class="reference internal" href="#email">电子邮件</a></li>
<li><a class="reference internal" href="#file-storage">文件存储</a></li>
<li><a class="reference internal" href="#file-uploads">文件上传</a></li>
<li><a class="reference internal" href="#forms">表单</a></li>
<li><a class="reference internal" href="#internationalization">国际化</a></li>
<li><a class="reference internal" href="#management-commands">管理命令</a></li>
<li><a class="reference internal" href="#models">模型</a></li>
<li><a class="reference internal" href="#signals">信号</a></li>
<li><a class="reference internal" href="#templates">模板</a></li>
<li><a class="reference internal" href="#requests-and-responses">请求和响应</a></li>
<li><a class="reference internal" href="#tests">测试</a></li>
<li><a class="reference internal" href="#utilities">实用程序</a></li>
<li><a class="reference internal" href="#validators">验证器</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-incompatible-changes-in-1-7">1.7 版中向后不兼容的变化</a><ul>
<li><a class="reference internal" href="#allow-syncdb-allow-migrate"><code class="docutils literal notranslate"><span class="pre">allow_syncdb</span></code> / <code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code></a></li>
<li><a class="reference internal" href="#initial-data">initial_data</a></li>
<li><a class="reference internal" href="#deconstruct-and-serializability"><code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> 和可序列化性</a></li>
<li><a class="reference internal" href="#app-loading-changes">应用加载的变化</a><ul>
<li><a class="reference internal" href="#start-up-sequence">启动序列</a></li>
<li><a class="reference internal" href="#standalone-scripts">独一无二的脚本</a></li>
<li><a class="reference internal" href="#wsgi-scripts">WSGI 脚本</a></li>
<li><a class="reference internal" href="#app-registry-consistency">应用程序注册表的一致性</a></li>
<li><a class="reference internal" href="#subclassing-appcommand">继承 AppCommand 类</a></li>
<li><a class="reference internal" href="#introspecting-applications">检查应用程序信息</a></li>
</ul>
</li>
<li><a class="reference internal" href="#management-commands-and-order-of-installed-apps">管理命令和 <code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code> 的顺序</a></li>
<li><a class="reference internal" href="#validationerror-constructor-and-internal-storage"><code class="docutils literal notranslate"><span class="pre">ValidationError</span></code> 构造函数和内部存储</a></li>
<li><a class="reference internal" href="#behavior-of-locmemcache-regarding-pickle-errors">关于 <code class="docutils literal notranslate"><span class="pre">LocMemCache</span></code> 对 pickle 错误的行为</a></li>
<li><a class="reference internal" href="#cache-keys-are-now-generated-from-the-request-s-absolute-url">现在缓存键从请求的绝对 URL 生成</a></li>
<li><a class="reference internal" href="#passing-none-to-manager-db-manager">将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 传递给 <code class="docutils literal notranslate"><span class="pre">Manager.db_manager()</span></code></a></li>
<li><a class="reference internal" href="#pytz-may-be-required">可能需要使用 <code class="docutils literal notranslate"><span class="pre">pytz</span></code></a></li>
<li><a class="reference internal" href="#remove-and-clear-methods-of-related-managers">关于相关管理器的 <code class="docutils literal notranslate"><span class="pre">remove()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">clear()</span></code> 方法</a></li>
<li><a class="reference internal" href="#admin-login-redirection-strategy">管理员登录重定向策略</a></li>
<li><a class="reference internal" href="#select-for-update-requires-a-transaction"><code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> 需要在事务中使用</a></li>
<li><a class="reference internal" href="#contrib-middleware-removed-from-default-middleware-classes">Contrib 中间件从默认的 <code class="docutils literal notranslate"><span class="pre">MIDDLEWARE_CLASSES</span></code> 中移除</a></li>
<li><a class="reference internal" href="#miscellaneous">杂项</a></li>
</ul>
</li>
<li><a class="reference internal" href="#features-deprecated-in-1-7">在 1.7 中被废弃的功能</a><ul>
<li><a class="reference internal" href="#django-core-cache-get-cache"><code class="docutils literal notranslate"><span class="pre">django.core.cache.get_cache</span></code></a></li>
<li><a class="reference internal" href="#django-utils-dictconfig-django-utils-importlib"><code class="docutils literal notranslate"><span class="pre">django.utils.dictconfig</span></code>/<code class="docutils literal notranslate"><span class="pre">django.utils.importlib</span></code></a></li>
<li><a class="reference internal" href="#django-utils-module-loading-import-by-path"><code class="docutils literal notranslate"><span class="pre">django.utils.module_loading.import_by_path</span></code></a></li>
<li><a class="reference internal" href="#django-utils-tzinfo"><code class="docutils literal notranslate"><span class="pre">django.utils.tzinfo</span></code></a></li>
<li><a class="reference internal" href="#django-utils-unittest"><code class="docutils literal notranslate"><span class="pre">django.utils.unittest</span></code></a></li>
<li><a class="reference internal" href="#django-utils-datastructures-sorteddict"><code class="docutils literal notranslate"><span class="pre">django.utils.datastructures.SortedDict</span></code></a></li>
<li><a class="reference internal" href="#custom-sql-location-for-models-package">自定义模型包的 SQL 位置</a></li>
<li><a class="reference internal" href="#reorganization-of-django-contrib-sites"><code class="docutils literal notranslate"><span class="pre">django.contrib.sites</span></code> 的重新组织</a></li>
<li><a class="reference internal" href="#declared-fieldsets-attribute-on-modeladmin"><code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">declared_fieldsets</span></code> 属性</a></li>
<li><a class="reference internal" href="#reorganization-of-django-contrib-contenttypes"><code class="docutils literal notranslate"><span class="pre">django.contrib.contenttypes</span></code> 的重新组织</a></li>
<li><a class="reference internal" href="#syncdb"><code class="docutils literal notranslate"><span class="pre">syncdb</span></code></a></li>
<li><a class="reference internal" href="#util-modules-renamed-to-utils"><code class="docutils literal notranslate"><span class="pre">util</span></code> 模块已重命名为 <code class="docutils literal notranslate"><span class="pre">utils</span></code></a></li>
<li><a class="reference internal" href="#get-formsets-method-on-modeladmin">在 <code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 上的 <code class="docutils literal notranslate"><span class="pre">get_formsets</span></code> 方法</a></li>
<li><a class="reference internal" href="#ipaddressfield"><code class="docutils literal notranslate"><span class="pre">IPAddressField</span></code></a></li>
<li><a class="reference internal" href="#basememcachedcache-get-memcache-timeout-method"><code class="docutils literal notranslate"><span class="pre">BaseMemcachedCache._get_memcache_timeout</span></code> 方法</a></li>
<li><a class="reference internal" href="#natural-key-serialization-options">自然键序列化选项</a></li>
<li><a class="reference internal" href="#merging-of-post-and-get-arguments-into-wsgirequest-request">将 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 和 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 参数合并到 <code class="docutils literal notranslate"><span class="pre">WSGIRequest.REQUEST</span></code> 中</a></li>
<li><a class="reference internal" href="#django-utils-datastructures-mergedict-class"><code class="docutils literal notranslate"><span class="pre">django.utils.datastructures.MergeDict</span></code> 类</a></li>
<li><a class="reference internal" href="#language-codes-zh-cn-zh-tw-and-fy-nl">语言代码 <code class="docutils literal notranslate"><span class="pre">zh-cn</span></code>、<code class="docutils literal notranslate"><span class="pre">zh-tw</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fy-nl</span></code></a></li>
<li><a class="reference internal" href="#django-utils-functional-memoize-function"><code class="docutils literal notranslate"><span class="pre">django.utils.functional.memoize</span></code> 函数</a></li>
<li><a class="reference internal" href="#geo-sitemaps">地理网站地图</a></li>
<li><a class="reference internal" href="#passing-callable-arguments-to-queryset-methods">将可调用参数传递给查询集方法</a></li>
<li><a class="reference internal" href="#admin-for-setting"><code class="docutils literal notranslate"><span class="pre">ADMIN_FOR</span></code> 设置</a></li>
<li><a class="reference internal" href="#splitdatetimewidget-with-datetimefield"><code class="docutils literal notranslate"><span class="pre">SplitDateTimeWidget</span></code> 与 <code class="docutils literal notranslate"><span class="pre">DateTimeField</span></code></a></li>
<li><a class="reference internal" href="#validate"><code class="docutils literal notranslate"><span class="pre">validate</span></code></a></li>
<li><a class="reference internal" href="#django-core-management-basecommand"><code class="docutils literal notranslate"><span class="pre">django.core.management.BaseCommand</span></code></a></li>
<li><a class="reference internal" href="#modeladmin-validators"><code class="docutils literal notranslate"><span class="pre">ModelAdmin</span></code> 验证器</a></li>
<li><a class="reference internal" href="#django-db-backends-databasevalidation-validate-field"><code class="docutils literal notranslate"><span class="pre">django.db.backends.DatabaseValidation.validate_field</span></code></a></li>
<li><a class="reference internal" href="#loading-ssi-and-url-template-tags-from-future-library">从 <code class="docutils literal notranslate"><span class="pre">future</span></code> 库加载 <code class="docutils literal notranslate"><span class="pre">ssi</span></code> 和 <code class="docutils literal notranslate"><span class="pre">url</span></code> 模板标签</a></li>
<li><a class="reference internal" href="#django-utils-text-javascript-quote"><code class="docutils literal notranslate"><span class="pre">django.utils.text.javascript_quote</span></code></a></li>
<li><a class="reference internal" href="#fix-ampersands-utils-method-and-template-filter"><code class="docutils literal notranslate"><span class="pre">fix_ampersands</span></code> 工具方法和模板过滤器</a></li>
<li><a class="reference internal" href="#reorganization-of-database-test-settings">数据库测试设置的重新组织</a></li>
<li><a class="reference internal" href="#fastcgi-support">FastCGI 支持</a></li>
<li><a class="reference internal" href="#moved-objects-in-contrib-sites"><code class="docutils literal notranslate"><span class="pre">contrib.sites</span></code> 中的对象已移动</a></li>
<li><a class="reference internal" href="#django-forms-forms-get-declared-fields"><code class="docutils literal notranslate"><span class="pre">django.forms.forms.get_declared_fields()</span></code></a></li>
<li><a class="reference internal" href="#private-query-lookup-apis">私有查询查找 API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#features-removed-in-1-7">在 1.7 版本中移除的功能</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="1.7.1.html"
                          title="上一章">Django 1.7.1 版本发行说明</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="1.6.11.html"
                          title="下一章">Django 1.6.11 版本发行说明</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/releases/1.7.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">2月 21, 2024</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="1.7.1.html" title="Django 1.7.1 版本发行说明">previous</a>
     |
    <a href="index.html" title="发行说明" accesskey="U">up</a>
   |
    <a href="1.6.11.html" title="Django 1.6.11 版本发行说明">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>