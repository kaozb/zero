
<!DOCTYPE html>

<html lang="zh_Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>应用程序 &#8212; Django 5.0.3.dev20240221071519 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="系统检查框架" href="checks.html" />
    <link rel="prev" title="API 参考" href="index.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django 5.0.3.dev20240221071519 文档</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="index.html" title="API 参考">previous</a>
     |
    <a href="index.html" title="API 参考" accesskey="U">up</a>
   |
    <a href="checks.html" title="系统检查框架">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="ref-applications">
            
  <div class="section" id="s-module-django.apps">
<span id="s-applications"></span><span id="module-django.apps"></span><span id="applications"></span><h1>应用程序<a class="headerlink" href="#module-django.apps" title="永久链接至标题">¶</a></h1>
<p>Django 包含一个已安装应用程序的注册表，能够存储配置和内省。它还维护着一个可用的 <a class="reference internal" href="../topics/db/models.html"><span class="doc">模型</span></a> 列表。</p>
<p>这个注册表叫做 <code class="xref py py-attr docutils literal notranslate"><span class="pre">app</span></code>，它在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">django.app</span></code> 中可用：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.apps</span> <span class="kn">import</span> <span class="n">apps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apps</span><span class="o">.</span><span class="n">get_app_config</span><span class="p">(</span><span class="s2">&quot;admin&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">verbose_name</span>
<span class="go">&#39;Administration&#39;</span>
</pre></div>
</div>
<div class="section" id="s-projects-and-applications">
<span id="projects-and-applications"></span><h2>项目和应用程序<a class="headerlink" href="#projects-and-applications" title="永久链接至标题">¶</a></h2>
<p>术语 <strong>项目</strong> 描述了一个 Django 网络应用。项目的 Python 包主要是由一个配置模块定义的，但它通常包含其他东西。例如，当你运行 <code class="docutils literal notranslate"><span class="pre">django-admin</span> <span class="pre">startproject</span> <span class="pre">mysite</span></code> 时，你会得到一个 <code class="docutils literal notranslate"><span class="pre">mysite</span></code> 项目目录，其中包含一个 <code class="docutils literal notranslate"><span class="pre">mysite</span></code> 的 Python 包，其中有 <code class="docutils literal notranslate"><span class="pre">settings.py</span></code>、<code class="docutils literal notranslate"><span class="pre">urls.py</span></code>、<code class="docutils literal notranslate"><span class="pre">asgi.py</span></code> 和 <code class="docutils literal notranslate"><span class="pre">wsgi.py</span></code>。该项目包经常被扩展到包括像辅助工具、CSS 和模板这样的东西，这些东西并不与特定的应用程序相关。</p>
<p>一个 <strong>项目的根目录</strong> （包含 <code class="docutils literal notranslate"><span class="pre">manage.py</span></code> 文件的目录）通常是项目中所有未单独安装的应用程序的容器。</p>
<p>术语 <strong>应用程序</strong> 指的是提供了一些功能的 Python 包。应用程序 <a class="reference internal" href="../intro/reusable-apps.html"><span class="doc">可在多个项目中重用</span></a>。</p>
<p>应用程序包括模型，视图，模板，模板标签，静态文件，URL，中间件等的一些组合。它们通常使用 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 选项加入到项目中，也可以使用其他机制，如 URLconf， <a class="reference internal" href="settings.html#std-setting-MIDDLEWARE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">MIDDLEWARE</span></code></a> 配置或模板继承。</p>
<p>重要的是要理解 Django 应用程序是一组与框架各部分交互的代码。并不存在 <code class="docutils literal notranslate"><span class="pre">Application</span></code> 对象这种东西。但是，在一些地方，Django 需要与已安装的应用进行交互，主要是为了配置，也是为了自省。所以应用注册表为每个安装的应用在一个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 实例中维护元数据。</p>
<p>一个项目包可以自由的作为一个应用程序并包含一些模型等（前提是，需要把它加入 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>）。</p>
</div>
<div class="section" id="s-configuring-applications">
<span id="s-configuring-applications-ref"></span><span id="configuring-applications"></span><span id="configuring-applications-ref"></span><h2>配置应用程序<a class="headerlink" href="#configuring-applications" title="永久链接至标题">¶</a></h2>
<p>要设置一个应用程序，在应用程序中创建一个 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 模块，然后在那里定义一个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 的子类。</p>
<p>当 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中包含一个应用程序模块的点分隔路径时，默认情况下，如果 Django 在 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 子模块中找到一个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类，它就会将该配置用于应用程序。这个行为可以通过设置 <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AppConfig.default</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 来禁止。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 模块包含多个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类，Django 会寻找一个 <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AppConfig.default</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的子类。</p>
<p>如果没有找到 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类，将使用 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 基类。</p>
<p>另外，<a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 也可以包含一个配置类的点分隔路径，以明确地指定它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">...</span><span class="p">,</span>
    <span class="s2">&quot;polls.apps.PollsAppConfig&quot;</span><span class="p">,</span>
    <span class="o">...</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
</div>
<div class="section" id="s-for-application-authors">
<span id="for-application-authors"></span><h3>对于应用程序作者<a class="headerlink" href="#for-application-authors" title="永久链接至标题">¶</a></h3>
<p>如果你正在创建一个名为 “Rock ’n’ roll” 的可插拔应用，那么这边将告诉你将如何为管理后台提供一个合适的名称：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># rock_n_roll/apps.py</span>

<span class="kn">from</span> <span class="nn">django.apps</span> <span class="kn">import</span> <span class="n">AppConfig</span>


<span class="k">class</span> <span class="nc">RockNRollConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;rock_n_roll&quot;</span>
    <span class="n">verbose_name</span> <span class="o">=</span> <span class="s2">&quot;Rock ’n’ roll&quot;</span>
</pre></div>
</div>
<p>当 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 包含 <code class="docutils literal notranslate"><span class="pre">'rock_n_roll'</span></code> 时，<code class="docutils literal notranslate"><span class="pre">RockNRollConfig</span></code> 将自动加载。如果需要防止这种情况发生，可以在类定义中把 <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>你可以提供多个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类来实现不同的行为。要告诉 Django 默认使用哪一个，可以在定义中把 <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。如果你的用户想选择一个非默认的配置，他们必须在他们的 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 配置中用这个类的点分隔路径替换 <code class="docutils literal notranslate"><span class="pre">'rock_n_roll'</span></code>。</p>
<p><a class="reference internal" href="#django.apps.AppConfig.name" title="django.apps.AppConfig.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AppConfig.name</span></code></a> 属性告诉 Django 这个配置适用于哪个应用。你可以定义在 <code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code> API 参考中描述任何其他属性。</p>
<p><a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类可以在任何地方定义。<code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 惯例只是允许 Django 在 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 包含一个应用程序模块的路径而不是一个配置类的路径时自动加载它们。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p>若你在应用的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 中导入了应用注册信息，名称 <code class="docutils literal notranslate"><span class="pre">apps</span></code> 会与子模块 <code class="docutils literal notranslate"><span class="pre">apps</span></code> 冲突。最好的办法是将此段带入移入子模块，再导入它。折中方案是导入后取个别名:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.apps</span> <span class="kn">import</span> <span class="n">apps</span> <span class="k">as</span> <span class="n">django_apps</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-for-application-users">
<span id="for-application-users"></span><h3>对于应用程序使用者<a class="headerlink" href="#for-application-users" title="永久链接至标题">¶</a></h3>
<p>项目中直接使用 “Rock ’n’ roll”，其名字会是 <code class="docutils literal notranslate"><span class="pre">anthology</span></code>，但是你可能期望显示 “Jazz Manouche”，这需要你提供自定义配置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># anthology/apps.py</span>

<span class="kn">from</span> <span class="nn">rock_n_roll.apps</span> <span class="kn">import</span> <span class="n">RockNRollConfig</span>


<span class="k">class</span> <span class="nc">JazzManoucheConfig</span><span class="p">(</span><span class="n">RockNRollConfig</span><span class="p">):</span>
    <span class="n">verbose_name</span> <span class="o">=</span> <span class="s2">&quot;Jazz Manouche&quot;</span>


<span class="c1"># anthology/settings.py</span>

<span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;anthology.apps.JazzManoucheConfig&quot;</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>这个例子显示了位于一个名为 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 的子模块中的特定项目配置类。<a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类可以在任何地方定义。</p>
<p>在这种情况下，<a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 必须包含配置类的点分隔路径，因为它位于应用程序之外，因此无法自动检测。</p>
</div>
</div>
<div class="section" id="s-application-configuration">
<span id="application-configuration"></span><h2>应用程序配置<a class="headerlink" href="#application-configuration" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.apps.AppConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">AppConfig</span></code><a class="headerlink" href="#django.apps.AppConfig" title="永久链接至目标">¶</a></dt>
<dd><p>应用程序配置对象存储了应用的元数据。某些属性可以在 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 的子类中配置。而其它 Django 设置好的配置是只读的。</p>
</dd></dl>

<div class="section" id="s-configurable-attributes">
<span id="configurable-attributes"></span><h3>可配置属性<a class="headerlink" href="#configurable-attributes" title="永久链接至标题">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.name">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">name</span></code><a class="headerlink" href="#django.apps.AppConfig.name" title="永久链接至目标">¶</a></dt>
<dd><p>指向此应用程序的完整的 Python 格式的路径，如 <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin'</span></code>。</p>
<p>此属性定义配置适用的应用程序。每个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类都必须包含此项。</p>
<p>它必须在整个 Django 项目中唯一。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.label">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">label</span></code><a class="headerlink" href="#django.apps.AppConfig.label" title="永久链接至目标">¶</a></dt>
<dd><p>应用程序简称，如 <code class="docutils literal notranslate"><span class="pre">'admin'</span></code></p>
<p>此属性允许在两个应用标签冲突时重命名其中一个的标签名。默认是 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的最后一段。必须是一个有效的 Python 标识符。</p>
<p>它必须在整个 Django 项目中唯一。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.verbose_name">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">verbose_name</span></code><a class="headerlink" href="#django.apps.AppConfig.verbose_name" title="永久链接至目标">¶</a></dt>
<dd><p>应用程序容易被人理解的名称，如 “Administration”。</p>
<p>此属性默认值为 <code class="docutils literal notranslate"><span class="pre">label.title()</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.path">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">path</span></code><a class="headerlink" href="#django.apps.AppConfig.path" title="永久链接至目标">¶</a></dt>
<dd><p>应用目录的文件系统路径，如 <code class="docutils literal notranslate"><span class="pre">'/usr/lib/pythonX.Y/dist-packages/django/contrib/admin'</span></code>。</p>
<p>大多数情况下，Django 能自动检测并设置此属性，但你也能在 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类中申明此属性，显式地重写它。很少情况下要这么做；例如，若应用包是一个拥有多个路径的 <a class="reference internal" href="#namespace-package">命名空间</a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.default">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">default</span></code><a class="headerlink" href="#django.apps.AppConfig.default" title="永久链接至目标">¶</a></dt>
<dd><p>将此属性设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 以防止 Django 自动选择配置类。当 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 只定义了一个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类，但你不想让 Django 默认使用它时，这个属性很有用。</p>
<p>将这个属性设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 来告诉 Django 自动选择一个配置类。当 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 定义了多个 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 子类，而你希望 Django 默认使用其中一个时，这个属性很有用。</p>
<p>默认情况下，这个属性没有设置。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.default_auto_field">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">default_auto_field</span></code><a class="headerlink" href="#django.apps.AppConfig.default_auto_field" title="永久链接至目标">¶</a></dt>
<dd><p>隐式主键类型，用于添加到本应用中的模型。你可以用它来保持 <a class="reference internal" href="models/fields.html#django.db.models.AutoField" title="django.db.models.AutoField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoField</span></code></a> 作为第三方应用的主键类型。</p>
<p>默认情况下，这是 <a class="reference internal" href="settings.html#std-setting-DEFAULT_AUTO_FIELD"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_AUTO_FIELD</span></code></a> 的值。</p>
</dd></dl>

</div>
<div class="section" id="s-read-only-attributes">
<span id="read-only-attributes"></span><h3>只读属性<a class="headerlink" href="#read-only-attributes" title="永久链接至标题">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.module">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">module</span></code><a class="headerlink" href="#django.apps.AppConfig.module" title="永久链接至目标">¶</a></dt>
<dd><p>应用程序的根模块，如 <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'django.contrib.admin'</span> <span class="pre">from</span> <span class="pre">'django/contrib/admin/__init__.py'&gt;</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.AppConfig.models_module">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">models_module</span></code><a class="headerlink" href="#django.apps.AppConfig.models_module" title="永久链接至目标">¶</a></dt>
<dd><p>包含模型的模块，如 <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'django.contrib.admin.models'</span> <span class="pre">from</span> <span class="pre">'django/contrib/admin/models.py'&gt;</span></code>。</p>
<p>应用不包含 <code class="docutils literal notranslate"><span class="pre">models</span></code> 模块时，可能是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。注意，数据库关联的信号，例如 <a class="reference internal" href="signals.html#django.db.models.signals.pre_migrate" title="django.db.models.signals.pre_migrate"><code class="xref py py-data docutils literal notranslate"><span class="pre">pre_migrate</span></code></a> 和 <a class="reference internal" href="signals.html#django.db.models.signals.post_migrate" title="django.db.models.signals.post_migrate"><code class="xref py py-data docutils literal notranslate"><span class="pre">post_migrate</span></code></a> 仅在应用有 <code class="docutils literal notranslate"><span class="pre">models</span></code> 模块时发出。</p>
</dd></dl>

</div>
<div class="section" id="s-methods">
<span id="methods"></span><h3>方法<a class="headerlink" href="#methods" title="永久链接至标题">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="django.apps.AppConfig.get_models">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">get_models</span></code>(<em><span class="n"><span class="pre">include_auto_created</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">include_swapped</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>)<a class="headerlink" href="#django.apps.AppConfig.get_models" title="永久链接至目标">¶</a></dt>
<dd><p>为该应用返回一个可迭代的 <a class="reference internal" href="models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> 类。</p>
<p>要求完整填写应用注册表。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.apps.AppConfig.get_model">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">get_model</span></code>(<em><span class="n"><span class="pre">model_name</span></span></em>, <em><span class="n"><span class="pre">require_ready</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>)<a class="headerlink" href="#django.apps.AppConfig.get_model" title="永久链接至目标">¶</a></dt>
<dd><p>返回给出的 <code class="docutils literal notranslate"><span class="pre">model_name</span></code> 的 <a class="reference internal" href="models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>。 <code class="docutils literal notranslate"><span class="pre">model_name</span></code> 是大小写敏感的。</p>
<p>如果应用程序中不存在此模块，则抛出 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> 异常。</p>
<p>除 <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> 参数为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 的情况下，都必须完整设置注册信息。 <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> 行为与 <a class="reference internal" href="#django.apps.apps.get_model" title="django.apps.apps.get_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apps.get_model()</span></code></a> 一致。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.apps.AppConfig.ready">
<code class="sig-prename descclassname"><span class="pre">AppConfig.</span></code><code class="sig-name descname"><span class="pre">ready</span></code>()<a class="headerlink" href="#django.apps.AppConfig.ready" title="永久链接至目标">¶</a></dt>
<dd><p>子类可以重写此方法来执行类似注册信号的初始化任务。只要注册表被填满就会调用此方法。</p>
<p>虽然你不能在定义 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 类的模型层导入模型，但可以在 <code class="docutils literal notranslate"><span class="pre">ready()</span></code> 中导入，通过 <code class="docutils literal notranslate"><span class="pre">import</span></code> 语句或 <a class="reference internal" href="#django.apps.AppConfig.get_model" title="django.apps.AppConfig.get_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_model()</span></code></a>。</p>
<p>若你正在注册 <a class="reference internal" href="signals.html#module-django.db.models.signals" title="django.db.models.signals: Signals sent by the model system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">model</span> <span class="pre">signals</span></code></a>，你可以通过字符串标签追踪发信者，而不是用模型类。</p>
<p>举例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.apps</span> <span class="kn">import</span> <span class="n">AppConfig</span>
<span class="kn">from</span> <span class="nn">django.db.models.signals</span> <span class="kn">import</span> <span class="n">pre_save</span>


<span class="k">class</span> <span class="nc">RockNRollConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># importing model classes</span>
        <span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">MyModel</span>  <span class="c1"># or...</span>

        <span class="n">MyModel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model</span><span class="p">(</span><span class="s2">&quot;MyModel&quot;</span><span class="p">)</span>

        <span class="c1"># registering signals with the model&#39;s string label</span>
        <span class="n">pre_save</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="s2">&quot;app_label.MyModel&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">尽管可以向上面介绍的那样访问模型类，但是要避免在 <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> 实现中与数据库交互。这包括了那些会通过 <code class="docutils literal notranslate"><span class="pre">django.db.connection</span></code> 执行查询 （<a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>， <a class="reference internal" href="models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>，管理器方法，等等）和原生查询的模型方法。你的 <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> 方法会在每个管理命令初始化阶段被执行。例如，虽然测试数据库的配置与生成环境配置是分开的， <code class="docutils literal notranslate"><span class="pre">manager.py</span> <span class="pre">test</span></code> 仍会对 <strong>生产环境</strong> 数据库执行一些查询操作。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">在普通的初始化进程中， <code class="docutils literal notranslate"><span class="pre">ready</span></code> 方法仅被 Django 调用一次。但在一些特殊情况下，特别是针对已安装应用的测试中，可以会多次调用 <code class="docutils literal notranslate"><span class="pre">ready</span></code>。这种情况下，在 <code class="docutils literal notranslate"><span class="pre">AppConfig</span></code> 类中编写幂等方法或放入一个标志，避免那些只需运行一次的代码被多次执行。</p>
</div>
</dd></dl>

</div>
<div class="section" id="s-namespace-packages-as-apps">
<span id="s-namespace-package"></span><span id="namespace-packages-as-apps"></span><span id="namespace-package"></span><h3>命名空间包作为应用程序<a class="headerlink" href="#namespace-packages-as-apps" title="永久链接至标题">¶</a></h3>
<p>没有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件的 Python 包被称为 “命名空间包”，可以分布在 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 上不同位置的多个目录中（见 <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>）。</p>
<p>Django 应用程序需要一个单一的基础文件系统路径，Django（取决于配置）将在其中搜索模板、静态资产等。因此，只有在以下情况之一为真时，命名空间包才可能是 Django 应用程序：</p>
<ol class="arabic simple">
<li>名称空间包实际上只有一个位置（即不分布在多个目录中）。</li>
<li>用于配置应用的 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 类有一个 <a class="reference internal" href="#django.apps.AppConfig.path" title="django.apps.AppConfig.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 类属性，它是 Django 将作为应用的单一基础路径的绝对目录路径。</li>
</ol>
<p>如果这些条件均不满足的话，Django 将抛出 <a class="reference internal" href="exceptions.html#django.core.exceptions.ImproperlyConfigured" title="django.core.exceptions.ImproperlyConfigured"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImproperlyConfigured</span></code></a> 错误。</p>
</div>
</div>
<div class="section" id="s-application-registry">
<span id="application-registry"></span><h2>应用程序注册表<a class="headerlink" href="#application-registry" title="永久链接至标题">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="django.apps.apps">
<code class="sig-name descname"><span class="pre">apps</span></code><a class="headerlink" href="#django.apps.apps" title="永久链接至目标">¶</a></dt>
<dd><p>应用程序注册表提供以下公共 API。以下未列出的方法被视为私有方法，可能会更改，恕不另行通知。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.apps.apps.ready">
<code class="sig-prename descclassname"><span class="pre">apps.</span></code><code class="sig-name descname"><span class="pre">ready</span></code><a class="headerlink" href="#django.apps.apps.ready" title="永久链接至目标">¶</a></dt>
<dd><p>在注册表完全填充和调用所有 <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AppConfig.ready()</span></code></a> 方法后设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的布尔属性。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.apps.apps.get_app_configs">
<code class="sig-prename descclassname"><span class="pre">apps.</span></code><code class="sig-name descname"><span class="pre">get_app_configs</span></code>()<a class="headerlink" href="#django.apps.apps.get_app_configs" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a> 实例组成的可迭代对象</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.apps.apps.get_app_config">
<code class="sig-prename descclassname"><span class="pre">apps.</span></code><code class="sig-name descname"><span class="pre">get_app_config</span></code>(<em><span class="n"><span class="pre">app_label</span></span></em>)<a class="headerlink" href="#django.apps.apps.get_app_config" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定 <code class="docutils literal notranslate"><span class="pre">app_label</span></code> 的应用程序的 <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppConfig</span></code></a>。如果不存在这样的应用程序，则会引发 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.apps.apps.is_installed">
<code class="sig-prename descclassname"><span class="pre">apps.</span></code><code class="sig-name descname"><span class="pre">is_installed</span></code>(<em><span class="n"><span class="pre">app_name</span></span></em>)<a class="headerlink" href="#django.apps.apps.is_installed" title="永久链接至目标">¶</a></dt>
<dd><p>检查注册表中是否存在给定名称的应用程序。<code class="docutils literal notranslate"><span class="pre">app_name</span></code> 是应用程序的全名，例如 <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin'</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.apps.apps.get_model">
<code class="sig-prename descclassname"><span class="pre">apps.</span></code><code class="sig-name descname"><span class="pre">get_model</span></code>(<em><span class="n"><span class="pre">app_label</span></span></em>, <em><span class="n"><span class="pre">model_name</span></span></em>, <em><span class="n"><span class="pre">require_ready</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>)<a class="headerlink" href="#django.apps.apps.get_model" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> 于给定的 <code class="docutils literal notranslate"><span class="pre">app_label</span></code> 和 <code class="docutils literal notranslate"><span class="pre">model_name</span></code>。作为快捷方式，本方法也接受一个单一参数，形式为 <code class="docutils literal notranslate"><span class="pre">app_label.model_name</span></code>. <code class="docutils literal notranslate"><span class="pre">model_name</span></code> 不区分大小写。</p>
<p>如果不存在这样的应用程序或模型，则引发 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>。当调用的单个参数不包含一个点时，会引发 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>除非 <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> 参数设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，否则要求应用注册表被完全填充。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 允许 <a class="reference internal" href="#app-loading-process"><span class="std std-ref">在应用注册表被填充</span></a> 的时候，特别是在导入模型的第二阶段，查找模型。那么 <code class="docutils literal notranslate"><span class="pre">get_model()</span></code> 就和导入模型的效果一样。主要用例是用设置配置模型类，如  <a class="reference internal" href="settings.html#std-setting-AUTH_USER_MODEL"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTH_USER_MODEL</span></code></a>。</p>
<p>当 <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时，<code class="docutils literal notranslate"><span class="pre">get_model()</span></code> 返回的模型类可能无法完全发挥作用（例如，可能缺少反向访问器），直到应用程序注册表完全填充。因此，最好尽可能将 <code class="docutils literal notranslate"><span class="pre">require_ready</span></code> 改为默认值 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

</div>
<div class="section" id="s-initialization-process">
<span id="s-app-loading-process"></span><span id="initialization-process"></span><span id="app-loading-process"></span><h2>初始化进程<a class="headerlink" href="#initialization-process" title="永久链接至标题">¶</a></h2>
<div class="section" id="s-how-applications-are-loaded">
<span id="how-applications-are-loaded"></span><h3>应用程序是如何被加载的<a class="headerlink" href="#how-applications-are-loaded" title="永久链接至标题">¶</a></h3>
<p>Django 启动后， <a class="reference internal" href="#django.setup" title="django.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.setup()</span></code></a> 负责配置应用注册信息。</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.setup">
<code class="sig-name descname"><span class="pre">setup</span></code>(<em><span class="n"><span class="pre">set_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>)<a class="reference internal" href="../_modules/django.html#setup"><span class="viewcode-link"><span class="pre">[源代码]</span></span></a><a class="headerlink" href="#django.setup" title="永久链接至目标">¶</a></dt>
<dd><p>配置 Django：</p>
<ul class="simple">
<li>加载配置。</li>
<li>设置日志。</li>
<li>若 <code class="docutils literal notranslate"><span class="pre">set_prefix</span></code> 为 True，为 URL 处理器脚本增加前缀 <a class="reference internal" href="settings.html#std-setting-FORCE_SCRIPT_NAME"><code class="xref std std-setting docutils literal notranslate"><span class="pre">FORCE_SCRIPT_NAME</span></code></a>，若未定义此项，则使用 <code class="docutils literal notranslate"><span class="pre">/</span></code>。</li>
<li>初始化应用程序注册。</li>
</ul>
<p>这个函数会被自动调用：</p>
<ul class="simple">
<li>当通过Django的ASGI或WSGI运行HTTP服务时。</li>
<li>调用一个管理命令时。</li>
</ul>
<p>在其他情况下，必须显式调用它，例如在纯 Python 脚本中。</p>
<div class="versionchanged">
<span class="title">Changed in Django 5.0:</span> <p>在应用程序与数据库交互之前，如果应用程序注册表尚未完全填充，则会引发 <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code>。</p>
</div>
</dd></dl>

<p>应用注册的初始化过程分三个阶段完成。在每个阶段，Django 根据应用在 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中的顺序依次处理。</p>
<ol class="arabic">
<li><p class="first">首先，Django 导入 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 中各项条目。</p>
<p>如果是应用配置类，Django 导入应用的根包，由其 <a class="reference internal" href="#django.apps.AppConfig.name" title="django.apps.AppConfig.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> 属性定义。如果是 Python 包，Django 会在 <code class="docutils literal notranslate"><span class="pre">apps.py</span></code> 子模块中寻找应用配置，否则会创建一个默认的应用配置。</p>
<p><em>在这情况下，你的代码不应该导入任何模型！</em></p>
<p>换句话说，应用程序的根包和定义应用程序配置类的模块不能导入任何模型，即使是间接导入。</p>
<p>严格来说，一旦应用配置完成加载后，Django 是允许导入模型。然而为了避免不必要的 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a>, 顺序约束。强烈建议在这个阶段不要导入任何模型。</p>
<p>一旦这个阶段完成，可以使用 API 对应用程序配置（如 <a class="reference internal" href="#django.apps.apps.get_app_config" title="django.apps.apps.get_app_config"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_app_config()</span></code></a> ）进行操作。</p>
</li>
<li><p class="first">然后 Django 会尝试导入每个应用程序的 <code class="docutils literal notranslate"><span class="pre">models</span></code> 子模块，如果有的话。</p>
<p>你必须在你的应用程序的 <code class="docutils literal notranslate"><span class="pre">models.py</span></code> 或 <code class="docutils literal notranslate"><span class="pre">models/__init__.py</span></code> 中定义或导入所有模型。否则，应用程序注册表可能在此时没有完全填充，这可能导致 ORM 失灵。</p>
<p>此步骤完成后，操作模型的 API，例如 <a class="reference internal" href="#django.apps.apps.get_model" title="django.apps.apps.get_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_model()</span></code></a>，就可以使用了。</p>
</li>
<li><p class="first">最后 Django 会运行每个应用配置的 <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ready()</span></code></a> 方法。</p>
</li>
</ol>
</div>
<div class="section" id="s-troubleshooting">
<span id="s-applications-troubleshooting"></span><span id="troubleshooting"></span><span id="applications-troubleshooting"></span><h3>错误调试<a class="headerlink" href="#troubleshooting" title="永久链接至标题">¶</a></h3>
<p>在初始化期间，这里有一些常见的错误你可能会遇上。</p>
<ul>
<li><p class="first"><a class="reference internal" href="exceptions.html#django.core.exceptions.AppRegistryNotReady" title="django.core.exceptions.AppRegistryNotReady"><code class="xref py py-class docutils literal notranslate"><span class="pre">AppRegistryNotReady</span></code></a>。当导入应用程序配置或模型模块触发依赖于应用程序注册表的代码时，会发生这种情况。</p>
<p>例如， <a class="reference internal" href="utils.html#django.utils.translation.gettext" title="django.utils.translation.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a> 使用应用程序注册表来查找应用程序中的翻译目录。要在导入时进行翻译，你需要 <a class="reference internal" href="utils.html#django.utils.translation.gettext_lazy" title="django.utils.translation.gettext_lazy"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext_lazy()</span></code></a> 来代替。（使用 <a class="reference internal" href="utils.html#django.utils.translation.gettext" title="django.utils.translation.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a> 会是一个 bug，因为翻译会在导入时进行，而不是在每次请求时根据活动语言进行。）</p>
<p>在模型模块中导入时用 ORM 执行数据库查询也会触发此异常。在所有模型都可用之前，ORM 无法正常工作。</p>
<p>如果你忘记在一个单独的 Python 脚本中调用函数 django.setup()，也会发生异常。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ImportError:</span> <span class="pre">cannot</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">...</span></code> 如果导入序列陷入循环，就会发生这种情况。</p>
<p>为了消除这些问题，你应该最大限度地减少模型模块之间的依赖关系，并在导入时尽可能减少复杂度。 为了避免在导入时执行代码，可以将其移入函数并缓存结果。 代码将在你首次需要结果时执行。 这个概念被称为“惰性求值”。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">django.contrib.admin</span></code> 会自动在已安装的应用程序中执行 <code class="docutils literal notranslate"><span class="pre">admin</span></code> 模块的自动发现。为了防止这种情况发生，请将你的 <a class="reference internal" href="settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 改为包含 <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin.app.SimpleAdminConfig'</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">'django.contrib.admin'</span></code>。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">RuntimeWarning:</span> <span class="pre">Accessing</span> <span class="pre">the</span> <span class="pre">database</span> <span class="pre">during</span> <span class="pre">app</span> <span class="pre">initialization</span> <span class="pre">is</span> <span class="pre">discouraged.</span></code> 此警告是在应用程序准备好之前执行的数据库查询触发的，例如在模块导入期间或在 <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AppConfig.ready()</span></code></a> 方法中。不鼓励这种过早的数据库查询，因为它们将在每个管理命令的启动期间运行，这会减慢项目的启动速度，可能会缓存过时的数据，甚至可能会在迁移未完成时失败。</p>
<p>例如，一个常见的错误是进行数据库查询以填充表单字段的选择项：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LocationForm</span><span class="p">(</span><span class="n">forms</span><span class="o">.</span><span class="n">Form</span><span class="p">):</span>
    <span class="n">country</span> <span class="o">=</span> <span class="n">forms</span><span class="o">.</span><span class="n">ChoiceField</span><span class="p">(</span><span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Country</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
</pre></div>
</div>
<p>在上面的示例中，来自 <code class="docutils literal notranslate"><span class="pre">Country.objects.all()</span></code> 的查询在模块导入期间执行，因为 <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> 被迭代。为了避免警告，表单可以使用 <a class="reference internal" href="forms/fields.html#django.forms.ModelChoiceField" title="django.forms.ModelChoiceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelChoiceField</span></code></a>，如下所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LocationForm</span><span class="p">(</span><span class="n">forms</span><span class="o">.</span><span class="n">Form</span><span class="p">):</span>
    <span class="n">country</span> <span class="o">=</span> <span class="n">forms</span><span class="o">.</span><span class="n">ModelChoiceField</span><span class="p">(</span><span class="n">queryset</span><span class="o">=</span><span class="n">Country</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>
</div>
<p>为了更容易找到触发此警告的代码，你可以让 Python <a class="reference external" href="https://docs.python.org/3/library/warnings.html#warning-filter" title="(在 Python v3.12)"><span class="xref std std-ref">将警告视为错误</span></a>，以显示堆栈跟踪，例如使用 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-Werror</span> <span class="pre">manage.py</span> <span class="pre">shell</span></code>。</p>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">应用程序</a><ul>
<li><a class="reference internal" href="#projects-and-applications">项目和应用程序</a></li>
<li><a class="reference internal" href="#configuring-applications">配置应用程序</a><ul>
<li><a class="reference internal" href="#for-application-authors">对于应用程序作者</a></li>
<li><a class="reference internal" href="#for-application-users">对于应用程序使用者</a></li>
</ul>
</li>
<li><a class="reference internal" href="#application-configuration">应用程序配置</a><ul>
<li><a class="reference internal" href="#configurable-attributes">可配置属性</a></li>
<li><a class="reference internal" href="#read-only-attributes">只读属性</a></li>
<li><a class="reference internal" href="#methods">方法</a></li>
<li><a class="reference internal" href="#namespace-packages-as-apps">命名空间包作为应用程序</a></li>
</ul>
</li>
<li><a class="reference internal" href="#application-registry">应用程序注册表</a></li>
<li><a class="reference internal" href="#initialization-process">初始化进程</a><ul>
<li><a class="reference internal" href="#how-applications-are-loaded">应用程序是如何被加载的</a></li>
<li><a class="reference internal" href="#troubleshooting">错误调试</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="index.html"
                          title="上一章">API 参考</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="checks.html"
                          title="下一章">系统检查框架</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ref/applications.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">2月 21, 2024</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="index.html" title="API 参考">previous</a>
     |
    <a href="index.html" title="API 参考" accesskey="U">up</a>
   |
    <a href="checks.html" title="系统检查框架">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>