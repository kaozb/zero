
<!DOCTYPE html>

<html lang="zh_Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>请求和响应对象 &#8212; Django 5.0.3.dev20240221071519 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="SchemaEditor" href="schema-editor.html" />
    <link rel="prev" title="分页器" href="paginator.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django 5.0.3.dev20240221071519 文档</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="paginator.html" title="分页器">previous</a>
     |
    <a href="index.html" title="API 参考" accesskey="U">up</a>
   |
    <a href="schema-editor.html" title="&lt;code class=&#34;docutils literal notranslate&#34;&gt;&lt;span class=&#34;pre&#34;&gt;SchemaEditor&lt;/span&gt;&lt;/code&gt;">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="ref-request-response">
            
  <div class="section" id="s-module-django.http">
<span id="s-request-and-response-objects"></span><span id="module-django.http"></span><span id="request-and-response-objects"></span><h1>请求和响应对象<a class="headerlink" href="#module-django.http" title="永久链接至标题">¶</a></h1>
<div class="section" id="s-quick-overview">
<span id="quick-overview"></span><h2>快速概述<a class="headerlink" href="#quick-overview" title="永久链接至标题">¶</a></h2>
<p>Django 使用请求和响应对象在系统中传递状态。</p>
<p>当一个页面被请求时，Django 会创建一个 <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpRequest</span></code></a> 对象，这个对象包含了请求的元数据。然后，Django 加载相应的视图，将 <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpRequest</span></code></a> 作为视图函数的第一个参数。每个视图负责返回一个 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 对象。</p>
<p>本文档解释了 <a class="reference internal" href="#module-django.http" title="django.http: Classes dealing with HTTP requests and responses."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.http</span></code></a> 模块中定义的 <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpRequest</span></code></a> 和 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 对象的 API。</p>
</div>
<div class="section" id="s-httprequest-objects">
<span id="httprequest-objects"></span><h2><code class="docutils literal notranslate"><span class="pre">HttpRequest</span></code> 对象<a class="headerlink" href="#httprequest-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpRequest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpRequest</span></code><a class="headerlink" href="#django.http.HttpRequest" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<div class="section" id="s-attributes">
<span id="s-httprequest-attributes"></span><span id="attributes"></span><span id="httprequest-attributes"></span><h3>属性<a class="headerlink" href="#attributes" title="永久链接至标题">¶</a></h3>
<p>除非另有说明，否则所有属性都应视为只读。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.scheme">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">scheme</span></code><a class="headerlink" href="#django.http.HttpRequest.scheme" title="永久链接至目标">¶</a></dt>
<dd><p>代表请求协议的字符串（通常是 <code class="docutils literal notranslate"><span class="pre">http</span></code> 或 <code class="docutils literal notranslate"><span class="pre">https</span></code>）。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.body">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">body</span></code><a class="headerlink" href="#django.http.HttpRequest.body" title="永久链接至目标">¶</a></dt>
<dd><p>原始的 HTTP 请求体作为一个字节字符串。这对于以不同方式处理非常规 HTML 表单的数据很有用：二进制图像，XML 有效负载等。对于处理传统的表单数据，使用 <a class="reference internal" href="#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpRequest.POST</span></code></a>。</p>
<p>你也可以使用类似文件的接口 <a class="reference internal" href="#django.http.HttpRequest.read" title="django.http.HttpRequest.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HttpRequest.read()</span></code></a> 或 <a class="reference internal" href="#django.http.HttpRequest.readline" title="django.http.HttpRequest.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HttpRequest.readline()</span></code></a> 从 <code class="docutils literal notranslate"><span class="pre">HttpRequest</span></code> 中读取。在使用这些 I/O 流方法中的任何一种方法读取请求后，访问 <code class="docutils literal notranslate"><span class="pre">body</span></code> 属性会产生 <code class="docutils literal notranslate"><span class="pre">RawPostDataException</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.path">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">path</span></code><a class="headerlink" href="#django.http.HttpRequest.path" title="永久链接至目标">¶</a></dt>
<dd><p>一个表示请求页面的完整路径的字符串，不包括 scheme、域名或查询字符串。</p>
<p>例如：<code class="docutils literal notranslate"><span class="pre">&quot;/music/bands/the_beatles/&quot;</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.path_info">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">path_info</span></code><a class="headerlink" href="#django.http.HttpRequest.path_info" title="永久链接至目标">¶</a></dt>
<dd><p>在某些 Web 服务器配置下，主机名后面的 URL 部分被分成脚本前缀部分和路径信息部分。无论使用哪个 Web 服务器，<code class="docutils literal notranslate"><span class="pre">path_info</span></code> 属性始终包含路径信息部分。使用这个属性而不是 <a class="reference internal" href="#django.http.HttpRequest.path" title="django.http.HttpRequest.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 可以使您的代码更容易在测试和部署服务器之间移动。</p>
<p>例如，如果你的应用程序的 <code class="docutils literal notranslate"><span class="pre">WSGIScriptAlias</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">&quot;/minfo&quot;</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">path</span></code> 可能是 <code class="docutils literal notranslate"><span class="pre">&quot;/minfo/music/bands/the_beatles/&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">path_info</span></code> 将是 <code class="docutils literal notranslate"><span class="pre">&quot;/music/bands/the_beatles/&quot;</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.method">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">method</span></code><a class="headerlink" href="#django.http.HttpRequest.method" title="永久链接至目标">¶</a></dt>
<dd><p>代表请求中使用的 HTTP 方法的字符串。保证是大写字母。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;GET&quot;</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;POST&quot;</span><span class="p">:</span>
    <span class="n">do_something_else</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.encoding">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">encoding</span></code><a class="headerlink" href="#django.http.HttpRequest.encoding" title="永久链接至目标">¶</a></dt>
<dd><p>表示当前用于解码表单提交数据的编码的字符串（或 <code class="docutils literal notranslate"><span class="pre">None</span></code>，表示使用 <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_CHARSET</span></code></a> 设置）。你可以写入这个属性来改变访问表单数据时使用的编码。任何后续的属性访问（如从 <a class="reference internal" href="#django.http.HttpRequest.GET" title="django.http.HttpRequest.GET"><code class="xref py py-attr docutils literal notranslate"><span class="pre">GET</span></code></a> 或 <a class="reference internal" href="#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code class="xref py py-attr docutils literal notranslate"><span class="pre">POST</span></code></a> 中读取）将使用新的 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> 值。如果你知道表单数据不是在 <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_CHARSET</span></code></a> 编码中，这很有用。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.content_type">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">content_type</span></code><a class="headerlink" href="#django.http.HttpRequest.content_type" title="永久链接至目标">¶</a></dt>
<dd><p>代表请求的 MIME 类型的字符串，从 <code class="docutils literal notranslate"><span class="pre">CONTENT_TYPE</span></code> 头解析。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.content_params">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">content_params</span></code><a class="headerlink" href="#django.http.HttpRequest.content_params" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">CONTENT_TYPE</span></code> 头中包含的键／值参数字典。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.GET">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">GET</span></code><a class="headerlink" href="#django.http.HttpRequest.GET" title="永久链接至目标">¶</a></dt>
<dd><p>一个类似字典的对象，包含所有给定的 HTTP GET 参数。参见下面的 <a class="reference internal" href="#django.http.QueryDict" title="django.http.QueryDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryDict</span></code></a> 文档。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.POST">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">POST</span></code><a class="headerlink" href="#django.http.HttpRequest.POST" title="永久链接至目标">¶</a></dt>
<dd><p>一个类似字典的对象，包含所有给定的 HTTP POST 参数，前提是请求包含表单数据。参见下面的 <a class="reference internal" href="#django.http.QueryDict" title="django.http.QueryDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryDict</span></code></a> 文档。如果你需要访问请求中发布的原始或非表单数据，可以通过 <a class="reference internal" href="#django.http.HttpRequest.body" title="django.http.HttpRequest.body"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpRequest.body</span></code></a> 属性来访问。</p>
<p>有可能一个请求是通过 POST 方式进来的，并带有一个空的 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 字典——比如说，一个表单是通过 POST HTTP 方法请求的，但不包括表单数据。因此，你不应该使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">request.POST</span></code> 来检查是否使用了 POST 方法；而应该使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">request.method</span> <span class="pre">==</span> <span class="pre">&quot;POST&quot;</span></code> （参见 <a class="reference internal" href="#django.http.HttpRequest.method" title="django.http.HttpRequest.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpRequest.method</span></code></a>）。</p>
<p><code class="docutils literal notranslate"><span class="pre">POST</span></code> 不包括文件上传信息。见 <a class="reference internal" href="#django.http.HttpRequest.FILES" title="django.http.HttpRequest.FILES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FILES</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.COOKIES">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">COOKIES</span></code><a class="headerlink" href="#django.http.HttpRequest.COOKIES" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含所有 cookies 的字典。键和值是字符串。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.FILES">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">FILES</span></code><a class="headerlink" href="#django.http.HttpRequest.FILES" title="永久链接至目标">¶</a></dt>
<dd><p>一个类似字典的对象，包含所有上传的文件。<code class="docutils literal notranslate"><span class="pre">FILES</span></code> 中的每个键是 <code class="docutils literal notranslate"><span class="pre">&lt;input</span> <span class="pre">type=&quot;file&quot;</span> <span class="pre">name=&quot;&quot;&gt;</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">name</span></code>。<code class="docutils literal notranslate"><span class="pre">FILES</span></code> 中的每个值是一个 <a class="reference internal" href="files/uploads.html#django.core.files.uploadedfile.UploadedFile" title="django.core.files.uploadedfile.UploadedFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">UploadedFile</span></code></a>。</p>
<p>更多信息请参见 <a class="reference internal" href="../topics/files.html"><span class="doc">管理文件</span></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">FILES</span></code> 只有在请求方法是 POST，并且发布请求的 <code class="docutils literal notranslate"><span class="pre">&lt;form&gt;</span></code> 有 <code class="docutils literal notranslate"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></code> 的情况下，才会包含数据。否则，<code class="docutils literal notranslate"><span class="pre">FILES</span></code> 将是一个类似字典的空白对象。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.META">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">META</span></code><a class="headerlink" href="#django.http.HttpRequest.META" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含所有可用的 HTTP 头文件的字典。可用的头信息取决于客户端和服务器，但这里有一些例子：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">CONTENT_LENGTH</span></code> —— 请求体的长度（字符串）。</li>
<li><code class="docutils literal notranslate"><span class="pre">CONTENT_TYPE</span></code> —— 请求体的 MIME 类型。</li>
<li><code class="docutils literal notranslate"><span class="pre">HTTP_ACCEPT</span></code> —— 可接受的响应内容类型。</li>
<li><code class="docutils literal notranslate"><span class="pre">HTTP_ACCEPT_ENCODING</span></code> —— 可接受的响应编码。</li>
<li><code class="docutils literal notranslate"><span class="pre">HTTP_ACCEPT_LANGUAGE</span></code> —— 可接受的响应语言。</li>
<li><code class="docutils literal notranslate"><span class="pre">HTTP_HOST</span></code> —— 客户端发送的 HTTP 主机头。</li>
<li><code class="docutils literal notranslate"><span class="pre">HTTP_REFERER</span></code> —— referrer 页面，如果有的话。</li>
<li><code class="docutils literal notranslate"><span class="pre">HTTP_USER_AGENT</span></code> —— 客户端的用户代理字符串。</li>
<li><code class="docutils literal notranslate"><span class="pre">QUERY_STRING</span></code> —— 查询字符串，是一个单一的（未解析的）字符串。</li>
<li><code class="docutils literal notranslate"><span class="pre">REMOTE_ADDR</span></code> —— 客户机的 IP 地址。</li>
<li><code class="docutils literal notranslate"><span class="pre">REMOTE_HOST</span></code> —— 客户机的主机名。</li>
<li><code class="docutils literal notranslate"><span class="pre">REMOTE_USER</span></code> -- 如果有的话，由 Web 服务器进行身份验证的用户。</li>
<li><code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code> —— <code class="docutils literal notranslate"><span class="pre">&quot;GET&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;POST&quot;</span></code> 等字符串。</li>
<li><code class="docutils literal notranslate"><span class="pre">SERVER_NAME</span></code> —— 服务器的主机名。</li>
<li><code class="docutils literal notranslate"><span class="pre">SERVER_PORT</span></code> —— 服务器的端口（字符串）。</li>
</ul>
<p>除了上面给出的 <code class="docutils literal notranslate"><span class="pre">CONTENT_LENGTH</span></code> 和 <code class="docutils literal notranslate"><span class="pre">CONTENT_TYPE</span></code> 之外，请求中的任何 HTTP 头都会被转换为 <code class="docutils literal notranslate"><span class="pre">META</span></code> 键，方法是将所有字符转换为大写字母，用下划线代替任何连字符，并在名称前加上 <code class="docutils literal notranslate"><span class="pre">HTTP_`</span></code> 前缀。因此，例如，一个名为 <code class="docutils literal notranslate"><span class="pre">X-Bender</span></code> 的头将被映射到 <code class="docutils literal notranslate"><span class="pre">META</span></code> 键 <code class="docutils literal notranslate"><span class="pre">HTTP_X_BENDER</span></code>。</p>
<p>请注意，<a class="reference internal" href="django-admin.html#django-admin-runserver"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">runserver</span></code></a> 会删除名称中带有下划线的所有标头，因此您不会在 <code class="docutils literal notranslate"><span class="pre">META</span></code> 中看到它们。这可以防止基于下划线和破折号之间的模糊性而进行标头欺骗，因为在 WSGI 环境变量中，它们都会被规范化为下划线。这与像 Nginx 和 Apache 2.4+ 这样的 Web 服务器的行为相匹配。</p>
<p><a class="reference internal" href="#django.http.HttpRequest.headers" title="django.http.HttpRequest.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpRequest.headers</span></code></a> 是一种更简单的方式来访问所有 HTTP 前缀头，加上 <code class="docutils literal notranslate"><span class="pre">CONTENT_LENGTH</span></code> 和 <code class="docutils literal notranslate"><span class="pre">CONTENT_TYPE</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.headers">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">headers</span></code><a class="headerlink" href="#django.http.HttpRequest.headers" title="永久链接至目标">¶</a></dt>
<dd><p>一个不区分大小写的类似字典的对象，提供对请求中所有 HTTP 前缀头的访问（加上 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code>）。</p>
<p>每个标头的名称在显示时以标题大小写形式呈现（例如，<code class="docutils literal notranslate"><span class="pre">User-Agent</span></code>）。您可以不区分大小写地访问标头：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">headers</span>
<span class="go">{&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6&#39;, ...}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;User-Agent&quot;</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;user-agent&quot;</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s2">&quot;User-Agent&quot;</span><span class="p">]</span>
<span class="go">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s2">&quot;user-agent&quot;</span><span class="p">]</span>
<span class="go">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;User-Agent&quot;</span><span class="p">)</span>
<span class="go">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;user-agent&quot;</span><span class="p">)</span>
<span class="go">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)</span>
</pre></div>
</div>
<p>例如，在 Django 模板中，还可以使用下划线代替连字符来查找标头：</p>
<div class="highlight-html+django notranslate"><div class="highlight"><pre><span></span><span class="cp">{{</span> <span class="nv">request.headers.user_agent</span> <span class="cp">}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.resolver_match">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">resolver_match</span></code><a class="headerlink" href="#django.http.HttpRequest.resolver_match" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="urlresolvers.html#django.urls.ResolverMatch" title="django.urls.ResolverMatch"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResolverMatch</span></code></a> 的一个实例，代表解析后的 URL。这个属性只有在 UR L解析发生后才会被设置，这意味着它在所有的视图中都是可用的，但在 URL 解析发生前被执行的中间件中则不可用（不过你可以在 <a class="reference internal" href="../topics/http/middleware.html#process_view" title="process_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_view()</span></code></a> 中使用它）。</p>
</dd></dl>

</div>
<div class="section" id="s-attributes-set-by-application-code">
<span id="attributes-set-by-application-code"></span><h3>应用程序代码设置的属性<a class="headerlink" href="#attributes-set-by-application-code" title="永久链接至标题">¶</a></h3>
<p>Django 不会自己设置这些属性，但如果你的应用程序设置了这些属性，就会使用它们。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.current_app">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">current_app</span></code><a class="headerlink" href="#django.http.HttpRequest.current_app" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="templates/builtins.html#std-templatetag-url"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">url</span></code></a> 模板标签将使用它的值作为 <a class="reference internal" href="urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">reverse()</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">current_app</span></code> 参数。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.urlconf">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">urlconf</span></code><a class="headerlink" href="#django.http.HttpRequest.urlconf" title="永久链接至目标">¶</a></dt>
<dd><p>这将作为当前请求的根 URLconf，覆盖 <a class="reference internal" href="settings.html#std-setting-ROOT_URLCONF"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ROOT_URLCONF</span></code></a> 设置。详情请参见 <a class="reference internal" href="../topics/http/urls.html#how-django-processes-a-request"><span class="std std-ref">Django 如何处理一个请求</span></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">urlconf</span></code> 可以设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，以恢复之前中间件所做的任何更改，并返回到使用 <a class="reference internal" href="settings.html#std-setting-ROOT_URLCONF"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ROOT_URLCONF</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.exception_reporter_filter">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">exception_reporter_filter</span></code><a class="headerlink" href="#django.http.HttpRequest.exception_reporter_filter" title="永久链接至目标">¶</a></dt>
<dd><p>这将代替当前请求的 <a class="reference internal" href="settings.html#std-setting-DEFAULT_EXCEPTION_REPORTER_FILTER"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_EXCEPTION_REPORTER_FILTER</span></code></a> 使用。详情请参见 <a class="reference internal" href="../howto/error-reporting.html#custom-error-reports"><span class="std std-ref">自定义错误报告</span></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.exception_reporter_class">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">exception_reporter_class</span></code><a class="headerlink" href="#django.http.HttpRequest.exception_reporter_class" title="永久链接至目标">¶</a></dt>
<dd><p>这将代替 <a class="reference internal" href="settings.html#std-setting-DEFAULT_EXCEPTION_REPORTER"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_EXCEPTION_REPORTER</span></code></a> 用于当前请求。详情请参见 <a class="reference internal" href="../howto/error-reporting.html#custom-error-reports"><span class="std std-ref">自定义错误报告</span></a>。</p>
</dd></dl>

</div>
<div class="section" id="s-attributes-set-by-middleware">
<span id="attributes-set-by-middleware"></span><h3>中间件设置的属性<a class="headerlink" href="#attributes-set-by-middleware" title="永久链接至标题">¶</a></h3>
<p>Django 的 contrib 应用中包含的一些中间件会在请求中设置属性。如果你没有在请求中看到属性，请确认在 <a class="reference internal" href="settings.html#std-setting-MIDDLEWARE"><code class="xref std std-setting docutils literal notranslate"><span class="pre">MIDDLEWARE</span></code></a> 中列出了相应的中间件类。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.session">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">session</span></code><a class="headerlink" href="#django.http.HttpRequest.session" title="永久链接至目标">¶</a></dt>
<dd><p>来自 <code class="xref py py-class docutils literal notranslate"><span class="pre">SessionMiddleware</span></code>。一个可读可写的，类似字典的对象，代表当前会话。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.site">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">site</span></code><a class="headerlink" href="#django.http.HttpRequest.site" title="永久链接至目标">¶</a></dt>
<dd><p>来自 <a class="reference internal" href="middleware.html#django.contrib.sites.middleware.CurrentSiteMiddleware" title="django.contrib.sites.middleware.CurrentSiteMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">CurrentSiteMiddleware</span></code></a>。由 <a class="reference internal" href="contrib/sites.html#django.contrib.sites.models.Site" title="django.contrib.sites.models.Site"><code class="xref py py-func docutils literal notranslate"><span class="pre">Site()</span></code></a> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">RequestSite</span></code> 返回的 <a class="reference internal" href="contrib/sites.html#django.contrib.sites.shortcuts.get_current_site" title="django.contrib.sites.shortcuts.get_current_site"><code class="xref py py-class docutils literal notranslate"><span class="pre">get_current_site()</span></code></a> 的实例，代表当前站点。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpRequest.user">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">user</span></code><a class="headerlink" href="#django.http.HttpRequest.user" title="永久链接至目标">¶</a></dt>
<dd><p>从 <code class="xref py py-class docutils literal notranslate"><span class="pre">AuthenticationMiddleware</span></code>。<a class="reference internal" href="settings.html#std-setting-AUTH_USER_MODEL"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTH_USER_MODEL</span></code></a> 的一个实例，代表当前登录的用户。如果用户当前没有登录，<code class="docutils literal notranslate"><span class="pre">user</span></code> 将被设置为一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">AnonymousUser</span></code> 的实例。你可以用 <a class="reference internal" href="contrib/auth.html#django.contrib.auth.models.User.is_authenticated" title="django.contrib.auth.models.User.is_authenticated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_authenticated</span></code></a> 来区分它们，比如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">is_authenticated</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Do something for logged-in users.</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Do something for anonymous users.</span>
</pre></div>
</div>
<p><a class="reference internal" href="#django.http.HttpRequest.auser" title="django.http.HttpRequest.auser"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auser()</span></code></a> 方法执行相同的操作，但可以从异步上下文中使用。</p>
</dd></dl>

</div>
<div class="section" id="s-methods">
<span id="methods"></span><h3>方法<a class="headerlink" href="#methods" title="永久链接至标题">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.auser">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">auser</span></code>()<a class="headerlink" href="#django.http.HttpRequest.auser" title="永久链接至目标">¶</a></dt>
<dd><div class="versionadded">
<span class="title">New in Django 5.0.</span> </div>
<p>从 <a class="reference internal" href="middleware.html#django.contrib.auth.middleware.AuthenticationMiddleware" title="django.contrib.auth.middleware.AuthenticationMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">AuthenticationMiddleware</span></code></a> 中的协程。返回一个表示当前已登录用户的 <a class="reference internal" href="settings.html#std-setting-AUTH_USER_MODEL"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTH_USER_MODEL</span></code></a> 实例。如果用户当前未登录，<code class="docutils literal notranslate"><span class="pre">auser</span></code> 将返回 <a class="reference internal" href="contrib/auth.html#django.contrib.auth.models.AnonymousUser" title="django.contrib.auth.models.AnonymousUser"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnonymousUser</span></code></a> 的实例。这类似于 <a class="reference internal" href="#django.http.HttpRequest.user" title="django.http.HttpRequest.user"><code class="xref py py-attr docutils literal notranslate"><span class="pre">user</span></code></a> 属性，但它在异步上下文中工作。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.get_host">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">get_host</span></code>()<a class="headerlink" href="#django.http.HttpRequest.get_host" title="永久链接至目标">¶</a></dt>
<dd><p>使用 <code class="docutils literal notranslate"><span class="pre">HTTP_X_FORWARDED_HOST</span></code> （如果 <a class="reference internal" href="settings.html#std-setting-USE_X_FORWARDED_HOST"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_X_FORWARDED_HOST</span></code></a> 已启用）和 <code class="docutils literal notranslate"><span class="pre">HTTP_HOST</span></code> 头信息，按顺序返回请求的发起主机。如果它们没有提供一个值，则该方法使用 <code class="docutils literal notranslate"><span class="pre">SERVER_NAME</span></code> 和 <code class="docutils literal notranslate"><span class="pre">SERVER_PORT</span></code> 的组合，详见 <span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-3333/"><strong>PEP 3333</strong></a>。</p>
<p>例如：<code class="docutils literal notranslate"><span class="pre">&quot;127.0.0.1:8000&quot;</span></code></p>
<p>如果主机不在 <a class="reference internal" href="settings.html#std-setting-ALLOWED_HOSTS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ALLOWED_HOSTS</span></code></a> 中或者域名根据 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1034.html"><strong>RFC 1034</strong></a>/<span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1035.html"><strong>RFC 1035</strong></a> 无效，则引发 <code class="docutils literal notranslate"><span class="pre">django.core.exceptions.DisallowedHost</span></code> 异常。</p>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p><a class="reference internal" href="#django.http.HttpRequest.get_host" title="django.http.HttpRequest.get_host"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_host()</span></code></a> 方法在主机处于多个代理后面时失效。一个解决方案是使用中间件重写代理头，如下面的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MultipleProxyMiddleware</span><span class="p">:</span>
    <span class="n">FORWARDED_FOR_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;HTTP_X_FORWARDED_FOR&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HTTP_X_FORWARDED_HOST&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HTTP_X_FORWARDED_SERVER&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_response</span> <span class="o">=</span> <span class="n">get_response</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewrites the proxy headers so that only the most</span>
<span class="sd">        recent proxy is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORWARDED_FOR_FIELDS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">[</span><span class="n">field</span><span class="p">]:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                    <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_response</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">这个中间件应该定位在任何其他依赖于:meth:~HttpRequest.get_host() 值的中间件之前——例如 <a class="reference internal" href="middleware.html#django.middleware.common.CommonMiddleware" title="django.middleware.common.CommonMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommonMiddleware</span></code></a> 或 <a class="reference internal" href="middleware.html#django.middleware.csrf.CsrfViewMiddleware" title="django.middleware.csrf.CsrfViewMiddleware"><code class="xref py py-class docutils literal notranslate"><span class="pre">CsrfViewMiddleware</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.get_port">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">get_port</span></code>()<a class="headerlink" href="#django.http.HttpRequest.get_port" title="永久链接至目标">¶</a></dt>
<dd><p>使用 <code class="docutils literal notranslate"><span class="pre">HTTP_X_FORWARDED_PORT</span></code> （如果 <a href="#id1"><span class="problematic" id="id2">:set:`USE_X_FORWARDED_PORT`</span></a> 已启用）和 <code class="docutils literal notranslate"><span class="pre">SERVER_PORT</span></code> <code class="docutils literal notranslate"><span class="pre">META</span></code> 变量中的信息，按顺序返回请求的起始端口。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.get_full_path">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">get_full_path</span></code>()<a class="headerlink" href="#django.http.HttpRequest.get_full_path" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">path</span></code>，加上附加的查询字符串（如果适用）。</p>
<p>例如：<code class="docutils literal notranslate"><span class="pre">&quot;/music/bands/the_beatles/?print=true&quot;</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.get_full_path_info">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">get_full_path_info</span></code>()<a class="headerlink" href="#django.http.HttpRequest.get_full_path_info" title="永久链接至目标">¶</a></dt>
<dd><p>像 <a class="reference internal" href="#django.http.HttpRequest.get_full_path" title="django.http.HttpRequest.get_full_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_full_path()</span></code></a> 一样，但使用 <a class="reference internal" href="#django.http.HttpRequest.path_info" title="django.http.HttpRequest.path_info"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path_info</span></code></a> 代替 <a class="reference internal" href="#django.http.HttpRequest.path" title="django.http.HttpRequest.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>。</p>
<p>例如：<code class="docutils literal notranslate"><span class="pre">&quot;/minfo/music/bands/the_beatles/?print=true&quot;</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.build_absolute_uri">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">build_absolute_uri</span></code>(<em><span class="n"><span class="pre">location</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpRequest.build_absolute_uri" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">location</span></code> 的绝对 URI 形式。如果没有提供 location，location 将被设置为 <code class="docutils literal notranslate"><span class="pre">request.get_full_path()</span></code>。</p>
<p>如果 location 已经是一个绝对 URI，它将不会被改变。否则，绝对 URI 将使用这个请求中可用的服务器变量建立。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">build_absolute_uri</span><span class="p">()</span>
<span class="go">&#39;https://example.com/music/bands/the_beatles/?print=true&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">build_absolute_uri</span><span class="p">(</span><span class="s2">&quot;/bands/&quot;</span><span class="p">)</span>
<span class="go">&#39;https://example.com/bands/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">build_absolute_uri</span><span class="p">(</span><span class="s2">&quot;https://example2.com/bands/&quot;</span><span class="p">)</span>
<span class="go">&#39;https://example2.com/bands/&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">在同一站点上混合使用 HTTP 和 HTTPS 是不鼓励的，因此 <a class="reference internal" href="#django.http.HttpRequest.build_absolute_uri" title="django.http.HttpRequest.build_absolute_uri"><code class="xref py py-meth docutils literal notranslate"><span class="pre">build_absolute_uri()</span></code></a> 将始终生成与当前请求具有相同协议的绝对 URI。如果您需要将用户重定向到 HTTPS，请最好让您的 Web 服务器将所有 HTTP 流量重定向到 HTTPS。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.get_signed_cookie">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">get_signed_cookie</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">RAISE_ERROR</span></span></em>, <em><span class="n"><span class="pre">salt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em><span class="n"><span class="pre">max_age</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpRequest.get_signed_cookie" title="永久链接至目标">¶</a></dt>
<dd><p>返回已签名 cookie 的 cookie 值，如果签名不再有效，则会引发 <code class="docutils literal notranslate"><span class="pre">django.core.signing.BadSignature</span></code> 异常。如果你提供了 <code class="docutils literal notranslate"><span class="pre">default</span></code> 参数，异常将被抑制，并返回默认值。</p>
<p>可选的 <code class="docutils literal notranslate"><span class="pre">salt</span></code> 参数可以用来提供额外的保护，以防止对你秘钥的暴力攻击。如果提供了这个参数，<code class="docutils literal notranslate"><span class="pre">max_age</span></code> 参数将根据附加在 cookie 值上的签名时间戳进行检查，以确保 cookie 不超过 <code class="docutils literal notranslate"><span class="pre">max_age</span></code> 秒。</p>
<p>例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
<span class="go">&#39;Tony&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">salt</span><span class="o">=</span><span class="s2">&quot;name-salt&quot;</span><span class="p">)</span>
<span class="go">&#39;Tony&#39; # assuming cookie was set using the same salt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;nonexistent-cookie&quot;</span><span class="p">)</span>
<span class="go">KeyError: &#39;nonexistent-cookie&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;nonexistent-cookie&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;cookie-that-was-tampered-with&quot;</span><span class="p">)</span>
<span class="go">BadSignature: ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">max_age</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="go">SignatureExpired: Signature age 1677.3839159 &gt; 60 seconds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">get_signed_cookie</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_age</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>更多信息请参见 <a class="reference internal" href="../topics/signing.html"><span class="doc">加密签名</span></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.is_secure">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">is_secure</span></code>()<a class="headerlink" href="#django.http.HttpRequest.is_secure" title="永久链接至目标">¶</a></dt>
<dd><p>如果请求是安全的，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>；如果请求是通过 HTTPS 发出的，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.accepts">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">accepts</span></code>(<em><span class="n"><span class="pre">mime_type</span></span></em>)<a class="headerlink" href="#django.http.HttpRequest.accepts" title="永久链接至目标">¶</a></dt>
<dd><p>如果请求的 <code class="docutils literal notranslate"><span class="pre">Accept</span></code> 标头与 <code class="docutils literal notranslate"><span class="pre">mime_type</span></code> 参数匹配，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">accepts</span><span class="p">(</span><span class="s2">&quot;text/html&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>大多数浏览器默认发送 <code class="docutils literal notranslate"><span class="pre">Accept:</span> <span class="pre">*/*</span></code>，默认情况下，这将为所有内容类型返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。在 API 请求中设置一个显式的 <code class="docutils literal notranslate"><span class="pre">Accept</span></code> 头，对于只为那些消费者返回不同的内容类型是很有用的。参见 <a class="reference internal" href="../topics/class-based-views/generic-editing.html#content-negotiation-example"><span class="std std-ref">内容协商示例</span></a> 使用 <code class="docutils literal notranslate"><span class="pre">accepts()</span></code> 向 API 消费者返回不同的内容。</p>
<p>如果一个响应根据 <code class="docutils literal notranslate"><span class="pre">Accept</span></code> 头的内容而变化，并且你使用了某种形式的缓存，比如 Django 的 <a class="reference internal" href="middleware.html#module-django.middleware.cache" title="django.middleware.cache: Middleware for the site-wide cache."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cache</span> <span class="pre">middleware</span></code></a>，你应该用 <code class="xref py py-func docutils literal notranslate"><span class="pre">vary_on_headers('Accept')</span></code> 来装饰视图，这样响应就会被正确地缓存。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.read">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">read</span></code>(<em><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpRequest.read" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.readline">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">readline</span></code>()<a class="headerlink" href="#django.http.HttpRequest.readline" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.readlines">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">readlines</span></code>()<a class="headerlink" href="#django.http.HttpRequest.readlines" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpRequest.__iter__">
<code class="sig-prename descclassname"><span class="pre">HttpRequest.</span></code><code class="sig-name descname"><span class="pre">__iter__</span></code>()<a class="headerlink" href="#django.http.HttpRequest.__iter__" title="永久链接至目标">¶</a></dt>
<dd><p>实现从 <code class="docutils literal notranslate"><span class="pre">HttpRequest</span></code> 实例中读取文件的类似接口的方法。这使得它可以以流式方式处理一个传入的请求。一个常见的用例是用迭代解析器处理一个大的 XML 有效载荷，而无需在内存中构建一个完整的 XML 树。</p>
<p>给定这个标准接口，一个 <code class="docutils literal notranslate"><span class="pre">HttpRequest</span></code> 实例可以直接传递给 XML 解析器，如 <a class="reference external" href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">ET</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="s-querydict-objects">
<span id="querydict-objects"></span><h2><code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 对象<a class="headerlink" href="#querydict-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.QueryDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">QueryDict</span></code><a class="headerlink" href="#django.http.QueryDict" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>在一个 <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpRequest</span></code></a> 对象中， <a class="reference internal" href="#django.http.HttpRequest.GET" title="django.http.HttpRequest.GET"><code class="xref py py-attr docutils literal notranslate"><span class="pre">GET</span></code></a> 和 <a class="reference internal" href="#django.http.HttpRequest.POST" title="django.http.HttpRequest.POST"><code class="xref py py-attr docutils literal notranslate"><span class="pre">POST</span></code></a> 属性是 <code class="docutils literal notranslate"><span class="pre">django.http.QueryDict</span></code> 的实例，这是一个类似字典的类，用来处理同一个键的多个值。这是很有必要的，因为一些 HTML 表单元素，尤其是 <code class="docutils literal notranslate"><span class="pre">&lt;select</span> <span class="pre">multiple&gt;</span></code>，会传递同一个键的多个值。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">request.POST</span></code> 和 <code class="docutils literal notranslate"><span class="pre">request.GET</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 将在正常的请求／响应周期中被访问时是不可改变的。要得到一个可变的版本，你需要使用 <a class="reference internal" href="#django.http.QueryDict.copy" title="django.http.QueryDict.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QueryDict.copy()</span></code></a>。</p>
<div class="section" id="s-id1">
<span id="id1"></span><h3>方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#django.http.QueryDict" title="django.http.QueryDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryDict</span></code></a> 实现了所有标准的字典方法，因为它是字典的一个子类。这里概述了例外情况：</p>
<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.__init__">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">__init__</span></code>(<em><span class="n"><span class="pre">query_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">mutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.__init__" title="永久链接至目标">¶</a></dt>
<dd><p>基于 <code class="docutils literal notranslate"><span class="pre">query_string</span></code> 实例化一个 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 对象。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=2&amp;c=3&quot;</span><span class="p">)</span>
<span class="go">&lt;QueryDict: {&#39;a&#39;: [&#39;1&#39;, &#39;2&#39;], &#39;c&#39;: [&#39;3&#39;]}&gt;</span>
</pre></div>
</div>
<p>如果没有传入 <code class="docutils literal notranslate"><span class="pre">query_string</span></code>，产生的 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 将是空的（它将没有键或值）。</p>
<p>你遇到的大多数 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code>s，特别是那些在 <code class="docutils literal notranslate"><span class="pre">request.POST</span></code> 和 <code class="docutils literal notranslate"><span class="pre">request.GET</span></code> 的，将是不可变的。如果你自己实例化一个，你可以通过传递 <code class="docutils literal notranslate"><span class="pre">mutable=True</span></code> 到它的 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 来使它可变。</p>
<p>设置键和值的字符串将从 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">str</span></code>。如果没有设置 <code class="docutils literal notranslate"><span class="pre">encoding</span></code>，则默认为 <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_CHARSET</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.fromkeys">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">fromkeys</span></code>(<em><span class="n"><span class="pre">iterable</span></span></em>, <em><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em><span class="n"><span class="pre">mutable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.fromkeys" title="永久链接至目标">¶</a></dt>
<dd><p>使用来自 <code class="docutils literal notranslate"><span class="pre">iterable</span></code> 的键和每个值等于 <code class="docutils literal notranslate"><span class="pre">value</span></code> 的值创建一个新的 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code>。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">QueryDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">)</span>
<span class="go">&lt;QueryDict: {&#39;a&#39;: [&#39;val&#39;, &#39;val&#39;], &#39;b&#39;: [&#39;val&#39;]}&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.__getitem__">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">__getitem__</span></code>(<em><span class="n"><span class="pre">key</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.__getitem__" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定键的值。如果键有多个值，则返回最后一个值。如果键不存在，会引发 <code class="docutils literal notranslate"><span class="pre">django.utils.datastructures.MultiValueDictKeyError</span></code>。（这是 Python 标准的 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 的一个子类，所以你可以坚持捕捉 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>。)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.__setitem__">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">__setitem__</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">value</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.__setitem__" title="永久链接至目标">¶</a></dt>
<dd><p>将给定的键设置为 <code class="docutils literal notranslate"><span class="pre">[value]</span></code> （一个单一元素为 <code class="docutils literal notranslate"><span class="pre">value</span></code> 的列表）。请注意，这个函数和其他有副作用的字典函数一样，只能在一个可变的 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 上调用（比如通过 <a class="reference internal" href="#django.http.QueryDict.copy" title="django.http.QueryDict.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QueryDict.copy()</span></code></a> 创建的）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.__contains__">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">__contains__</span></code>(<em><span class="n"><span class="pre">key</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.__contains__" title="永久链接至目标">¶</a></dt>
<dd><p>如果给定的键被设置，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。这让你可以执行，例如，<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">&quot;foo&quot;</span> <span class="pre">in</span> <span class="pre">request.GET</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.get">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">get</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.get" title="永久链接至目标">¶</a></dt>
<dd><p>使用与 <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 相同的逻辑，如果键不存在，则用钩子返回一个默认值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.setdefault">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">setdefault</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.setdefault" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" title="(在 Python v3.12)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.setdefault()</span></code></a> 一样，只是它在内部使用 <a class="reference internal" href="#django.http.QueryDict.__setitem__" title="django.http.QueryDict.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.update">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">update</span></code>(<em><span class="n"><span class="pre">other_dict</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.update" title="永久链接至目标">¶</a></dt>
<dd><p>接受一个 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 或一个字典。类似于 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.update" title="(在 Python v3.12)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.update()</span></code></a>，但它会将项目添加到当前字典而不是替换它们。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&quot;</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>  <span class="c1"># returns the last</span>
<span class="go">&#39;2&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.items">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">items</span></code>()<a class="headerlink" href="#django.http.QueryDict.items" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.items" title="(在 Python v3.12)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a>，不过它使用与 <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 相同的最后一个值逻辑，并返回一个迭代器对象而不是视图对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=2&amp;a=3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, &#39;3&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.values">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">values</span></code>()<a class="headerlink" href="#django.http.QueryDict.values" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.values" title="(在 Python v3.12)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a>，不过它使用与 <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 相同的最后一个值逻辑，并返回一个迭代器而不是视图对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=2&amp;a=3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[&#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<p>此外，<code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 有以下方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.copy">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">copy</span></code>()<a class="headerlink" href="#django.http.QueryDict.copy" title="永久链接至目标">¶</a></dt>
<dd><p>使用 <a class="reference external" href="https://docs.python.org/3/library/copy.html#copy.deepcopy" title="(在 Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 返回对象的副本。这个副本将是可变的，即使原始副本不是。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.getlist">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">getlist</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.getlist" title="永久链接至目标">¶</a></dt>
<dd><p>返回带有请求键的数据列表。如果键不存在且 <code class="docutils literal notranslate"><span class="pre">default</span></code> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则返回一个空列表。除非提供的默认值不是一个列表，否则保证返回一个列表。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.setlist">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">setlist</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">list_</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.setlist" title="永久链接至目标">¶</a></dt>
<dd><p>将给定的键设置为 <code class="docutils literal notranslate"><span class="pre">list_</span></code> （与 <a class="reference internal" href="#django.http.QueryDict.__setitem__" title="django.http.QueryDict.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 不同）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.appendlist">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">appendlist</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">item</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.appendlist" title="永久链接至目标">¶</a></dt>
<dd><p>将一个项目添加到与键相关联的内部列表中。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.setlistdefault">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">setlistdefault</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">default_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.setlistdefault" title="永久链接至目标">¶</a></dt>
<dd><p>和 <a class="reference internal" href="#django.http.QueryDict.setdefault" title="django.http.QueryDict.setdefault"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code></a> 一样，只不过它取的是一个值的列表，而不是单个值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.lists">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">lists</span></code>()<a class="headerlink" href="#django.http.QueryDict.lists" title="永久链接至目标">¶</a></dt>
<dd><p>类似于 <a class="reference internal" href="#django.http.QueryDict.items" title="django.http.QueryDict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a>，不过它包括字典中每个成员的所有值，以列表的形式。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=2&amp;a=3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">lists</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.pop">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">pop</span></code>(<em><span class="n"><span class="pre">key</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.pop" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定键的值列表并从字典中删除它们。如果键不存在，则引发 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=2&amp;a=3&quot;</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.popitem">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">popitem</span></code>()<a class="headerlink" href="#django.http.QueryDict.popitem" title="永久链接至目标">¶</a></dt>
<dd><p>移除字典中的一个任意成员（因为没有顺序概念），并返回一个包含键和该键所有值的列表的两个值的元组。当在空字典上调用时，引发 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=2&amp;a=3&quot;</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
<span class="go">(&#39;a&#39;, [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.dict">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">dict</span></code>()<a class="headerlink" href="#django.http.QueryDict.dict" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 的 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 表示。对于 <code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 中的每个（键，列表）对，<code class="docutils literal notranslate"><span class="pre">dict</span></code> 将具有（键，项），其中项是列表的一个元素，使用与 <a class="reference internal" href="#django.http.QueryDict.__getitem__" title="django.http.QueryDict.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QueryDict.__getitem__()</span></code></a> 相同的逻辑：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=1&amp;a=3&amp;a=5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
<span class="go">{&#39;a&#39;: &#39;5&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.QueryDict.urlencode">
<code class="sig-prename descclassname"><span class="pre">QueryDict.</span></code><code class="sig-name descname"><span class="pre">urlencode</span></code>(<em><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.QueryDict.urlencode" title="永久链接至目标">¶</a></dt>
<dd><p>以查询字符串格式返回数据的字符串。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="s2">&quot;a=2&amp;b=3&amp;b=5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">urlencode</span><span class="p">()</span>
<span class="go">&#39;a=2&amp;b=3&amp;b=5&#39;</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">safe</span></code> 参数传递不需要编码的字符。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">QueryDict</span><span class="p">(</span><span class="n">mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/a&amp;b/&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">urlencode</span><span class="p">(</span><span class="n">safe</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
<span class="go">&#39;next=/a%26b/&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="s-httpresponse-objects">
<span id="httpresponse-objects"></span><h2><code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 对象<a class="headerlink" href="#httpresponse-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponse</span></code><a class="headerlink" href="#django.http.HttpResponse" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>与 Django 自动创建的 <a class="reference internal" href="#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpRequest</span></code></a> 对象不同， <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 对象是你的责任。你写的每个视图都要负责实例化、填充和返回一个 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 对象。</p>
<p><a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 类位于 <a class="reference internal" href="#module-django.http" title="django.http: Classes dealing with HTTP requests and responses."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.http</span></code></a> 模块中。</p>
<div class="section" id="s-usage">
<span id="usage"></span><h3>用法<a class="headerlink" href="#usage" title="永久链接至标题">¶</a></h3>
<div class="section" id="s-passing-strings">
<span id="passing-strings"></span><h4>传入字符串<a class="headerlink" href="#passing-strings" title="永久链接至标题">¶</a></h4>
<p>典型的用法是将页面的内容作为字符串、字节串或 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 传递给 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 构造函数：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.http</span> <span class="kn">import</span> <span class="n">HttpResponse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="s2">&quot;Here&#39;s the text of the web page.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="s2">&quot;Text only, please.&quot;</span><span class="p">,</span> <span class="n">content_type</span><span class="o">=</span><span class="s2">&quot;text/plain&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Bytestrings are also accepted.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Memoryview as well.&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>但如果你想逐步添加内容，你可以将 <code class="docutils literal notranslate"><span class="pre">response</span></code> 当作类似文件的对象来使用：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;Here&#39;s the text of the web page.&lt;/p&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;p&gt;Here&#39;s another paragraph.&lt;/p&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-passing-iterators">
<span id="passing-iterators"></span><h4>传入迭代器<a class="headerlink" href="#passing-iterators" title="永久链接至标题">¶</a></h4>
<p>最后，你可以传递 <code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 一个迭代器而不是字符串。<code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 将立即消耗迭代器，将其内容存储为一个字符串，然后丢弃它。带有 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 方法的对象，如文件和生成器，会立即关闭。</p>
<p>如果你需要将响应从迭代器流式传输到客户端，你必须使用 <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 类来代替。</p>
</div>
<div class="section" id="s-setting-header-fields">
<span id="s-id2"></span><span id="setting-header-fields"></span><span id="id2"></span><h4>设置头字段<a class="headerlink" href="#setting-header-fields" title="永久链接至标题">¶</a></h4>
<p>要在响应中设置或移除头字段，使用 <a class="reference internal" href="#django.http.HttpResponse.headers" title="django.http.HttpResponse.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpResponse.headers</span></code></a>：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s2">&quot;Age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s2">&quot;Age&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>你还可以通过将响应当作字典来操作头部信息：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">response</span><span class="p">[</span><span class="s2">&quot;Age&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>这相当于代理到了 <code class="docutils literal notranslate"><span class="pre">HttpResponse.headers</span></code>，也是 <code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 最初提供的接口。</p>
<p>使用这个接口时，不像字典那样，如果头字段不存在，<code class="docutils literal notranslate"><span class="pre">del</span></code> 不会引发 <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>。</p>
<p>你还可以在实例化时设置头部信息：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Age&quot;</span><span class="p">:</span> <span class="mi">120</span><span class="p">})</span>
</pre></div>
</div>
<p>对于设置 <code class="docutils literal notranslate"><span class="pre">Cache-Control</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Vary</span></code> 头字段，建议使用 <a class="reference internal" href="utils.html#django.utils.cache.patch_cache_control" title="django.utils.cache.patch_cache_control"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.utils.cache.patch_cache_control</span></code></a> 和 <a class="reference internal" href="utils.html#django.utils.cache.patch_vary_headers" title="django.utils.cache.patch_vary_headers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.utils.cache.patch_vary_headers</span></code></a> 中的 <a class="reference internal" href="utils.html#django.utils.cache.patch_cache_control" title="django.utils.cache.patch_cache_control"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch_cache_control()</span></code></a> 和 <a class="reference internal" href="utils.html#django.utils.cache.patch_vary_headers" title="django.utils.cache.patch_vary_headers"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch_vary_headers()</span></code></a> 方法，因为这些字段可以有多个以逗号分隔的值。这些“补丁”方法保证了其他的值，例如由中间件添加的值，不会被删除。</p>
<p>HTTP 头字段不能包含换行符。试图设置一个包含换行符（CR 或 LF）的头字段将引发 <code class="docutils literal notranslate"><span class="pre">BadHeaderError</span></code>。</p>
</div>
<div class="section" id="s-telling-the-browser-to-treat-the-response-as-a-file-attachment">
<span id="telling-the-browser-to-treat-the-response-as-a-file-attachment"></span><h4>告诉浏览器将响应作为文件附件处理<a class="headerlink" href="#telling-the-browser-to-treat-the-response-as-a-file-attachment" title="永久链接至标题">¶</a></h4>
<p>要告诉浏览器将响应视为文件附件，设置 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Content-Disposition</span></code> 头部。例如，这是如何返回一个 Microsoft Excel 电子表格的方式：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">HttpResponse</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">my_data</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headers</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;Content-Type&quot;</span><span class="p">:</span> <span class="s2">&quot;application/vnd.ms-excel&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;Content-Disposition&quot;</span><span class="p">:</span> <span class="s1">&#39;attachment; filename=&quot;foo.xls&quot;&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Content-Disposition</span></code> 头并没有什么 Django 特有的内容，但是很容易忘记语法，所以我们把它包含在这里。</p>
</div>
</div>
<div class="section" id="s-id3">
<span id="id3"></span><h3>属性<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.content">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">content</span></code><a class="headerlink" href="#django.http.HttpResponse.content" title="永久链接至目标">¶</a></dt>
<dd><p>一个代表内容的字节字符串，必要时由字符串编码。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.cookies">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">cookies</span></code><a class="headerlink" href="#django.http.HttpResponse.cookies" title="永久链接至目标">¶</a></dt>
<dd><p>一个包含在响应中的 cookie 的 <a class="reference external" href="https://docs.python.org/3/library/http.cookies.html#http.cookies.SimpleCookie" title="(在 Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">http.cookies.SimpleCookie</span></code></a> 对象。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.headers">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">headers</span></code><a class="headerlink" href="#django.http.HttpResponse.headers" title="永久链接至目标">¶</a></dt>
<dd><p>一个不区分大小写的、类似字典的对象，提供对响应中除了 <code class="docutils literal notranslate"><span class="pre">Set-Cookie</span></code> 头部之外的所有 HTTP 头部的接口。请参阅 <a class="reference internal" href="#setting-header-fields"><span class="std std-ref">设置头字段</span></a> 和 <a class="reference internal" href="#django.http.HttpResponse.cookies" title="django.http.HttpResponse.cookies"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpResponse.cookies</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.charset">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">charset</span></code><a class="headerlink" href="#django.http.HttpResponse.charset" title="永久链接至目标">¶</a></dt>
<dd><p>表示响应将被编码的字符集的字符串。如果在 <code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 实例化时没有给出，将从 <code class="docutils literal notranslate"><span class="pre">content_type</span></code> 中提取，如果不成功，将使用 <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_CHARSET</span></code></a> 设置。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.status_code">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">status_code</span></code><a class="headerlink" href="#django.http.HttpResponse.status_code" title="永久链接至目标">¶</a></dt>
<dd><p>响应的 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15"><strong>HTTP 状态码</strong></a>。</p>
<p>除非 <a class="reference internal" href="#django.http.HttpResponse.reason_phrase" title="django.http.HttpResponse.reason_phrase"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason_phrase</span></code></a> 被明确设置，否则在构造函数外修改 <code class="docutils literal notranslate"><span class="pre">status_code</span></code> 的值也会修改 <code class="docutils literal notranslate"><span class="pre">reason_phrase</span></code> 的值。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.reason_phrase">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">reason_phrase</span></code><a class="headerlink" href="#django.http.HttpResponse.reason_phrase" title="永久链接至目标">¶</a></dt>
<dd><p>响应的 HTTP 原因短语。它使用 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15.1"><strong>HTTP 标准</strong></a> 中的默认原因短语。</p>
<p>除非明确设置，否则 <code class="docutils literal notranslate"><span class="pre">reason_phrase</span></code> 由 <a class="reference internal" href="#django.http.HttpResponse.status_code" title="django.http.HttpResponse.status_code"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status_code</span></code></a> 的值决定。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.streaming">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">streaming</span></code><a class="headerlink" href="#django.http.HttpResponse.streaming" title="永久链接至目标">¶</a></dt>
<dd><p>这总是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>此属性的存在是为了让中间件能够将流式响应与常规响应区别对待。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponse.closed">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">closed</span></code><a class="headerlink" href="#django.http.HttpResponse.closed" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code> 如果响应已经结束。</p>
</dd></dl>

</div>
<div class="section" id="s-id4">
<span id="id4"></span><h3>方法<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.__init__">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">__init__</span></code>(<em><span class="n"><span class="pre">content</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em><span class="n"><span class="pre">content_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em><span class="n"><span class="pre">reason</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">charset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">headers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.__init__" title="永久链接至目标">¶</a></dt>
<dd><p>使用给定的页面内容、内容类型和头部实例化一个 <code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 对象。</p>
<p><code class="docutils literal notranslate"><span class="pre">content</span></code> 最常见的是迭代器、字节字符串、<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 或字符串。其他类型将通过对它们的字符串表示进行编码而转换为字节组。迭代器应该返回字符串或字节字符串，这些将被连接在一起以形成响应的内容。</p>
<p><code class="docutils literal notranslate"><span class="pre">content_type</span></code> 是 MIME 类型，可选择用字符集编码完成，用于填充 HTTP <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 头。如果没有指定，则由 <code class="docutils literal notranslate"><span class="pre">'text/html'</span></code> 和 <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_CHARSET</span></code></a> 配置组成，默认情况下：<code class="docutils literal notranslate"><span class="pre">&quot;text/html;</span> <span class="pre">charset=utf-8&quot;</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">status</span></code> 是响应的 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15"><strong>HTTP 状态码</strong></a>。你可以使用 Python 的 <a class="reference external" href="https://docs.python.org/3/library/http.html#http.HTTPStatus" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.HTTPStatus</span></code></a> 来使用有意义的别名，例如 <code class="docutils literal notranslate"><span class="pre">HTTPStatus.NO_CONTENT</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">reason</span></code> 是 HTTP 响应短语。如果没有提供，将使用默认短语。</p>
<p><code class="docutils literal notranslate"><span class="pre">charset</span></code> 是对响应进行编码的字符集。如果没有给出，将从 <code class="docutils literal notranslate"><span class="pre">content_type</span></code> 中提取，如果不成功，将使用 <a class="reference internal" href="settings.html#std-setting-DEFAULT_CHARSET"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_CHARSET</span></code></a> 配置。</p>
<p><code class="docutils literal notranslate"><span class="pre">headers</span></code> 是响应的 HTTP 头部的 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.__setitem__">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">__setitem__</span></code>(<em><span class="n"><span class="pre">header</span></span></em>, <em><span class="n"><span class="pre">value</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.__setitem__" title="永久链接至目标">¶</a></dt>
<dd><p>将给定的响应头名设置为给定的值。<code class="docutils literal notranslate"><span class="pre">header</span></code> 和 <code class="docutils literal notranslate"><span class="pre">value</span></code> 都应该是字符串。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.__delitem__">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">__delitem__</span></code>(<em><span class="n"><span class="pre">header</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.__delitem__" title="永久链接至目标">¶</a></dt>
<dd><p>删除指定名称的响应头。如果头不存在，则静默失败。不区分大小写。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.__getitem__">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">__getitem__</span></code>(<em><span class="n"><span class="pre">header</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.__getitem__" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定响应头名的值。不区分大小写。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.get">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">get</span></code>(<em><span class="n"><span class="pre">header</span></span></em>, <em><span class="n"><span class="pre">alternate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.get" title="永久链接至目标">¶</a></dt>
<dd><p>返回给定响应头的值，如果头不存在，则返回 <code class="docutils literal notranslate"><span class="pre">alternate</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.has_header">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">has_header</span></code>(<em><span class="n"><span class="pre">header</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.has_header" title="永久链接至目标">¶</a></dt>
<dd><p>根据对给定名称的响应头进行不区分大小写的检查，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.items">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">items</span></code>()<a class="headerlink" href="#django.http.HttpResponse.items" title="永久链接至目标">¶</a></dt>
<dd><p>像 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.items" title="(在 Python v3.12)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> 一样作用于响应的 HTTP 头信息。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.setdefault">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">setdefault</span></code>(<em><span class="n"><span class="pre">header</span></span></em>, <em><span class="n"><span class="pre">value</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.setdefault" title="永久链接至目标">¶</a></dt>
<dd><p>设置响应头，除非它已经被设置。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.set_cookie">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">set_cookie</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em><span class="n"><span class="pre">max_age</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">expires</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">secure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">httponly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">samesite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.set_cookie" title="永久链接至目标">¶</a></dt>
<dd><p>设置一个 cookie。参数与 Python 标准库中的 <a class="reference external" href="https://docs.python.org/3/library/http.cookies.html#http.cookies.Morsel" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Morsel</span></code></a> cookie 对象相同。</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">max_age</span></code> 应该是一个 <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> 对象、整数秒数，或者 <code class="docutils literal notranslate"><span class="pre">None</span></code> （默认值），如果 cookie 只应持续客户端浏览器会话的时间。如果未指定 <code class="docutils literal notranslate"><span class="pre">expires</span></code>，它将被计算。</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">expires</span></code> 应是格式为 <code class="docutils literal notranslate"><span class="pre">&quot;Wdy,</span> <span class="pre">DD-Mon-YY</span> <span class="pre">HH:MM:SS</span> <span class="pre">GMT&quot;</span></code> 的字符串，或者是 UTC 的 <code class="docutils literal notranslate"><span class="pre">datetime.datetime</span></code> 对象。如果 <code class="docutils literal notranslate"><span class="pre">expires</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">datetime</span></code> 对象，将计算 <code class="docutils literal notranslate"><span class="pre">max_age</span></code>。</p>
</li>
<li><p class="first">如果你想设置一个跨域的 cookie，请使用 <code class="docutils literal notranslate"><span class="pre">domain</span></code>。例如，<code class="docutils literal notranslate"><span class="pre">domain=&quot;example.com&quot;</span></code> 将设置一个可被 www.example.com、blog.example.com 等域读取的 cookie。否则，一个 cookie 将只能被设置它的域读取。</p>
</li>
<li><p class="first">如果你想让 cookie 只在使用 <code class="docutils literal notranslate"><span class="pre">https</span></code> 方案进行请求时才发送给服务器，请使用 <code class="docutils literal notranslate"><span class="pre">secure=True</span></code>。</p>
</li>
<li><p class="first">如果你想防止客户端的 JavaScript 访问 cookie，请使用 <code class="docutils literal notranslate"><span class="pre">httponly=True</span></code>。</p>
<p><a class="reference external" href="https://owasp.org/www-community/HttpOnly">HttpOnly</a> 是包含在 Set-Cookie HTTP 响应头中的一个标志。它是 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6265.html#section-4.1.2.6"><strong>RFC 6265</strong></a> 标准中 Cookie 的一部分，可以作为一种有用的方式来降低客户端脚本访问受保护 Cookie 数据的风险。</p>
</li>
<li><p class="first">使用 <code class="docutils literal notranslate"><span class="pre">samesite='Strict'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">samesite='Lax'</span></code> 来告诉浏览器在执行跨源请求时不要发送这个 cookie。<a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite">SameSite</a> 并不是所有浏览器都支持，所以它并不能替代 Django 的 CSRF 保护，而是一种深度防御措施。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">samesite=''None'</span></code> （字符串）来明确说明这个 cookie 会随着所有的同站和跨站请求而发送。</p>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6265.html#section-6.1"><strong>RFC 6265</strong></a> 规定，用户代理应支持至少 4096 字节的 cookies。对于很多浏览器来说，这也是最大的尺寸。如果试图存储一个超过 4096 字节的 cookie，Django 不会引发异常，但很多浏览器不会正确设置 cookie。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.set_signed_cookie">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">set_signed_cookie</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">value</span></span></em>, <em><span class="n"><span class="pre">salt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em><span class="n"><span class="pre">max_age</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">expires</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">secure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">httponly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">samesite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.set_signed_cookie" title="永久链接至目标">¶</a></dt>
<dd><p>像 <a class="reference internal" href="#django.http.HttpResponse.set_cookie" title="django.http.HttpResponse.set_cookie"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_cookie()</span></code></a> 一样，但是 <a class="reference internal" href="../topics/signing.html"><span class="doc">在设置 cookie 之前对它进行加密签名</span></a>。与 <a class="reference internal" href="#django.http.HttpRequest.get_signed_cookie" title="django.http.HttpRequest.get_signed_cookie"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HttpRequest.get_signed_cookie()</span></code></a> 一起使用。你可以使用可选的 <code class="docutils literal notranslate"><span class="pre">salt</span></code> 参数来增加密钥强度，但你需要记得把它传递给相应的 <a class="reference internal" href="#django.http.HttpRequest.get_signed_cookie" title="django.http.HttpRequest.get_signed_cookie"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HttpRequest.get_signed_cookie()</span></code></a> 调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.delete_cookie">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">delete_cookie</span></code>(<em><span class="n"><span class="pre">key</span></span></em>, <em><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="n"><span class="pre">samesite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.delete_cookie" title="永久链接至目标">¶</a></dt>
<dd><p>删除给定键的 cookie。如果键不存在，则静默失败。</p>
<p>由于 cookie 的工作方式，<code class="docutils literal notranslate"><span class="pre">path</span></code> 和 <code class="docutils literal notranslate"><span class="pre">domain</span></code> 应该与你在 <code class="docutils literal notranslate"><span class="pre">set_cookie()</span></code> 中使用的值相同，否则 cookie 可能不会被删除。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.close">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">close</span></code>()<a class="headerlink" href="#django.http.HttpResponse.close" title="永久链接至目标">¶</a></dt>
<dd><p>本方法在请求结束时由 WSGI 服务器直接调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.write">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">write</span></code>(<em><span class="n"><span class="pre">content</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.write" title="永久链接至目标">¶</a></dt>
<dd><p>这个方法使一个 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类似文件的对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.flush">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">flush</span></code>()<a class="headerlink" href="#django.http.HttpResponse.flush" title="永久链接至目标">¶</a></dt>
<dd><p>这个方法使一个 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类似文件的对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.tell">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">tell</span></code>()<a class="headerlink" href="#django.http.HttpResponse.tell" title="永久链接至目标">¶</a></dt>
<dd><p>这个方法使一个 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类似文件的对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.getvalue">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">getvalue</span></code>()<a class="headerlink" href="#django.http.HttpResponse.getvalue" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="#django.http.HttpResponse.content" title="django.http.HttpResponse.content"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpResponse.content</span></code></a> 的值。本方法使一个 :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>HttpResponse`实例成为一个类流对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.readable">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">readable</span></code>()<a class="headerlink" href="#django.http.HttpResponse.readable" title="永久链接至目标">¶</a></dt>
<dd><p>总是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。此方法使 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类流对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.seekable">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">seekable</span></code>()<a class="headerlink" href="#django.http.HttpResponse.seekable" title="永久链接至目标">¶</a></dt>
<dd><p>总是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。此方法使 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类流对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.writable">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">writable</span></code>()<a class="headerlink" href="#django.http.HttpResponse.writable" title="永久链接至目标">¶</a></dt>
<dd><p>总是 <code class="docutils literal notranslate"><span class="pre">True</span></code>。此方法使 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类流对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="django.http.HttpResponse.writelines">
<code class="sig-prename descclassname"><span class="pre">HttpResponse.</span></code><code class="sig-name descname"><span class="pre">writelines</span></code>(<em><span class="n"><span class="pre">lines</span></span></em>)<a class="headerlink" href="#django.http.HttpResponse.writelines" title="永久链接至目标">¶</a></dt>
<dd><p>将行的列表写入响应。不添加行的分隔符。此方法使 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 实例成为一个类流对象。</p>
</dd></dl>

</div>
<div class="section" id="s-httpresponse-subclasses">
<span id="s-ref-httpresponse-subclasses"></span><span id="httpresponse-subclasses"></span><span id="ref-httpresponse-subclasses"></span><h3><code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 子类<a class="headerlink" href="#httpresponse-subclasses" title="永久链接至标题">¶</a></h3>
<p>Django 包含了许多 <code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 的子类来处理不同类型的 HTTP 响应。像 <code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 一样，这些子类位于 <a class="reference internal" href="#module-django.http" title="django.http: Classes dealing with HTTP requests and responses."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.http</span></code></a> 中。</p>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseRedirect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseRedirect</span></code><a class="headerlink" href="#django.http.HttpResponseRedirect" title="永久链接至目标">¶</a></dt>
<dd><p>构造函数的第一个参数是必需的——要重定向的路径。这可以是一个完全限定的 URL（例如 <code class="docutils literal notranslate"><span class="pre">'https://www.yahoo.com/search/</span></code>)，一个没有域名的绝对路径（例如 <code class="docutils literal notranslate"><span class="pre">'/search/'</span></code>），甚至是一个相对路径（例如 <code class="docutils literal notranslate"><span class="pre">'search/'</span></code>）。在最后一种情况下，客户端浏览器会根据当前路径自己重建完整的 URL。参见 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 了解其他可选的构造函数参数。请注意，这将返回一个 HTTP 状态码 302。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.HttpResponseRedirect.url">
<code class="sig-name descname"><span class="pre">url</span></code><a class="headerlink" href="#django.http.HttpResponseRedirect.url" title="永久链接至目标">¶</a></dt>
<dd><p>这个只读属性表示响应将重定向到的 URL（相当于 <code class="docutils literal notranslate"><span class="pre">Location</span></code> 响应头）。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponsePermanentRedirect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponsePermanentRedirect</span></code><a class="headerlink" href="#django.http.HttpResponsePermanentRedirect" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponseRedirect" title="django.http.HttpResponseRedirect"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponseRedirect</span></code></a> 一样，但它返回的是一个永久重定向（HTTP 状态码 301），而不是“found”重定向（状态码 302）。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseNotModified">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseNotModified</span></code><a class="headerlink" href="#django.http.HttpResponseNotModified" title="永久链接至目标">¶</a></dt>
<dd><p>构造函数不接受任何参数，也不应该添加任何内容到这个响应中。用它来表示自用户最后一次请求后，页面没有被修改（状态码 304）。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseBadRequest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseBadRequest</span></code><a class="headerlink" href="#django.http.HttpResponseBadRequest" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 一样，但使用 400 状态码。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseNotFound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseNotFound</span></code><a class="headerlink" href="#django.http.HttpResponseNotFound" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 一样，但使用 404 状态码。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseForbidden">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseForbidden</span></code><a class="headerlink" href="#django.http.HttpResponseForbidden" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 一样，但使用 403 状态码。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseNotAllowed">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseNotAllowed</span></code><a class="headerlink" href="#django.http.HttpResponseNotAllowed" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 一样，但使用 405 状态码。构造函数的第一个参数是必需的：一个允许的方法列表（例如 <code class="docutils literal notranslate"><span class="pre">['GET',</span> <span class="pre">'POST']</span></code>）。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseGone">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseGone</span></code><a class="headerlink" href="#django.http.HttpResponseGone" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 一样，但使用 410 状态码。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseServerError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseServerError</span></code><a class="headerlink" href="#django.http.HttpResponseServerError" title="永久链接至目标">¶</a></dt>
<dd><p>就像 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 一样，但使用 500 状态码。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">备注</p>
<p class="last">如果 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 的自定义子类实现了 <code class="docutils literal notranslate"><span class="pre">render</span></code> 方法，Django 会将其视为模拟 <a class="reference internal" href="template-response.html#django.template.response.SimpleTemplateResponse" title="django.template.response.SimpleTemplateResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleTemplateResponse</span></code></a>，并且 <code class="docutils literal notranslate"><span class="pre">render</span></code> 方法本身必须返回一个有效的响应对象。</p>
</div>
<div class="section" id="s-custom-response-classes">
<span id="custom-response-classes"></span><h4>自定义响应类<a class="headerlink" href="#custom-response-classes" title="永久链接至标题">¶</a></h4>
<p>如果你发现自己需要一个 Django 没有提供的响应类，你可以借助 <a class="reference external" href="https://docs.python.org/3/library/http.html#http.HTTPStatus" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.HTTPStatus</span></code></a> 来创建它。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">http</span> <span class="kn">import</span> <span class="n">HTTPStatus</span>
<span class="kn">from</span> <span class="nn">django.http</span> <span class="kn">import</span> <span class="n">HttpResponse</span>


<span class="k">class</span> <span class="nc">HttpResponseNoContent</span><span class="p">(</span><span class="n">HttpResponse</span><span class="p">):</span>
    <span class="n">status_code</span> <span class="o">=</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">NO_CONTENT</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-jsonresponse-objects">
<span id="jsonresponse-objects"></span><h2><code class="docutils literal notranslate"><span class="pre">JsonResponse</span></code> 对象<a class="headerlink" href="#jsonresponse-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.JsonResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">JsonResponse</span></code>(<em><span class="n"><span class="pre">data</span></span></em>, <em><span class="n"><span class="pre">encoder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DjangoJSONEncoder</span></span></em>, <em><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em><span class="n"><span class="pre">json_dumps_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em>)<a class="headerlink" href="#django.http.JsonResponse" title="永久链接至目标">¶</a></dt>
<dd><p>一个 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 子类，帮助创建一个 JSON 编码的响应。它继承了它的超类的大部分行为，但有一些不同：</p>
<p>其默认的 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 头设置为 <em class="mimetype">application/json</em>。</p>
<p>第一个参数 <code class="docutils literal notranslate"><span class="pre">data</span></code> 应该是 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 实例。如果 <code class="docutils literal notranslate"><span class="pre">safe</span></code> 参数设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code> （见下文），它可以是任何 JSON 可序列化的对象。</p>
<p><code class="docutils literal notranslate"><span class="pre">encoder</span></code>，默认为 <a class="reference internal" href="../topics/serialization.html#django.core.serializers.json.DjangoJSONEncoder" title="django.core.serializers.json.DjangoJSONEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.core.serializers.json.DjangoJSONEncoder</span></code></a>，将用于序列化数据。关于这个序列化器的更多细节，请参见 <a class="reference internal" href="../topics/serialization.html#serialization-formats-json"><span class="std std-ref">JSON 序列化</span></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">safe</span></code> 布尔参数默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。如果它被设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，任何对象都可以被传递到序列化中（否则只允许 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 实例）。如果 <code class="docutils literal notranslate"><span class="pre">safe</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，而第一个参数是一个非 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 对象，则会引发一个 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">json_dumps_params</span></code> 参数是一个关键字参数的字典，用来传递给 <code class="docutils literal notranslate"><span class="pre">json.dumps()</span></code> 调用，用于生成响应。</p>
</dd></dl>

<div class="section" id="s-id5">
<span id="id5"></span><h3>用法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>典型的用法可能如下所示：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.http</span> <span class="kn">import</span> <span class="n">JsonResponse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">JsonResponse</span><span class="p">({</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">content</span>
<span class="go">b&#39;{&quot;foo&quot;: &quot;bar&quot;}&#39;</span>
</pre></div>
</div>
<div class="section" id="s-serializing-non-dictionary-objects">
<span id="serializing-non-dictionary-objects"></span><h4>序列化非字典对象<a class="headerlink" href="#serializing-non-dictionary-objects" title="永久链接至标题">¶</a></h4>
<p>为了序列化除了 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 之外的对象，你必须将 <code class="docutils literal notranslate"><span class="pre">safe</span></code> 参数设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">JsonResponse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">safe</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>如果没有传递 <code class="docutils literal notranslate"><span class="pre">safe=False</span></code>，将引发一个 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(在 Python v3.12)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>注意，基于 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 对象的 API 更具可扩展性、灵活性，并且更容易维护前向兼容性。因此，你应该避免在 JSON 编码的响应中使用非字典对象。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">在 <a class="reference external" href="https://262.ecma-international.org/5.1/#sec-11.1.4">ECMAScript 第 5 版</a> 之前，可能会对 JavaScript 的 <code class="docutils literal notranslate"><span class="pre">Array</span></code> 构造函数进行恶意操作。因此，Django 默认情况下不允许将非字典对象传递给 <a class="reference internal" href="#django.http.JsonResponse" title="django.http.JsonResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">JsonResponse</span></code></a> 构造函数。然而，大多数现代浏览器实现了 ECMAScript 5，消除了这种攻击方式。因此，可以禁用这个安全预防措施。</p>
</div>
</div>
<div class="section" id="s-changing-the-default-json-encoder">
<span id="changing-the-default-json-encoder"></span><h4>更改默认 JSON 编码器<a class="headerlink" href="#changing-the-default-json-encoder" title="永久链接至标题">¶</a></h4>
<p>如果你需要使用不同的 JSON 编码器类，可以将 <code class="docutils literal notranslate"><span class="pre">encoder</span></code> 参数传递给构造方法：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">JsonResponse</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="n">MyJSONEncoder</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="s-streaminghttpresponse-objects">
<span id="s-httpresponse-streaming"></span><span id="streaminghttpresponse-objects"></span><span id="httpresponse-streaming"></span><h2><code class="docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code> 对象<a class="headerlink" href="#streaminghttpresponse-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.StreamingHttpResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">StreamingHttpResponse</span></code><a class="headerlink" href="#django.http.StreamingHttpResponse" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 类用于从 Django 向浏览器流式传输响应。</p>
<div class="admonition-advanced-usage admonition">
<p class="first admonition-title">高级用法</p>
<p><a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 有点高级，因为重要的是要知道你将在 WSGI 下同步提供你的应用程序，还是在 ASGI 下异步提供，并相应地调整你的用法。</p>
<p class="last">请仔细阅读这些注释。</p>
</div>
<p><a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 在 WSGI 下的一个示例用法是在生成响应时需要太长时间或使用太多内存的情况下进行流式传输内容。例如，在 <a class="reference internal" href="../howto/outputting-csv.html#streaming-csv-files"><span class="std std-ref">生成大型 CSV 文件</span></a> 时非常有用。</p>
<p>不过，在执行这种操作时需要考虑性能问题。Django 在 WSGI 下设计用于短暂的请求。流式响应将绑定一个工作进程在响应的整个持续时间内。这可能导致性能不佳。</p>
<p>一般来说，你应该在请求-响应周期之外执行昂贵的任务，而不是采用流式响应。</p>
<p>然而，在 ASGI 下提供服务时，一个 <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 不需要在等待 I/O 时阻止其他请求被处理。这打开了在流式传输内容时进行长时间请求和实施长轮询以及服务器推送事件等模式的可能性。</p>
<p>即使在 ASGI 下，也应该只在绝对需要在将数据传输给客户端之前不迭代整个内容的情况下使用 <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a>。因为无法访问内容，许多中间件无法正常工作。例如，对于流式响应，无法生成 <code class="docutils literal notranslate"><span class="pre">ETag</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 头部。</p>
<p><a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 不是 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 的子类，因此它的 API 略有不同。然而，它几乎是相同的，但有以下显著的区别。</p>
<ul>
<li><p class="first">它应该被提供一个产生字节串、<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(在 Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 或字符串作为内容的迭代器。在 WSGI 下提供服务时，这应该是一个同步迭代器。在 ASGI 下提供服务时，应该是一个异步迭代器。</p>
</li>
<li><p class="first">除非迭代响应对象本身，否则无法访问其内容。这只应该在响应返回给客户端时发生：你不应该自己迭代响应。</p>
<p>在 WSGI 下，响应将同步迭代。在 ASGI 下，响应将异步迭代。（这就是为什么迭代器类型必须与你使用的协议匹配的原因。）</p>
<p>为了避免崩溃，迭代时将将不正确的迭代器类型映射到正确的类型，并引发警告，但为了执行这个操作，迭代器必须被完全消耗，这就破坏了使用 <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 的目的。</p>
</li>
<li><p class="first">它没有 <code class="docutils literal notranslate"><span class="pre">content</span></code> 属性。相反，它有一个 <a class="reference internal" href="#django.http.StreamingHttpResponse.streaming_content" title="django.http.StreamingHttpResponse.streaming_content"><code class="xref py py-attr docutils literal notranslate"><span class="pre">streaming_content</span></code></a> 属性。这可以在中间件中用于包装响应可迭代对象，但不应该被消耗。</p>
</li>
<li><p class="first">你不能使用类文件对象的 <code class="docutils literal notranslate"><span class="pre">tell()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">write()</span></code> 方法。这样做会引起一个异常。</p>
</li>
</ul>
<p><a class="reference internal" href="#django.http.HttpResponseBase" title="django.http.HttpResponseBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponseBase</span></code></a> 基类在 <a class="reference internal" href="#django.http.HttpResponse" title="django.http.HttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponse</span></code></a> 和 <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 之间是通用的。</p>
<div class="versionchanged">
<span class="title">Changed in Django 4.2:</span> <p>已添加对异步迭代的支持。</p>
</div>
<div class="section" id="s-id6">
<span id="id6"></span><h3>属性<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.StreamingHttpResponse.streaming_content">
<code class="sig-prename descclassname"><span class="pre">StreamingHttpResponse.</span></code><code class="sig-name descname"><span class="pre">streaming_content</span></code><a class="headerlink" href="#django.http.StreamingHttpResponse.streaming_content" title="永久链接至目标">¶</a></dt>
<dd><p>响应内容的迭代器，根据 <a class="reference internal" href="#django.http.HttpResponse.charset" title="django.http.HttpResponse.charset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HttpResponse.charset</span></code></a> 编码的字节字符串。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.StreamingHttpResponse.status_code">
<code class="sig-prename descclassname"><span class="pre">StreamingHttpResponse.</span></code><code class="sig-name descname"><span class="pre">status_code</span></code><a class="headerlink" href="#django.http.StreamingHttpResponse.status_code" title="永久链接至目标">¶</a></dt>
<dd><p>响应的 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15"><strong>HTTP 状态码</strong></a>。</p>
<p>除非 <a class="reference internal" href="#django.http.StreamingHttpResponse.reason_phrase" title="django.http.StreamingHttpResponse.reason_phrase"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason_phrase</span></code></a> 被明确设置，否则在构造函数外修改 <code class="docutils literal notranslate"><span class="pre">status_code</span></code> 的值也会修改 <code class="docutils literal notranslate"><span class="pre">reason_phrase</span></code> 的值。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.StreamingHttpResponse.reason_phrase">
<code class="sig-prename descclassname"><span class="pre">StreamingHttpResponse.</span></code><code class="sig-name descname"><span class="pre">reason_phrase</span></code><a class="headerlink" href="#django.http.StreamingHttpResponse.reason_phrase" title="永久链接至目标">¶</a></dt>
<dd><p>响应的 HTTP 原因短语。它使用 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9110.html#section-15.1"><strong>HTTP 标准</strong></a> 中的默认原因短语。</p>
<p>除非明确设置，否则 <code class="docutils literal notranslate"><span class="pre">reason_phrase</span></code> 由 <a class="reference internal" href="#django.http.StreamingHttpResponse.status_code" title="django.http.StreamingHttpResponse.status_code"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status_code</span></code></a> 的值决定。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.StreamingHttpResponse.streaming">
<code class="sig-prename descclassname"><span class="pre">StreamingHttpResponse.</span></code><code class="sig-name descname"><span class="pre">streaming</span></code><a class="headerlink" href="#django.http.StreamingHttpResponse.streaming" title="永久链接至目标">¶</a></dt>
<dd><p>这总是 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="django.http.StreamingHttpResponse.is_async">
<code class="sig-prename descclassname"><span class="pre">StreamingHttpResponse.</span></code><code class="sig-name descname"><span class="pre">is_async</span></code><a class="headerlink" href="#django.http.StreamingHttpResponse.is_async" title="永久链接至目标">¶</a></dt>
<dd><div class="versionadded">
<span class="title">New in Django 4.2.</span> </div>
<p>一个布尔值，指示 <a class="reference internal" href="#django.http.StreamingHttpResponse.streaming_content" title="django.http.StreamingHttpResponse.streaming_content"><code class="xref py py-attr docutils literal notranslate"><span class="pre">StreamingHttpResponse.streaming_content</span></code></a> 是否是异步迭代器。</p>
<p>这对于需要包装 <a class="reference internal" href="#django.http.StreamingHttpResponse.streaming_content" title="django.http.StreamingHttpResponse.streaming_content"><code class="xref py py-attr docutils literal notranslate"><span class="pre">StreamingHttpResponse.streaming_content</span></code></a> 的中间件非常有用。</p>
</dd></dl>

</div>
<div class="section" id="s-handling-disconnects">
<span id="s-request-response-streaming-disconnect"></span><span id="handling-disconnects"></span><span id="request-response-streaming-disconnect"></span><h3>处理断开连接<a class="headerlink" href="#handling-disconnects" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 5.0.</span> </div>
<p>如果在流式响应期间客户端断开连接，Django 将取消处理响应的协程。如果你想手动清理资源，可以通过捕获 <code class="docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code> 来实现：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">streaming_response</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Do some work here</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">my_streaming_iterator</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">chunk</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="c1"># Handle disconnect</span>
        <span class="o">...</span>
        <span class="k">raise</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">my_streaming_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">StreamingHttpResponse</span><span class="p">(</span><span class="n">streaming_response</span><span class="p">())</span>
</pre></div>
</div>
<p>这个示例只展示了在响应流式传输时如何处理客户端断开连接。如果在返回 <code class="docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code> 对象之前在视图中执行长时间运行的操作，那么你可能还想在视图本身中处理断开连接，可以参考 <a class="reference internal" href="../topics/async.html#async-handling-disconnect"><span class="std std-ref">在视图中处理断开连接</span></a>。</p>
</div>
</div>
<div class="section" id="s-fileresponse-objects">
<span id="fileresponse-objects"></span><h2><code class="docutils literal notranslate"><span class="pre">FileResponse</span></code> 对象<a class="headerlink" href="#fileresponse-objects" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.FileResponse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">FileResponse</span></code>(<em><span class="n"><span class="pre">open_file</span></span></em>, <em><span class="n"><span class="pre">as_attachment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em>)<a class="headerlink" href="#django.http.FileResponse" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#django.http.FileResponse" title="django.http.FileResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileResponse</span></code></a> 是 <a class="reference internal" href="#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> 的一个子类，它针对二进制文件进行了优化。如果 wsgi 服务器提供的话，它使用 <span class="target" id="index-32"></span><a class="pep reference external" href="https://peps.python.org/pep-3333/#optional-platform-specific-file-handling"><strong>wsgi.file_wrapper</strong></a>，否则它将文件以小块的形式流式传输出去。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">as_attachment=True</span></code>，<code class="docutils literal notranslate"><span class="pre">Content-Disposition</span></code> 头被设置为 <code class="docutils literal notranslate"><span class="pre">attachment</span></code>，要求浏览器将文件作为下载文件提供给用户。否则，只有在有文件名的情况下，才会设置值为 <code class="docutils literal notranslate"><span class="pre">inline</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Content-Disposition</span></code> 头（浏览器默认）。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">open_file</span></code> 没有名字，或者 <code class="docutils literal notranslate"><span class="pre">open_file</span></code> 的名字不合适，可以使用 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 参数提供一个自定义的文件名。请注意，如果你传递了一个类似文件的对象，比如 <code class="docutils literal notranslate"><span class="pre">io.BytesIO</span></code>，你的任务是在把它传递给 <code class="docutils literal notranslate"><span class="pre">FileResponse</span></code> 之前 <code class="docutils literal notranslate"><span class="pre">seek()`</span></code>。</p>
<p>当可以从 <code class="docutils literal notranslate"><span class="pre">open_file</span></code> 的内容猜测到时，<code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 头部将自动设置。</p>
<p>当可以从 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 或 <code class="docutils literal notranslate"><span class="pre">open_file</span></code> 的名称猜测到时，<code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 头部将自动设置。</p>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">FileResponse</span></code> 接受任何具有二进制内容的文件类似对象，例如以二进制模式打开的文件，如下所示：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.http</span> <span class="kn">import</span> <span class="n">FileResponse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">FileResponse</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile.png&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>该文件会自动关闭，所以不要用上下文管理器打开它。</p>
<div class="admonition-use-under-asgi admonition">
<p class="first admonition-title">在 ASGI 下使用</p>
<p>Python 的文件 API 是同步的。这意味着文件必须被完全消耗才能在 ASGI 下提供服务。</p>
<p class="last">为了异步流式传输文件，你需要使用提供异步文件 API 的第三方包，例如 <a class="reference external" href="https://github.com/Tinche/aiofiles">aiofiles</a>。</p>
</div>
<div class="section" id="s-id7">
<span id="id7"></span><h3>方法<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="django.http.FileResponse.set_headers">
<code class="sig-prename descclassname"><span class="pre">FileResponse.</span></code><code class="sig-name descname"><span class="pre">set_headers</span></code>(<em><span class="n"><span class="pre">open_file</span></span></em>)<a class="headerlink" href="#django.http.FileResponse.set_headers" title="永久链接至目标">¶</a></dt>
<dd><p>该方法在响应初始化过程中自动调用，并根据 <code class="docutils literal notranslate"><span class="pre">open_file</span></code> 设置各种头文件（<code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>、<code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Content-Disposition</span></code>）。</p>
</dd></dl>

</div>
</div>
<div class="section" id="s-httpresponsebase-class">
<span id="httpresponsebase-class"></span><h2><code class="docutils literal notranslate"><span class="pre">HttpResponseBase</span></code> 类<a class="headerlink" href="#httpresponsebase-class" title="永久链接至标题">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="django.http.HttpResponseBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><code class="sig-name descname"><span class="pre">HttpResponseBase</span></code><a class="headerlink" href="#django.http.HttpResponseBase" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#django.http.HttpResponseBase" title="django.http.HttpResponseBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpResponseBase</span></code></a> 类是所有 Django 响应共有的。它不应该直接用于创建响应，但在类型检查方面可能会有用。</p>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">请求和响应对象</a><ul>
<li><a class="reference internal" href="#quick-overview">快速概述</a></li>
<li><a class="reference internal" href="#httprequest-objects"><code class="docutils literal notranslate"><span class="pre">HttpRequest</span></code> 对象</a><ul>
<li><a class="reference internal" href="#attributes">属性</a></li>
<li><a class="reference internal" href="#attributes-set-by-application-code">应用程序代码设置的属性</a></li>
<li><a class="reference internal" href="#attributes-set-by-middleware">中间件设置的属性</a></li>
<li><a class="reference internal" href="#methods">方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querydict-objects"><code class="docutils literal notranslate"><span class="pre">QueryDict</span></code> 对象</a><ul>
<li><a class="reference internal" href="#id1">方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#httpresponse-objects"><code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 对象</a><ul>
<li><a class="reference internal" href="#usage">用法</a><ul>
<li><a class="reference internal" href="#passing-strings">传入字符串</a></li>
<li><a class="reference internal" href="#passing-iterators">传入迭代器</a></li>
<li><a class="reference internal" href="#setting-header-fields">设置头字段</a></li>
<li><a class="reference internal" href="#telling-the-browser-to-treat-the-response-as-a-file-attachment">告诉浏览器将响应作为文件附件处理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">属性</a></li>
<li><a class="reference internal" href="#id4">方法</a></li>
<li><a class="reference internal" href="#httpresponse-subclasses"><code class="docutils literal notranslate"><span class="pre">HttpResponse</span></code> 子类</a><ul>
<li><a class="reference internal" href="#custom-response-classes">自定义响应类</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#jsonresponse-objects"><code class="docutils literal notranslate"><span class="pre">JsonResponse</span></code> 对象</a><ul>
<li><a class="reference internal" href="#id5">用法</a><ul>
<li><a class="reference internal" href="#serializing-non-dictionary-objects">序列化非字典对象</a></li>
<li><a class="reference internal" href="#changing-the-default-json-encoder">更改默认 JSON 编码器</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#streaminghttpresponse-objects"><code class="docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code> 对象</a><ul>
<li><a class="reference internal" href="#id6">属性</a></li>
<li><a class="reference internal" href="#handling-disconnects">处理断开连接</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fileresponse-objects"><code class="docutils literal notranslate"><span class="pre">FileResponse</span></code> 对象</a><ul>
<li><a class="reference internal" href="#id7">方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#httpresponsebase-class"><code class="docutils literal notranslate"><span class="pre">HttpResponseBase</span></code> 类</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="paginator.html"
                          title="上一章">分页器</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="schema-editor.html"
                          title="下一章"><code class="docutils literal notranslate"><span class="pre">SchemaEditor</span></code></a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ref/request-response.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">2月 21, 2024</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="paginator.html" title="分页器">previous</a>
     |
    <a href="index.html" title="API 参考" accesskey="U">up</a>
   |
    <a href="schema-editor.html" title="&lt;code class=&#34;docutils literal notranslate&#34;&gt;&lt;span class=&#34;pre&#34;&gt;SchemaEditor&lt;/span&gt;&lt;/code&gt;">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>